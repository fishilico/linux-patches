From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Nicolas Iooss <nicolas.iooss_linux@m4x.org>
Date: Sat, 8 Oct 2016 14:39:21 +0200
Subject: [PATCH] {PLUGIN} Add printk format checker plugin

This plugin helped to detect the following bugs:
- 901d805c33fc ("UBSAN: fix typo in format string")
- 7703773ef1d8 ("brcmfmac: fix pmksa->bssid usage")
- 4c171636bc2b ("[media] v4l: rcar_fdp1: use %4.4s to format a 4-byte
  string")

It has also detected some bugs reported and fixed by other people:
- 7d129adff3af ("rtlwifi: rtl8192de: Fix misleading REG_MCUFWDL
  information")
---
 drivers/android/binder.c                      |   2 +-
 drivers/block/rbd.c                           |   6 +
 drivers/gpu/drm/msm/disp/dpu1/dpu_kms.c       |   2 +-
 drivers/hwtracing/intel_th/pti.c              |   3 +
 drivers/i3c/master.c                          |   3 +
 drivers/iio/adc/ad7606.c                      |   3 +
 drivers/md/bcache/sysfs.c                     |   3 +
 drivers/misc/habanalabs/goya/goya.c           |   7 +-
 drivers/net/ethernet/intel/i40e/i40e_main.c   |   4 +-
 drivers/net/ethernet/ti/davinci_emac.c        |   2 +-
 drivers/net/ethernet/ti/netcp_ethss.c         |   4 +-
 drivers/net/wireless/ath/ath10k/wmi.c         |   2 +-
 .../wireless/intel/iwlwifi/mvm/debugfs-vif.c  |   6 +-
 drivers/of/unittest.c                         |   6 +
 drivers/platform/x86/asus-laptop.c            |   4 +-
 drivers/rtc/rtc-ds1307.c                      |   3 +
 drivers/scsi/bnx2fc/bnx2fc_fcoe.c             |   2 +-
 drivers/scsi/fcoe/fcoe.c                      |   2 +-
 drivers/scsi/fcoe/fcoe_transport.c            |   4 +-
 drivers/scsi/hpsa.c                           |   2 +-
 drivers/scsi/qedf/qedf_main.c                 |   2 +-
 drivers/scsi/qedi/qedi_main.c                 |   7 +-
 drivers/scsi/smartpqi/smartpqi_init.c         |   2 +-
 drivers/target/iscsi/iscsi_target_auth.c      |   8 +-
 drivers/target/target_core_pr.c               |   2 +-
 fs/nfsd/nfsctl.c                              |   9 +-
 fs/overlayfs/inode.c                          |   3 +
 fs/reiserfs/Makefile                          |  16 +
 kernel/trace/trace_output.c                   |   3 +
 net/core/skbuff.c                             |   2 +-
 net/ipv4/sysctl_net_ipv4.c                    |   2 +-
 scripts/Makefile.gcc-plugins                  |   5 +
 scripts/gcc-plugins/Kconfig                   |   7 +
 scripts/gcc-plugins/printk_format_plugin.c    | 844 ++++++++++++++++++
 security/apparmor/mount.c                     |  10 +-
 sound/soc/stm/stm32_sai_sub.c                 |   2 +-
 sound/soc/ti/omap-mcbsp-st.c                  |   3 +
 37 files changed, 959 insertions(+), 38 deletions(-)
 create mode 100644 scripts/gcc-plugins/printk_format_plugin.c

diff --git a/drivers/android/binder.c b/drivers/android/binder.c
index 265d9dd46a5e..4c12e709e162 100644
--- a/drivers/android/binder.c
+++ b/drivers/android/binder.c
@@ -6029,7 +6029,7 @@ static void print_binder_transaction_log_entry(struct seq_file *m,
 	 * done printing the fields of the entry
 	 */
 	smp_rmb();
-	seq_printf(m, debug_id && debug_id == READ_ONCE(e->debug_id_done) ?
+	seq_printf(m, "%s", debug_id && debug_id == READ_ONCE(e->debug_id_done) ?
 			"\n" : " (incomplete)\n");
 }
 
diff --git a/drivers/block/rbd.c b/drivers/block/rbd.c
index 39136675dae5..605672a263d3 100644
--- a/drivers/block/rbd.c
+++ b/drivers/block/rbd.c
@@ -1587,9 +1587,15 @@ __rbd_obj_add_osd_request(struct rbd_obj_request *obj_req,
 	ceph_oloc_copy(&req->r_base_oloc, &rbd_dev->header_oloc);
 	req->r_base_oloc.pool = rbd_dev->layout.pool_id;
 
+/* FIXME this change should not be mandatory with the printk checker plugin
+ * (need to find the formats of a conditional)
+ */
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wformat-security"
 	ret = ceph_oid_aprintf(&req->r_base_oid, GFP_NOIO, name_format,
 			       rbd_dev->header.object_prefix,
 			       obj_req->ex.oe_objno);
+#pragma GCC diagnostic pop
 	if (ret)
 		return ERR_PTR(ret);
 
diff --git a/drivers/gpu/drm/msm/disp/dpu1/dpu_kms.c b/drivers/gpu/drm/msm/disp/dpu1/dpu_kms.c
index 58b0485dc375..d7f263751ebe 100644
--- a/drivers/gpu/drm/msm/disp/dpu1/dpu_kms.c
+++ b/drivers/gpu/drm/msm/disp/dpu1/dpu_kms.c
@@ -175,7 +175,7 @@ static int _dpu_debugfs_show_regset32(struct seq_file *s, void *data)
 	for (i = 0; i < regset->blk_len; i += 4) {
 		addr = regset->offset + i;
 		if ((addr & 0xF) == 0x0)
-			seq_printf(s, i ? "\n[%x]" : "[%x]", addr);
+			seq_printf(s, "%s[%x]", i ? "\n" : "", addr);
 		seq_printf(s, " %08x", readl_relaxed(base + i));
 	}
 	seq_puts(s, "\n");
diff --git a/drivers/hwtracing/intel_th/pti.c b/drivers/hwtracing/intel_th/pti.c
index 0da6b787f553..3a2f73f2ceb6 100644
--- a/drivers/hwtracing/intel_th/pti.c
+++ b/drivers/hwtracing/intel_th/pti.c
@@ -258,8 +258,11 @@ static ssize_t lpp_dest_show(struct device *dev, struct device_attribute *attr,
 		if (!(pti->lpp_dest_mask & BIT(i)))
 			continue;
 
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wformat-security"
 		ret += scnprintf(buf + ret, PAGE_SIZE - ret,
 				 fmt, lpp_dest_str[i]);
+#pragma GCC diagnostic pop
 	}
 
 	if (ret)
diff --git a/drivers/i3c/master.c b/drivers/i3c/master.c
index 5c051dba32a5..b324ba59613e 100644
--- a/drivers/i3c/master.c
+++ b/drivers/i3c/master.c
@@ -220,8 +220,11 @@ static ssize_t hdrcap_show(struct device *dev,
 		if (!hdrcap_strings[mode])
 			continue;
 
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wformat-security"
 		ret = sprintf(buf + offset, offset ? " %s" : "%s",
 			      hdrcap_strings[mode]);
+#pragma GCC diagnostic pop
 		if (ret < 0)
 			goto out;
 
diff --git a/drivers/iio/adc/ad7606.c b/drivers/iio/adc/ad7606.c
index f5ba94c03a8d..0d1e1cd34e4b 100644
--- a/drivers/iio/adc/ad7606.c
+++ b/drivers/iio/adc/ad7606.c
@@ -204,8 +204,11 @@ static ssize_t ad7606_show_avail(char *buf, const unsigned int *vals,
 	int i;
 
 	for (i = 0; i < n; i++) {
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wformat-security"
 		len += scnprintf(buf + len, PAGE_SIZE - len,
 			micros ? "0.%06u " : "%u ", vals[i]);
+#pragma GCC diagnostic pop
 	}
 	buf[len - 1] = '\n';
 
diff --git a/drivers/md/bcache/sysfs.c b/drivers/md/bcache/sysfs.c
index 627dcea0f5b6..7440d8cc5dd5 100644
--- a/drivers/md/bcache/sysfs.c
+++ b/drivers/md/bcache/sysfs.c
@@ -145,9 +145,12 @@ static ssize_t bch_snprint_string_list(char *buf,
 	char *out = buf;
 	size_t i;
 
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wformat-security"
 	for (i = 0; list[i]; i++)
 		out += snprintf(out, buf + size - out,
 				i == selected ? "[%s] " : "%s ", list[i]);
+#pragma GCC diagnostic pop
 
 	out[-1] = '\n';
 	return out - buf;
diff --git a/drivers/misc/habanalabs/goya/goya.c b/drivers/misc/habanalabs/goya/goya.c
index 06c5851913df..c9fbb6fe9f17 100644
--- a/drivers/misc/habanalabs/goya/goya.c
+++ b/drivers/misc/habanalabs/goya/goya.c
@@ -4974,8 +4974,8 @@ int goya_armcp_info_get(struct hl_device *hdev)
 static bool goya_is_device_idle(struct hl_device *hdev, u32 *mask,
 				struct seq_file *s)
 {
-	const char *fmt = "%-5d%-9s%#-14x%#-16x%#x\n";
-	const char *dma_fmt = "%-5d%-9s%#-14x%#x\n";
+#define fmt "%-5d%-9s%#-14x%#-16x%#x\n"
+#define dma_fmt "%-5d%-9s%#-14x%#x\n"
 	u32 qm_glbl_sts0, cmdq_glbl_sts0, dma_core_sts0, tpc_cfg_sts,
 		mme_arch_sts;
 	bool is_idle = true, is_eng_idle;
@@ -5045,7 +5045,8 @@ static bool goya_is_device_idle(struct hl_device *hdev, u32 *mask,
 				cmdq_glbl_sts0, mme_arch_sts);
 		seq_puts(s, "\n");
 	}
-
+#undef dma_fmt
+#undef fmt
 	return is_idle;
 }
 
diff --git a/drivers/net/ethernet/intel/i40e/i40e_main.c b/drivers/net/ethernet/intel/i40e/i40e_main.c
index 6031223eafab..9234d2ba3ce5 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@ -8461,7 +8461,7 @@ void i40e_do_reset(struct i40e_pf *pf, u32 reset_flags, bool lock_acquired)
 		dev_dbg(&pf->pdev->dev, "PFR requested\n");
 		i40e_handle_reset_warning(pf, lock_acquired);
 
-		dev_info(&pf->pdev->dev,
+		dev_info(&pf->pdev->dev, "%s",
 			 pf->flags & I40E_FLAG_DISABLE_FW_LLDP ?
 			 "FW LLDP is disabled\n" :
 			 "FW LLDP is enabled\n");
@@ -14986,7 +14986,7 @@ static int i40e_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	pci_set_drvdata(pdev, pf);
 	pci_save_state(pdev);
 
-	dev_info(&pdev->dev,
+	dev_info(&pdev->dev, "%s",
 		 (pf->flags & I40E_FLAG_DISABLE_FW_LLDP) ?
 			"FW LLDP is disabled\n" :
 			"FW LLDP is enabled\n");
diff --git a/drivers/net/ethernet/ti/davinci_emac.c b/drivers/net/ethernet/ti/davinci_emac.c
index ae27be85e363..a13c5798681d 100644
--- a/drivers/net/ethernet/ti/davinci_emac.c
+++ b/drivers/net/ethernet/ti/davinci_emac.c
@@ -313,7 +313,7 @@ struct emac_priv {
 	struct napi_struct napi;
 	char mac_addr[6];
 	void __iomem *remap_addr;
-	u32 emac_base_phys;
+	phys_addr_t emac_base_phys;
 	void __iomem *emac_base;
 	void __iomem *ctrl_base;
 	struct cpdma_ctlr *dma;
diff --git a/drivers/net/ethernet/ti/netcp_ethss.c b/drivers/net/ethernet/ti/netcp_ethss.c
index 2c1fac33136c..74fc8822a7a8 100644
--- a/drivers/net/ethernet/ti/netcp_ethss.c
+++ b/drivers/net/ethernet/ti/netcp_ethss.c
@@ -2352,7 +2352,7 @@ static int gbe_slave_open(struct gbe_intf *gbe_intf)
 				slave->slave_num);
 			return -ENODEV;
 		}
-		dev_dbg(priv->dev, "phy found: id is: 0x%s\n",
+		dev_dbg(priv->dev, "phy found: id is: %s\n", /* BUG? */
 			phydev_name(slave->phy));
 		phy_start(slave->phy);
 	}
@@ -3201,7 +3201,7 @@ static void init_secondary_ports(struct gbe_priv *gbe_dev,
 			dev_err(dev, "phy not found for slave %d\n",
 				slave->slave_num);
 		} else {
-			dev_dbg(dev, "phy found: id is: 0x%s\n",
+			dev_dbg(dev, "phy found: id is: %s\n", /* BUG? */
 				phydev_name(slave->phy));
 			phy_start(slave->phy);
 		}
diff --git a/drivers/net/wireless/ath/ath10k/wmi.c b/drivers/net/wireless/ath/ath10k/wmi.c
index 01924f7d0282..bd513af09fef 100644
--- a/drivers/net/wireless/ath/ath10k/wmi.c
+++ b/drivers/net/wireless/ath/ath10k/wmi.c
@@ -7362,7 +7362,7 @@ ath10k_wmi_op_gen_peer_set_param(struct ath10k *ar, u32 vdev_id,
 	ether_addr_copy(cmd->peer_macaddr.addr, peer_addr);
 
 	ath10k_dbg(ar, ATH10K_DBG_WMI,
-		   "wmi vdev %d peer 0x%pM set param %d value %d\n",
+		   "wmi vdev %d peer %pM set param %d value %d\n", /* BUG? Only place with 0x%pM */
 		   vdev_id, peer_addr, param_id, param_value);
 	return skb;
 }
diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/debugfs-vif.c b/drivers/net/wireless/intel/iwlwifi/mvm/debugfs-vif.c
index f043eefabb4e..826e3836c4ea 100644
--- a/drivers/net/wireless/intel/iwlwifi/mvm/debugfs-vif.c
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/debugfs-vif.c
@@ -582,7 +582,7 @@ static ssize_t iwl_dbgfs_low_latency_read(struct file *file,
 {
 	struct ieee80211_vif *vif = file->private_data;
 	struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
-	char format[] = "traffic=%d\ndbgfs=%d\nvcmd=%d\nvif_type=%d\n"
+	const char format[] = "traffic=%d\ndbgfs=%d\nvcmd=%d\nvif_type=%d\n"
 			"dbgfs_force_enable=%d\ndbgfs_force=%d\nactual=%d\n";
 
 	/*
@@ -592,7 +592,9 @@ static ssize_t iwl_dbgfs_low_latency_read(struct file *file,
 	char buf[sizeof(format) + 1] = {};
 	int len;
 
-	len = scnprintf(buf, sizeof(buf) - 1, format,
+	len = scnprintf(buf, sizeof(buf) - 1,
+			"traffic=%d\ndbgfs=%d\nvcmd=%d\nvif_type=%d\n"
+			"dbgfs_force_enable=%d\ndbgfs_force=%d\nactual=%d\n",
 			!!(mvmvif->low_latency & LOW_LATENCY_TRAFFIC),
 			!!(mvmvif->low_latency & LOW_LATENCY_DEBUGFS),
 			!!(mvmvif->low_latency & LOW_LATENCY_VCMD),
diff --git a/drivers/of/unittest.c b/drivers/of/unittest.c
index 92e895d86458..5d602247fa53 100644
--- a/drivers/of/unittest.c
+++ b/drivers/of/unittest.c
@@ -263,7 +263,10 @@ static void __init of_unittest_printf_one(struct device_node *np, const char *fm
 
 	/* Baseline; check conversion with a large size limit */
 	memset(buf, 0xff, buf_size);
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wformat-security"
 	size = snprintf(buf, buf_size - 2, fmt, np);
+#pragma GCC diagnostic pop
 
 	/* use strcmp() instead of strncmp() here to be absolutely sure strings match */
 	unittest((strcmp(buf, expected) == 0) && (buf[size+1] == 0xff),
@@ -275,7 +278,10 @@ static void __init of_unittest_printf_one(struct device_node *np, const char *fm
 	for (i = 0; i < 2; i++, size--) {
 		/* Clear the buffer, and make sure it works correctly still */
 		memset(buf, 0xff, buf_size);
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wformat-security"
 		snprintf(buf, size+1, fmt, np);
+#pragma GCC diagnostic pop
 		unittest(strncmp(buf, expected, size) == 0 && (buf[size+1] == 0xff),
 			"snprintf failed; size=%i fmt='%s' expected='%s' rslt='%s'\n",
 			size, fmt, expected, buf);
diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 472af7edf0af..0033ee2d4a47 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -906,11 +906,11 @@ static ssize_t infos_show(struct device *dev, struct device_attribute *attr,
 		snprintf(buf, 9, "%s", asus->dsdt_info->oem_table_id);
 		len += sprintf(page + len, "OEM table id       : %s\n", buf);
 		snprintf(buf, 16, "%x", asus->dsdt_info->oem_revision);
-		len += sprintf(page + len, "OEM revision       : 0x%s\n", buf);
+		len += sprintf(page + len, "OEM revision       : 0x %s\n", buf); /* Silence false positive "0x%s" warning */
 		snprintf(buf, 5, "%s", asus->dsdt_info->asl_compiler_id);
 		len += sprintf(page + len, "ASL comp vendor id : %s\n", buf);
 		snprintf(buf, 16, "%x", asus->dsdt_info->asl_compiler_revision);
-		len += sprintf(page + len, "ASL comp revision  : 0x%s\n", buf);
+		len += sprintf(page + len, "ASL comp revision  : 0x %s\n", buf); /* Silence false positive "0x%s" warning */
 	}
 
 	return len;
diff --git a/drivers/rtc/rtc-ds1307.c b/drivers/rtc/rtc-ds1307.c
index 1f7e8aefc1eb..11d5eea5e008 100644
--- a/drivers/rtc/rtc-ds1307.c
+++ b/drivers/rtc/rtc-ds1307.c
@@ -1149,8 +1149,11 @@ static ssize_t frequency_test_show(struct device *dev,
 
 	regmap_read(ds1307->regmap, M41TXX_REG_CONTROL, &ctrl_reg);
 
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wformat-security"
 	return scnprintf(buf, PAGE_SIZE, (ctrl_reg & M41TXX_BIT_FT) ? "on\n" :
 			"off\n");
+#pragma GCC diagnostic pop
 }
 
 static DEVICE_ATTR_RW(frequency_test);
diff --git a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c b/drivers/scsi/bnx2fc/bnx2fc_fcoe.c
index b4bfab5edf8f..a3b8bd96e891 100644
--- a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c
+++ b/drivers/scsi/bnx2fc/bnx2fc_fcoe.c
@@ -1136,7 +1136,7 @@ static int bnx2fc_vport_create(struct fc_vport *vport, bool disabled)
 	if (rc) {
 		fcoe_wwn_to_str(vport->port_name, buf, sizeof(buf));
 		printk(KERN_ERR PFX "Failed to create vport, "
-		       "WWPN (0x%s) already exists\n",
+		       "WWPN (0x %s) already exists\n", /* Silence false positive "0x%s" warning */
 		       buf);
 		return rc;
 	}
diff --git a/drivers/scsi/fcoe/fcoe.c b/drivers/scsi/fcoe/fcoe.c
index 25dae9f0b205..5b409be4f228 100644
--- a/drivers/scsi/fcoe/fcoe.c
+++ b/drivers/scsi/fcoe/fcoe.c
@@ -2669,7 +2669,7 @@ static int fcoe_vport_create(struct fc_vport *vport, bool disabled)
 	if (rc) {
 		fcoe_wwn_to_str(vport->port_name, buf, sizeof(buf));
 		printk(KERN_ERR "fcoe: Failed to create vport, "
-			"WWPN (0x%s) already exists\n",
+			"WWPN (0x %s) already exists\n", /* Silence false positive "0x%s" warning */
 			buf);
 		return rc;
 	}
diff --git a/drivers/scsi/fcoe/fcoe_transport.c b/drivers/scsi/fcoe/fcoe_transport.c
index a20ddc301c89..e1a622dc449a 100644
--- a/drivers/scsi/fcoe/fcoe_transport.c
+++ b/drivers/scsi/fcoe/fcoe_transport.c
@@ -258,7 +258,7 @@ int fcoe_validate_vport_create(struct fc_vport *vport)
 	fcoe_wwn_to_str(vport->port_name, buf, sizeof(buf));
 	/* Check if the wwpn is not same as that of the lport */
 	if (!memcmp(&n_port->wwpn, &vport->port_name, sizeof(u64))) {
-		LIBFCOE_TRANSPORT_DBG("vport WWPN 0x%s is same as that of the "
+		LIBFCOE_TRANSPORT_DBG("vport WWPN 0x %s is same as that of the " /* Silence false positive "0x%s" warning */
 				      "base port WWPN\n", buf);
 		rc = -EINVAL;
 		goto out;
@@ -267,7 +267,7 @@ int fcoe_validate_vport_create(struct fc_vport *vport)
 	/* Check if there is any existing vport with same wwpn */
 	list_for_each_entry(vn_port, &n_port->vports, list) {
 		if (!memcmp(&vn_port->wwpn, &vport->port_name, sizeof(u64))) {
-			LIBFCOE_TRANSPORT_DBG("vport with given WWPN 0x%s "
+			LIBFCOE_TRANSPORT_DBG("vport with given WWPN 0x %s " /* Silence false positive "0x%s" warning */
 					      "already exists\n", buf);
 			rc = -EINVAL;
 			break;
diff --git a/drivers/scsi/hpsa.c b/drivers/scsi/hpsa.c
index 216e557f703e..0ba56c203d36 100644
--- a/drivers/scsi/hpsa.c
+++ b/drivers/scsi/hpsa.c
@@ -6806,7 +6806,7 @@ static int fill_cmd(struct CommandList *c, u8 cmd, struct ctlr_info *h,
 			c->Request.CDB[9] = 0;
 			break;
 		default:
-			dev_warn(&h->pdev->dev, "unknown command 0x%c\n", cmd);
+			dev_warn(&h->pdev->dev, "unknown command 0x%02x\n", cmd);
 			BUG();
 		}
 	} else if (cmd_type == TYPE_MSG) {
diff --git a/drivers/scsi/qedf/qedf_main.c b/drivers/scsi/qedf/qedf_main.c
index 59ca98f12afd..eb39b43c180d 100644
--- a/drivers/scsi/qedf/qedf_main.c
+++ b/drivers/scsi/qedf/qedf_main.c
@@ -1728,7 +1728,7 @@ static int qedf_vport_create(struct fc_vport *vport, bool disabled)
 	if (rc) {
 		fcoe_wwn_to_str(vport->port_name, buf, sizeof(buf));
 		QEDF_WARN(&(base_qedf->dbg_ctx), "Failed to create vport, "
-			   "WWPN (0x%s) already exists.\n", buf);
+			   "WWPN (0x %s) already exists.\n", buf); /* Silence false positive "0x%s" warning */
 		goto err1;
 	}
 
diff --git a/drivers/scsi/qedi/qedi_main.c b/drivers/scsi/qedi/qedi_main.c
index 55bd37dad7ef..3644131010b8 100644
--- a/drivers/scsi/qedi/qedi_main.c
+++ b/drivers/scsi/qedi/qedi_main.c
@@ -1980,7 +1980,8 @@ static ssize_t qedi_show_boot_eth_info(void *data, int type, char *buf)
 	int rc = 1;
 	u32 ipv6_en, dhcp_en, ip_len;
 	struct nvm_iscsi_block *block;
-	char *fmt, *ip, *sub, *gw;
+	char *ip, *sub, *gw;
+	const char *fmt;
 
 	block = qedi_get_nvram_block(qedi);
 	if (!block)
@@ -2008,6 +2009,9 @@ static ssize_t qedi_show_boot_eth_info(void *data, int type, char *buf)
 		ip_len = ipv6_en ? 5 : 8;
 	}
 
+
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wformat-security"
 	switch (type) {
 	case ISCSI_BOOT_ETH_IP_ADDR:
 		rc = snprintf(buf, ip_len, fmt, ip);
@@ -2041,6 +2045,7 @@ static ssize_t qedi_show_boot_eth_info(void *data, int type, char *buf)
 		rc = 0;
 		break;
 	}
+#pragma GCC diagnostic pop
 
 	return rc;
 }
diff --git a/drivers/scsi/smartpqi/smartpqi_init.c b/drivers/scsi/smartpqi/smartpqi_init.c
index 919c38406ed8..f3634cc47830 100644
--- a/drivers/scsi/smartpqi/smartpqi_init.c
+++ b/drivers/scsi/smartpqi/smartpqi_init.c
@@ -507,7 +507,7 @@ static int pqi_build_raid_path_request(struct pqi_ctrl_info *ctrl_info,
 		put_unaligned_be16(cdb_length, &cdb[7]);
 		break;
 	default:
-		dev_err(&ctrl_info->pci_dev->dev, "unknown command 0x%c\n",
+		dev_err(&ctrl_info->pci_dev->dev, "unknown command 0x%02x\n",
 			cmd);
 		break;
 	}
diff --git a/drivers/target/iscsi/iscsi_target_auth.c b/drivers/target/iscsi/iscsi_target_auth.c
index 51ddca2033e0..ae82e229c5d2 100644
--- a/drivers/target/iscsi/iscsi_target_auth.c
+++ b/drivers/target/iscsi/iscsi_target_auth.c
@@ -38,10 +38,10 @@ static int chap_gen_challenge(
 	/*
 	 * Set CHAP_C, and copy the generated challenge into c_str.
 	 */
-	*c_len += sprintf(c_str + *c_len, "CHAP_C=0x%s", challenge_asciihex);
+	*c_len += sprintf(c_str + *c_len, "CHAP_C=0x %s", challenge_asciihex); /* False positives of "0x%s" */
 	*c_len += 1;
 
-	pr_debug("[%s] Sending CHAP_C=0x%s\n\n", (caller) ? "server" : "client",
+	pr_debug("[%s] Sending CHAP_C=0x %s\n\n", (caller) ? "server" : "client",
 			challenge_asciihex);
 	return 0;
 }
@@ -394,10 +394,10 @@ static int chap_server_compute_md5(
 	 * Convert response from binary hex to ascii hext.
 	 */
 	bin2hex(response, digest, MD5_SIGNATURE_SIZE);
-	*nr_out_len += sprintf(nr_out_ptr + *nr_out_len, "CHAP_R=0x%s",
+	*nr_out_len += sprintf(nr_out_ptr + *nr_out_len, "CHAP_R=0x %s", /* Silence false positive "0x%s" warning, but this introduces a bug */
 			response);
 	*nr_out_len += 1;
-	pr_debug("[server] Sending CHAP_R=0x%s\n", response);
+	pr_debug("[server] Sending CHAP_R=0x %s\n", response); /* Silence false positive "0x%s" warning */
 	auth_ret = 0;
 out:
 	kzfree(desc);
diff --git a/drivers/target/target_core_pr.c b/drivers/target/target_core_pr.c
index b09b444cc13f..15ac2fa306f6 100644
--- a/drivers/target/target_core_pr.c
+++ b/drivers/target/target_core_pr.c
@@ -50,7 +50,7 @@ void core_pr_dump_initiator_port(
 		return;
 	}
 
-	snprintf(buf, size, ",i,0x%s", pr_reg->pr_reg_isid);
+	snprintf(buf, size, ",i,0x %s", pr_reg->pr_reg_isid); /* Silence false positive "0x%s" warning */
 }
 
 enum register_type {
diff --git a/fs/nfsd/nfsctl.c b/fs/nfsd/nfsctl.c
index 11b42c523f04..4c811f6413c3 100644
--- a/fs/nfsd/nfsctl.c
+++ b/fs/nfsd/nfsctl.c
@@ -544,7 +544,6 @@ static ssize_t
 nfsd_print_version_support(struct nfsd_net *nn, char *buf, int remaining,
 		const char *sep, unsigned vers, int minor)
 {
-	const char *format = minor < 0 ? "%s%c%u" : "%s%c%u.%u";
 	bool supported = !!nfsd_vers(nn, vers, NFSD_TEST);
 
 	if (vers == 4 && minor >= 0 &&
@@ -557,7 +556,13 @@ nfsd_print_version_support(struct nfsd_net *nn, char *buf, int remaining,
 		 * +4, unless -4.0 is present.
 		 */
 		return 0;
-	return snprintf(buf, remaining, format, sep,
+	/* FIXME this change should not be mandatory with the printk checker plugin
+	 * (need to find the formats of a conditional)
+	 */
+	if (minor < 0)
+		return snprintf(buf, remaining, "%s%c%u", sep,
+				supported ? '+' : '-', vers);
+	return snprintf(buf, remaining, "%s%c%u.%u", sep,
 			supported ? '+' : '-', vers, minor);
 }
 
diff --git a/fs/overlayfs/inode.c b/fs/overlayfs/inode.c
index bc14781886bf..64a639adc124 100644
--- a/fs/overlayfs/inode.c
+++ b/fs/overlayfs/inode.c
@@ -638,8 +638,11 @@ static int ovl_set_nlink_common(struct dentry *dentry,
 	char buf[13];
 	int len;
 
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wformat-security"
 	len = snprintf(buf, sizeof(buf), format,
 		       (int) (inode->i_nlink - realinode->i_nlink));
+#pragma GCC diagnostic pop
 
 	if (WARN_ON(len >= sizeof(buf)))
 		return -EIO;
diff --git a/fs/reiserfs/Makefile b/fs/reiserfs/Makefile
index bd29c58ccbd8..31324124b84b 100644
--- a/fs/reiserfs/Makefile
+++ b/fs/reiserfs/Makefile
@@ -10,6 +10,22 @@ reiserfs-objs := bitmap.o do_balan.o namei.o inode.o file.o dir.o fix_node.o \
 		 hashes.o tail_conversion.o journal.o resize.o \
 		 item_ops.o ioctl.o xattr.o lock.o
 
+# Disable printk format checker in some files
+-include scripts/Makefile.gcc-plugins
+CFLAGS_dir.o += $(DISABLE_PRINTK_FORMAT_PLUGIN)
+CFLAGS_do_balan.o += $(DISABLE_PRINTK_FORMAT_PLUGIN)
+CFLAGS_fix_node.o += $(DISABLE_PRINTK_FORMAT_PLUGIN)
+CFLAGS_ibalance.o += $(DISABLE_PRINTK_FORMAT_PLUGIN)
+CFLAGS_inode.o += $(DISABLE_PRINTK_FORMAT_PLUGIN)
+CFLAGS_item_ops.o += $(DISABLE_PRINTK_FORMAT_PLUGIN)
+CFLAGS_lbalance.o += $(DISABLE_PRINTK_FORMAT_PLUGIN)
+CFLAGS_namei.o += $(DISABLE_PRINTK_FORMAT_PLUGIN)
+CFLAGS_prints.o += $(DISABLE_PRINTK_FORMAT_PLUGIN)
+CFLAGS_super.o += $(DISABLE_PRINTK_FORMAT_PLUGIN)
+CFLAGS_stree.o += $(DISABLE_PRINTK_FORMAT_PLUGIN)
+CFLAGS_tail_conversion.o += $(DISABLE_PRINTK_FORMAT_PLUGIN)
+CFLAGS_xattr.o += $(DISABLE_PRINTK_FORMAT_PLUGIN)
+
 ifeq ($(CONFIG_REISERFS_PROC_INFO),y)
 reiserfs-objs += procfs.o
 endif
diff --git a/kernel/trace/trace_output.c b/kernel/trace/trace_output.c
index ccd4ee0027ea..8145dbabe70f 100644
--- a/kernel/trace/trace_output.c
+++ b/kernel/trace/trace_output.c
@@ -221,8 +221,11 @@ trace_print_hex_seq(struct trace_seq *p, const unsigned char *buf, int buf_len,
 	const char *ret = trace_seq_buffer_ptr(p);
 	const char *fmt = concatenate ? "%*phN" : "%*ph";
 
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wformat-security"
 	for (i = 0; i < buf_len; i += 16)
 		trace_seq_printf(p, fmt, min(buf_len - i, 16), &buf[i]);
+#pragma GCC diagnostic pop
 	trace_seq_putc(p, 0);
 
 	return ret;
diff --git a/net/core/skbuff.c b/net/core/skbuff.c
index 42e16260f87b..3133f3337050 100644
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -759,7 +759,7 @@ void skb_dump(const char *level, const struct sk_buff *skb, bool full_pkt)
 	       ntohs(skb->protocol), skb->pkt_type, skb->skb_iif);
 
 	if (dev)
-		printk("%sdev name=%s feat=0x%pNF\n",
+		printk("%sdev name=%s feat=0x %pNF\n", /* TODO: is 0x okay? */
 		       level, dev->name, &dev->features);
 	if (sk)
 		printk("%ssk family=%hu type=%u proto=%u\n",
diff --git a/net/ipv4/sysctl_net_ipv4.c b/net/ipv4/sysctl_net_ipv4.c
index 59ded25acd04..1eca553068c5 100644
--- a/net/ipv4/sysctl_net_ipv4.c
+++ b/net/ipv4/sysctl_net_ipv4.c
@@ -289,7 +289,7 @@ static int sscanf_key(char *buf, __le32 *key)
 		for (i = 0; i < ARRAY_SIZE(user_key); i++)
 			key[i] = cpu_to_le32(user_key[i]);
 	}
-	pr_debug("proc TFO key set 0x%x-%x-%x-%x <- 0x%s: %u\n",
+	pr_debug("proc TFO key set 0x%x-%x-%x-%x <- 0x %s: %u\n", /* False-positive of 0x%s */
 		 user_key[0], user_key[1], user_key[2], user_key[3], buf, ret);
 
 	return ret;
diff --git a/scripts/Makefile.gcc-plugins b/scripts/Makefile.gcc-plugins
index 5f7df50cfe7a..b74fe31ff37f 100644
--- a/scripts/Makefile.gcc-plugins
+++ b/scripts/Makefile.gcc-plugins
@@ -10,6 +10,11 @@ ifdef CONFIG_GCC_PLUGIN_LATENT_ENTROPY
 endif
 export DISABLE_LATENT_ENTROPY_PLUGIN
 
+gcc-plugin-$(CONFIG_GCC_PLUGIN_PRINTK_FORMAT)	+= printk_format_plugin.so
+ifdef CONFIG_GCC_PLUGIN_PRINTK_FORMAT
+  DISABLE_PRINTK_FORMAT_PLUGIN			+= -fplugin-arg-printk_format_plugin-disable
+endif
+
 gcc-plugin-$(CONFIG_GCC_PLUGIN_SANCOV)		+= sancov_plugin.so
 
 gcc-plugin-$(CONFIG_GCC_PLUGIN_STRUCTLEAK)	+= structleak_plugin.so
diff --git a/scripts/gcc-plugins/Kconfig b/scripts/gcc-plugins/Kconfig
index d33de0b9f4f5..2256d93fee8c 100644
--- a/scripts/gcc-plugins/Kconfig
+++ b/scripts/gcc-plugins/Kconfig
@@ -113,4 +113,11 @@ config GCC_PLUGIN_ARM_SSP_PER_TASK
 	bool
 	depends on GCC_PLUGINS && ARM
 
+config GCC_PLUGIN_PRINTK_FORMAT
+	bool "Check printk format strings"
+	depends on GCC_PLUGINS
+	help
+	  Check printk format strings with kernel specs.
+	  This is complementary to -Wformat-security and -Wformat=2 flags.
+
 endmenu
diff --git a/scripts/gcc-plugins/printk_format_plugin.c b/scripts/gcc-plugins/printk_format_plugin.c
new file mode 100644
index 000000000000..f27ae87c8317
--- /dev/null
+++ b/scripts/gcc-plugins/printk_format_plugin.c
@@ -0,0 +1,844 @@
+/*
+ * Copyright 2016-2018 by Nicolas Iooss
+ *
+ * Check printf format string with kernel-style formatting
+ */
+
+#include "gcc-common.h"
+
+int plugin_is_GPL_compatible;
+
+static struct plugin_info printk_format_plugin_info = {
+	.version	= "20190924",
+	.help		= "Printk format checker\n",
+};
+
+/**
+ * Identifier match helpers
+ */
+static bool identifier_is(const_tree identifier, const char *str)
+{
+	size_t len = strlen(str);
+
+	if (!identifier)
+		return false;
+
+	return IDENTIFIER_LENGTH(identifier) == len && !strncmp(str, IDENTIFIER_POINTER(identifier), len);
+}
+
+/**
+ * Verify that the given value is an integer
+ */
+static bool is_integer_type(const_tree value)
+{
+	if (TREE_CODE(TREE_TYPE(value)) == INTEGER_TYPE)
+		return true;
+	if (TREE_CODE(TREE_TYPE(value)) == ENUMERAL_TYPE)
+		return true;
+	return false;
+}
+
+/**
+ * Check that the given type is 8-bit integer
+ */
+static bool is_8bit_int_type(const_tree value)
+{
+	return TREE_CODE(value) == INTEGER_TYPE &&
+		(TREE_INT_CST_ELT_CHECK(TYPE_SIZE(value), 0) == 8);
+}
+
+/**
+ * Check that the given type is 32-bit integer
+ */
+static bool is_32bit_int_type(const_tree value)
+{
+	return TREE_CODE(value) == INTEGER_TYPE &&
+		(TREE_INT_CST_ELT_CHECK(TYPE_SIZE(value), 0) == 32);
+}
+
+/**
+ * Verify that the given value is a float
+ */
+static bool is_float_type(const_tree value)
+{
+	if (TREE_CODE(TREE_TYPE(value)) == REAL_TYPE)
+		return true;
+	return false;
+}
+
+/**
+ * Verify that the given value is a string
+ */
+static bool is_string_type(const_tree value, const char *format)
+{
+	if (TREE_CODE(TREE_TYPE(value)) == POINTER_TYPE) {
+		const_tree subtype = TREE_TYPE(TREE_TYPE(value));
+		/* Check for char* */
+		if (is_8bit_int_type(subtype))
+			return true;
+
+		/* Check for void* */
+		if (TREE_CODE(subtype) == VOID_TYPE)
+			return true;
+
+		/* Check for pointer to char[] */
+		if (TREE_CODE(subtype) == ARRAY_TYPE && is_8bit_int_type(TREE_TYPE(subtype)))
+			return true;
+
+		if (!strncmp(format, "%4.4s", 5) || !strncmp(format, "%.4s", 4)) {
+			/* Check for acpi_name* ... */
+			if (TREE_CODE(subtype) == INTEGER_TYPE && identifier_is(TYPE_IDENTIFIER(subtype), "acpi_name"))
+				return true;
+			if (TREE_CODE(subtype) == UNION_TYPE && identifier_is(TYPE_IDENTIFIER(subtype), "acpi_name_union"))
+				return true;
+			if (TREE_CODE(subtype) == INTEGER_TYPE && identifier_is(TYPE_IDENTIFIER(subtype), "uint32_t"))
+				return true;
+			if (TREE_CODE(subtype) == INTEGER_TYPE && identifier_is(TYPE_IDENTIFIER(subtype), "int"))
+				return true;
+			if (TREE_CODE(subtype) == INTEGER_TYPE && identifier_is(TYPE_IDENTIFIER(subtype), "unsigned int"))
+				return true;
+			if (TREE_CODE(subtype) == INTEGER_TYPE && identifier_is(TYPE_IDENTIFIER(subtype), "u32"))
+				return true;
+			if (TREE_CODE(subtype) == INTEGER_TYPE && identifier_is(TYPE_IDENTIFIER(subtype), "__u32"))
+				return true;
+			if (TREE_CODE(subtype) == INTEGER_TYPE && identifier_is(TYPE_IDENTIFIER(subtype), "__le32"))
+				return true;
+		}
+		if (!strncmp(format, "%.8s", 4)) {
+			if (TREE_CODE(subtype) == INTEGER_TYPE && identifier_is(TYPE_IDENTIFIER(subtype), "u64"))
+				return true;
+			if (TREE_CODE(subtype) == INTEGER_TYPE && identifier_is(TYPE_IDENTIFIER(subtype), "__u64"))
+				return true;
+		}
+		/* occurence in sound/pci/mixart/mixart_core.c XXX: there is a cast to char* in the source code which seems to be lost by gcc :( */
+		if (TREE_CODE(subtype) == INTEGER_TYPE && identifier_is(TYPE_IDENTIFIER(subtype), "u32"))
+			return true;
+		if (TREE_CODE(subtype) == INTEGER_TYPE && identifier_is(TYPE_IDENTIFIER(subtype), "__be32"))
+			return true;
+		if (TREE_CODE(subtype) == INTEGER_TYPE && identifier_is(TYPE_IDENTIFIER(subtype), "u16"))
+			return true;
+		if (TREE_CODE(subtype) == ARRAY_TYPE && TREE_CODE(TREE_TYPE(subtype)) == INTEGER_TYPE)
+			return true;
+	}
+	return false;
+}
+
+/**
+ * Verify that the associated pointer type is valid
+ * c.f. Documentation/printk-formats.txt
+ */
+static bool is_fmtpointer_type(const_tree value, const char *ptr_format)
+{
+	const_tree subtype;
+
+	/* First, value need to be a pointer */
+	if (TREE_CODE(TREE_TYPE(value)) != POINTER_TYPE) {
+fprintf(stderr, "NOT PTR\n");
+		return false;
+	}
+
+	subtype = TREE_TYPE(TREE_TYPE(value));
+
+	switch (*ptr_format) {
+	/* Order of formats taken from Documentation/printk-formats.txt */
+
+	/* Symbols/Function Pointers */
+	case 'F':
+	case 'f':
+		if (TREE_CODE(subtype) == FUNCTION_TYPE)
+			return true;
+		if (TREE_CODE(subtype) == VOID_TYPE)
+			return true;
+		if (TREE_CODE(subtype) == POINTER_TYPE &&
+		    TREE_CODE(TREE_TYPE(subtype)) == FUNCTION_TYPE)
+			return true;
+		if (TREE_CODE(subtype) == INTEGER_TYPE) /* Field addr of struct kprobes */
+			return true;
+		break;
+	case 'S':
+	case 's':
+	case 'B':
+		/* Can be a pointer to anything */
+		return true;
+
+	/* Kernel pointers */
+	case 'K':
+		return true;
+
+	/* Unmodified Addresses */
+	case 'x':
+		return true;
+
+	/* Struct Resources */
+	case 'r':
+	case 'R':
+		if (TREE_CODE(subtype) == RECORD_TYPE &&
+		    identifier_is(TYPE_IDENTIFIER(subtype), "resource"))
+			return true;
+		break;
+
+	/* Physical addresses types phys_addr_t and DMA addresses types dma_addr_t */
+	case 'a':
+		/* As some code mixes both dma_addr_t and phys_addr_t with %pad
+		 * and %pap, accept both types.
+		 */
+		if (TREE_CODE(subtype) == INTEGER_TYPE && (
+		    identifier_is(TYPE_IDENTIFIER(subtype), "dma_addr_t") ||
+		    identifier_is(TYPE_IDENTIFIER(subtype), "long unsigned int") ||
+		    identifier_is(TYPE_IDENTIFIER(subtype), "phys_addr_t") ||
+		    identifier_is(TYPE_IDENTIFIER(subtype), "resource_size_t") ||
+		    identifier_is(TYPE_IDENTIFIER(subtype), "u64")))
+			return true;
+		break;
+
+	/* Raw buffer */
+	case 'E':
+		if (is_8bit_int_type(subtype))
+			return true;
+		if (TREE_CODE(subtype) == ARRAY_TYPE && is_8bit_int_type(TREE_TYPE(subtype)))
+			return true;
+		if (TREE_CODE(subtype) == VOID_TYPE)
+			return true;
+		break;
+	case 'h':
+		if (TREE_CODE(subtype) == INTEGER_TYPE)
+			return true;
+		if (TREE_CODE(subtype) == ARRAY_TYPE &&
+		    TREE_CODE(TREE_TYPE(subtype)) == INTEGER_TYPE)
+			return true;
+		if (TREE_CODE(subtype) == VOID_TYPE)
+			return true;
+		if (TREE_CODE(subtype) == RECORD_TYPE && (
+		    identifier_is(TYPE_IDENTIFIER(subtype), "atio_from_isp") ||
+		    identifier_is(TYPE_IDENTIFIER(subtype), "be_id_t") ||
+		    identifier_is(TYPE_IDENTIFIER(subtype), "nvme_feat_auto_pst") ||
+		    identifier_is(TYPE_IDENTIFIER(subtype), "ovl_fh") ||
+		    identifier_is(TYPE_IDENTIFIER(subtype), "stateid_t") ||
+		    identifier_is(TYPE_IDENTIFIER(subtype), "uwb_rceb") ||
+		    identifier_is(TYPE_IDENTIFIER(subtype), "vnt_mac_set_key")))
+			return true;
+		if (TREE_CODE(subtype) == ARRAY_TYPE &&
+		    TREE_CODE(TREE_TYPE(subtype)) == RECORD_TYPE &&
+		    identifier_is(TYPE_IDENTIFIER(TREE_TYPE(subtype)), "v4l2_rds_data"))
+			return true;
+		break;
+
+	/* MAC/FDDI addresses */
+	case 'M':
+	case 'm':
+		if (TREE_CODE(subtype) == INTEGER_TYPE)
+			return true;
+		if (TREE_CODE(subtype) == VOID_TYPE)
+			return true;
+		if (TREE_CODE(subtype) == ARRAY_TYPE &&
+		    is_8bit_int_type(TREE_TYPE(subtype)))
+			return true;
+		if (TREE_CODE(subtype) == RECORD_TYPE &&
+		    identifier_is(TYPE_IDENTIFIER(subtype), "bdaddr_t"))
+			return true;
+		if (TREE_CODE(subtype) == RECORD_TYPE &&
+		    identifier_is(TYPE_IDENTIFIER(subtype), "mac_addr"))
+			return true;
+		if (TREE_CODE(subtype) == RECORD_TYPE &&
+		    identifier_is(TYPE_IDENTIFIER(subtype), "wmi_mac_addr"))
+			return true;
+		break;
+
+	/* IPv4/IPv6 addresses */
+	case 'I':
+	case 'i':
+		if (ptr_format[1] == '4') {
+			if (TREE_CODE(subtype) == RECORD_TYPE && identifier_is(TYPE_IDENTIFIER(subtype), "in_addr"))
+				return true;
+			if (TREE_CODE(subtype) == INTEGER_TYPE && (
+			    is_8bit_int_type(subtype) ||
+			    is_32bit_int_type(subtype) ||
+			    identifier_is(TYPE_IDENTIFIER(subtype), "long unsigned int")))
+				return true;
+			if (TREE_CODE(subtype) == ARRAY_TYPE &&
+			    TREE_CODE(TREE_TYPE(subtype)) == INTEGER_TYPE)
+				return true;
+		} else if (ptr_format[1] == '6') {
+			if (TREE_CODE(subtype) == RECORD_TYPE && identifier_is(TYPE_IDENTIFIER(subtype), "in6_addr"))
+				return true;
+			if (is_8bit_int_type(subtype))
+				return true;
+			if (TREE_CODE(subtype) == ARRAY_TYPE &&
+			    TREE_CODE(TREE_TYPE(subtype)) == INTEGER_TYPE)
+				return true;
+			if (TREE_CODE(subtype) == VOID_TYPE)
+				return true;
+			if (TREE_CODE(subtype) == INTEGER_TYPE &&
+			    identifier_is(TYPE_IDENTIFIER(subtype), "u32"))
+				return true;
+		} else if (ptr_format[1] == 'S') {
+			if (TREE_CODE(subtype) == RECORD_TYPE && (
+			    identifier_is(TYPE_IDENTIFIER(subtype), "sockaddr") ||
+			    identifier_is(TYPE_IDENTIFIER(subtype), "__kernel_sockaddr_storage") ||
+			    identifier_is(TYPE_IDENTIFIER(subtype), "sockaddr_in")))
+				return true;
+			if (TREE_CODE(subtype) == ARRAY_TYPE &&
+			    TREE_CODE(TREE_TYPE(subtype)) == INTEGER_TYPE &&
+			    is_8bit_int_type(TREE_TYPE(subtype)))
+				return true;
+		}
+		if (TREE_CODE(subtype) == UNION_TYPE) /* FIXME: detect sockaddr union */
+			return true;
+		break;
+
+	/* UUID/GUID addresses */
+	case 'U':
+		if (is_8bit_int_type(subtype))
+			return true;
+		if (TREE_CODE(subtype) == ARRAY_TYPE && is_8bit_int_type(TREE_TYPE(subtype)))
+			return true;
+		if (TREE_CODE(subtype) == RECORD_TYPE && (
+		    identifier_is(TYPE_IDENTIFIER(subtype), "ceph_fsid") ||
+		    identifier_is(TYPE_IDENTIFIER(subtype), "efi_guid_t") ||
+		    identifier_is(TYPE_IDENTIFIER(subtype), "guid_t") ||
+		    identifier_is(TYPE_IDENTIFIER(subtype), "orangefs_khandle") ||
+		    identifier_is(TYPE_IDENTIFIER(subtype), "uuid_be") ||
+		    identifier_is(TYPE_IDENTIFIER(subtype), "uuid_le") ||
+		    identifier_is(TYPE_IDENTIFIER(subtype), "uuid_t")))
+			return true;
+		break;
+
+	/* dentry names */
+	case 'd':
+		if (TREE_CODE(subtype) == RECORD_TYPE &&
+		    identifier_is(TYPE_IDENTIFIER(subtype), "dentry"))
+			return true;
+		if (TREE_CODE(subtype) == VOID_TYPE) /* for NULL */
+			return true;
+		break;
+	case 'D':
+		if (TREE_CODE(subtype) == RECORD_TYPE &&
+		    identifier_is(TYPE_IDENTIFIER(subtype), "file"))
+			return true;
+		if (TREE_CODE(subtype) == VOID_TYPE) /* for NULL */
+			return true;
+		break;
+
+	/* block_device names */
+	case 'g':
+		if (TREE_CODE(subtype) == RECORD_TYPE &&
+		    identifier_is(TYPE_IDENTIFIER(subtype), "block_device"))
+			return true;
+		break;
+
+	/* struct va_format */
+	case 'V':
+		if (TREE_CODE(subtype) == RECORD_TYPE &&
+		    identifier_is(TYPE_IDENTIFIER(subtype), "va_format"))
+			return true;
+		break;
+
+	/* struct clk */
+	case 'C':
+		if (TREE_CODE(subtype) == RECORD_TYPE &&
+		    identifier_is(TYPE_IDENTIFIER(subtype), "clk"))
+			return true;
+		break;
+
+	/* struct rtc_time */
+	case 't':
+		if (TREE_CODE(subtype) == RECORD_TYPE &&
+		    identifier_is(TYPE_IDENTIFIER(subtype), "rtc_time"))
+			return true;
+		break;
+
+	/* bitmap and its derivatives such as cpumask and nodemask */
+	case 'b':
+		if (TREE_CODE(subtype) == INTEGER_TYPE)
+			return true;
+		if (TREE_CODE(subtype) == VOID_TYPE)
+			return true;
+		if (TREE_CODE(subtype) == ARRAY_TYPE &&
+		    TREE_CODE(TREE_TYPE(subtype)) == INTEGER_TYPE)
+			return true;
+		if (TREE_CODE(subtype) == RECORD_TYPE && (
+		    identifier_is(TYPE_IDENTIFIER(subtype), "cpumask") ||
+		    identifier_is(TYPE_IDENTIFIER(subtype), "cpumask_t")))
+			return true;
+		break;
+
+	/* Flags bitfields such as page flags, gfp_flags */
+	case 'G':
+		if (TREE_CODE(subtype) == INTEGER_TYPE &&
+		    identifier_is(TYPE_IDENTIFIER(subtype), "gfp_t"))
+			return true;
+		if (TREE_CODE(subtype) == INTEGER_TYPE &&
+		    identifier_is(TYPE_IDENTIFIER(subtype), "long unsigned int"))
+			return true;
+		break;
+
+	/* Network device features */
+	case 'N':
+		if (ptr_format[1] == 'F') {
+			if (TREE_CODE(subtype) == INTEGER_TYPE &&
+			    identifier_is(TYPE_IDENTIFIER(subtype), "netdev_features_t"))
+				return true;
+			if (TREE_CODE(subtype) == INTEGER_TYPE &&
+			    identifier_is(TYPE_IDENTIFIER(subtype), "long long unsigned int"))
+				return true;
+		}
+		break;
+
+	/* kobject based struct */
+	case 'O':
+		if (ptr_format[1] == 'F') {
+			if (TREE_CODE(subtype) == VOID_TYPE)
+				return true;
+			if (TREE_CODE(subtype) == RECORD_TYPE &&
+			    identifier_is(TYPE_IDENTIFIER(subtype), "device_node"))
+				return true;
+		}
+		break;
+
+	/* Raw pointers (everything else after %p) */
+	case '\0':
+	case '\t':
+	case '\n':
+	case ' ':
+	case '!':
+	case '"':
+	case '#':
+	case '$':
+	case '%':
+	case '\'':
+	case '(':
+	case ')':
+	case '+':
+	case ',':
+	case '-':
+	case '.':
+	case '/':
+	case '0':
+	case ':':
+	case ';':
+	case '<':
+	case '=':
+	case '>':
+	case '?':
+	case '@':
+	case '[':
+	case '\\':
+	case ']':
+	case '^':
+	case '_':
+	case '{':
+	case '|':
+	case '}':
+		return true;
+	}
+
+	debug_tree(value);
+	return false;
+}
+
+/* Function from Emese's initify_plugin
+ * https://github.com/ephox-gcc-plugins/initify/blob/master/initify_plugin.c
+ */
+static const_tree get_string_cst(const_tree var)
+{
+	if (var == NULL_TREE)
+		return NULL_TREE;
+
+	if (TREE_CODE(var) == STRING_CST)
+		return var;
+
+	switch (TREE_CODE_CLASS(TREE_CODE(var))) {
+	case tcc_expression:
+	case tcc_reference: {
+		int i;
+
+		for (i = 0; i < TREE_OPERAND_LENGTH(var); i++) {
+			const_tree ret = get_string_cst(TREE_OPERAND(var, i));
+
+			if (ret != NULL_TREE)
+				return ret;
+		}
+		break;
+	case tcc_declaration:
+		/* const char [] variable with known content */
+		if (TYPE_READONLY(var)) {
+			const_tree subtype = TREE_TYPE(var);
+			if (TREE_CODE(subtype) == ARRAY_TYPE && is_8bit_int_type(TREE_TYPE(subtype))) {
+				return get_string_cst(DECL_INITIAL(var));
+			}
+		}
+		break;
+	}
+
+	default:
+		break;
+	}
+	return NULL_TREE;
+}
+
+/**
+ * Get the printf format attribute of a function, or NULL_TREE if it does not exist
+ *
+ * The first parameter of the printf attribute is given by:
+ *    TREE_INT_CST_ELT(TREE_VALUE(ret), 0)
+ * and the second one by:
+ *    TREE_INT_CST_ELT(TREE_VALUE(TREE_CHAIN(ret)), 0)
+ */
+static const_tree get_printf_attribute(location_t loc, const_tree fntype)
+{
+	const_tree attr, attrval;
+
+	/* Look up "format" attribute in declaration type */
+	attr = lookup_attribute("format", TYPE_ATTRIBUTES(fntype));
+	if (attr == NULL_TREE)
+		return NULL_TREE;
+
+	/* Filter "printf" value */
+	attrval = TREE_VALUE(attr);
+	if (attrval == NULL_TREE)
+		return NULL_TREE;
+	if (identifier_is(TREE_VALUE(attrval), "printf") ||
+	    identifier_is(TREE_VALUE(attrval), "__printf__") ||
+	    identifier_is(TREE_VALUE(attrval), "gnu_printf")) {
+		return TREE_CHAIN(attrval);
+	}
+
+	/* Ignore "scanf" format attribute */
+	if (identifier_is(TREE_VALUE(attrval), "scanf") ||
+	    identifier_is(TREE_VALUE(attrval), "__scanf__") ||
+	    identifier_is(TREE_VALUE(attrval), "gnu_scanf")) {
+		return NULL_TREE;
+	}
+	warning_at(loc, OPT_Wall, G_("Unknown format parameter %s\n"),
+		   IDENTIFIER_POINTER(TREE_VALUE(attrval)));
+	return NULL_TREE;
+}
+
+/**
+ * Get the type of the specified argument in the function declaration
+ *
+ * argidx = 1 for the first argument, 2 for the second one, etc.
+ */
+static const_tree get_fct_arg_type(const_tree fntype, HOST_WIDE_INT argidx)
+{
+	const_tree arg_type;
+	function_args_iterator arg_iter;
+
+	gcc_assert(argidx > 0);
+	FOREACH_FUNCTION_ARGS(fntype, arg_type, arg_iter) {
+		argidx -= 1;
+		if (!argidx)
+			return arg_type;
+	}
+	/* the call should has been made with "argidx <= gimple_call_num_args(call_stmt)" */
+	gcc_assert(false);
+}
+
+/**
+ * Analyze the calls to functions using printf-formatted arguments in a GIMPLE
+ * statement
+ */
+static void analyze_statement(gimple stmt)
+{
+	gcall *call_stmt;
+	const_tree printf_attr, fmtarg_type;
+	HOST_WIDE_INT fmt_idx, arg_idx;
+	const_tree fntype, format_tree, arg_tree;
+	int format_length;
+	const char *format;
+	unsigned int argnum;
+
+	/* Get the function declaration */
+	call_stmt = as_a_gcall(stmt);
+	fntype = gimple_call_fntype(call_stmt);
+	if (fntype == NULL_TREE) {
+		/* This happens when calling var_arg(), multiplication
+		 * overflow, ASAN...
+		 */
+		if (gimple_call_internal_p(call_stmt)) {
+			return;
+		}
+		warning_at(gimple_location(stmt), 0,
+			   G_("Unable to get the function type\n"));
+		debug_gimple_stmt(stmt); /* TODO remove? */
+		return;
+	}
+
+	/* Get the printf format attribute */
+	printf_attr = get_printf_attribute(gimple_location(stmt), fntype);
+	if (!printf_attr)
+		return;
+	fmt_idx = TREE_INT_CST_ELT(TREE_VALUE(printf_attr), 0);
+	arg_idx = TREE_INT_CST_ELT(TREE_VALUE(TREE_CHAIN(printf_attr)), 0);
+
+	/* Sanity checks on the number of arguments */
+	argnum = gimple_call_num_args(call_stmt);
+	if (fmt_idx < 1 || fmt_idx > argnum) {
+		warning_at(gimple_location(stmt), OPT_Wformat_,
+			   G_("Invalid call to function with attribute __printf(%lu, %lu)\n"),
+			   fmt_idx, arg_idx);
+		return;
+	}
+	if (arg_idx < 0 || arg_idx > argnum + 1) {
+		warning_at(gimple_location(stmt), OPT_Wformat_,
+			   G_("Invalid call to function with attribute __printf(%lu, %lu)\n"),
+			   fmt_idx, arg_idx);
+		return;
+	}
+
+	/* Warn if the format attribute type is not const char* */
+	fmtarg_type = get_fct_arg_type(fntype, fmt_idx);
+	if (TREE_CODE(fmtarg_type) != POINTER_TYPE ||
+	    !is_8bit_int_type(TREE_TYPE(fmtarg_type))) {
+		warning_at(gimple_location(stmt), OPT_Wformat_,
+			G_("Unexpected type for printf format attribute (not a char*)\n"));
+	} else if (!TYPE_READONLY(TREE_TYPE(fmtarg_type))) {
+		warning_at(gimple_location(stmt), OPT_Wformat_,
+			   G_("Call to a function with a non-const char* format\n"));
+	}
+
+	/* Do not play with va_args-based functions */
+	if (arg_idx == 0)
+		return;
+
+	/* Skip NULL format */
+	format_tree = gimple_call_arg(call_stmt, fmt_idx - 1);
+	if (TREE_CODE(format_tree) == INTEGER_CST &&
+	    TREE_INT_CST_ELT_CHECK(format_tree, 0) == 0)
+		return;
+
+	/* Retrieve the format string */
+	format_tree = get_string_cst(format_tree);
+	if (format_tree == NULL_TREE) {
+		warning_at(gimple_location(call_stmt), OPT_Wformat_security,
+			   G_("Call with a non-constant string\n"));
+		return;
+	}
+	gcc_assert(TREE_CODE(format_tree) == STRING_CST);
+	format_length = TREE_STRING_LENGTH(format_tree);
+	if (!format_length)
+		return;
+	format = TREE_STRING_POINTER(format_tree);
+	if (strnlen(format, format_length) != format_length - 1) {
+		/* drivers/isdn/hardware/eicon/ uses dprintf("\000\377", ...)
+		 * as a legitimate way, with no % sign.
+		 */
+		if (format[0] != '\0' || memchr(format, '%', format_length)) {
+			warning_at(gimple_location(call_stmt), OPT_Wformat_,
+				   G_("Call with a a format which contains nul character\n"));
+		}
+		return;
+	}
+
+	while (*format) {
+		bool found, has_hex_prefix = false;
+		const char *subs_start = format;
+		unsigned int star_count = 0;
+
+		/* Found errors such as "0x%d" */
+		if (format[0] == '0' && format[1] == 'x' && format[2] == '%') {
+			/* go to the % sign and skip over format modifiers */
+			format += 2;
+			has_hex_prefix = true;
+		}
+
+		/* Skip normal characters */
+		if (*format != '%') {
+			format++;
+			continue;
+		}
+
+		/* Skip "%%" */
+		if (format[1] == '%') {
+			format += 2;
+			continue;
+		}
+
+		/* Found a % sign, skip format prefix */
+		found = true;
+		while (found) {
+			format++;
+			switch (*format) {
+			case '-':
+			case '+':
+			case ' ':
+			case '.':
+			case '#':
+			case '0': case '1': case '2': case '3': case '4':
+			case '5': case '6': case '7': case '8': case '9':
+			case 'h': case 'l': case 'L': case 't':
+			case 'z':
+				break;
+			case '*':
+				/* There may be several stars, like "%*.*s" */
+				star_count++;
+				break;
+			default:
+				found = false;
+			}
+		}
+
+		/* Get the current argument for the format */
+		if (arg_idx > argnum) {
+			warning_at(gimple_location(call_stmt), OPT_Wformat_,
+				   G_("Not enough arguments for format\n"));
+			return;
+		}
+		arg_tree = gimple_call_arg(call_stmt, arg_idx - 1);
+		arg_idx++;
+
+		while (star_count) {
+			/* size argument is an integer */
+			if (!is_integer_type(arg_tree)) {
+				warning_at(gimple_location(call_stmt),
+					   OPT_Wformat_,
+					   G_("Argument for the size of %.*s is not an integer\n"),
+					   format + 1 - subs_start, subs_start);
+			}
+
+			/* Get the next argument */
+			if (arg_idx > argnum) {
+				warning_at(gimple_location(call_stmt),
+					   OPT_Wformat_,
+					   G_("Not enough arguments for format\n"));
+				return;
+			}
+			arg_tree = gimple_call_arg(call_stmt, arg_idx - 1);
+			arg_idx++;
+			star_count--;
+		}
+
+		/* Check the format for hexadecimal. Allow:
+		 * - 0x%x, 0x%lx, 0x%X...
+		 * - 0x%p without any pointer modifier
+		 * - 0x%pK, 0x%pad, 0x*phN...
+		 */
+#define ALLOW_0xPTR_CHARS "abhKx:-.;,'/ )]\t\n"
+		if (has_hex_prefix && !(strchr("xX", *format) ||
+		    (*format == 'p' && memchr(ALLOW_0xPTR_CHARS, format[1], sizeof(ALLOW_0xPTR_CHARS))))) {
+			warning_at(gimple_location(call_stmt),
+				   OPT_Wformat_,
+				   G_("Bad format with 0x prefix: %.*s\n"),
+				   format + 1 - subs_start, subs_start);
+			/* Do not continue nor return in order to check the
+			 * consistency of the argument type too/
+			 */
+		}
+
+		/* Check the format */
+		switch (*format) {
+		case 'c':
+		case 'd':
+		case 'i':
+		case 'o':
+		case 'u':
+		case 'x':
+		case 'X':
+			/* integer type */
+			if (!is_integer_type(arg_tree)) {
+				warning_at(gimple_location(call_stmt),
+					   OPT_Wformat_,
+					   G_("Argument for %.*s is not an integer\n"),
+					   format + 1 - subs_start, subs_start);
+			}
+			format++;
+			break;
+		case 'f':
+			/* float type */
+			if (!is_float_type(arg_tree)) {
+				warning_at(gimple_location(call_stmt),
+					   OPT_Wformat_,
+					   G_("Argument for %.*s is not a float\n"),
+					   format + 1 - subs_start, subs_start);
+			}
+			format++;
+			break;
+		case 's':
+			/* string type */
+			if (!is_string_type(arg_tree, subs_start)) {
+				warning_at(gimple_location(call_stmt),
+					   OPT_Wformat_,
+					   G_("Argument for %.*s is not a string\n"),
+					   format + 1 - subs_start, subs_start);
+			}
+			format++;
+			break;
+		case 'p':
+			/* pointer type */
+			if (!is_fmtpointer_type(arg_tree, format + 1)) {
+				warning_at(gimple_location(call_stmt),
+					   OPT_Wformat_,
+					   G_("Argument for %.*s is not a pointer with a matching type\n"),
+					   format + 2 - subs_start, subs_start);
+			}
+			format++;
+			break;
+		default:
+			warning_at(gimple_location(call_stmt), OPT_Wformat_,
+				   G_("Unexpected format %s\n"), format);
+			format++;
+		}
+	}
+}
+
+static unsigned int printk_format_execute(void)
+{
+	basic_block bb;
+
+	FOR_EACH_BB_FN(bb, cfun) {
+		gimple_stmt_iterator gsi;
+
+		for (gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi)) {
+			gimple stmt;
+
+			/* Get the statement */
+			stmt = gsi_stmt(gsi);
+			if (!is_gimple_call(stmt))
+				continue;
+
+			analyze_statement(stmt);
+		}
+	}
+
+	return 0;
+}
+
+#define PASS_NAME printk_format
+
+#define NO_GATE
+#define TODO_FLAGS_FINISH TODO_dump_func
+
+#include "gcc-generate-gimple-pass.h"
+
+int plugin_init(struct plugin_name_args *plugin_info, struct plugin_gcc_version *version)
+{
+	const char * const plugin_name = plugin_info->base_name;
+	const int argc = plugin_info->argc;
+	const struct plugin_argument * const argv = plugin_info->argv;
+	int i;
+	bool enabled = true;
+
+	PASS_INFO(printk_format, "ssa", 1, PASS_POS_INSERT_AFTER);
+
+	if (!plugin_default_version_check(version, &gcc_version)) {
+		error(G_("incompatible gcc/plugin versions"));
+		return 1;
+	}
+
+	for (i = 0; i < argc; ++i) {
+		if (!(strcmp(argv[i].key, "disable"))) {
+			enabled = false;
+			continue;
+		}
+		error(G_("unkown option '-fplugin-arg-%s-%s'"), plugin_name, argv[i].key);
+	}
+
+	register_callback(plugin_name, PLUGIN_INFO, NULL,
+				&printk_format_plugin_info);
+	if (enabled) {
+		register_callback(plugin_name, PLUGIN_PASS_MANAGER_SETUP, NULL,
+					&printk_format_pass_info);
+	}
+
+	return 0;
+}
diff --git a/security/apparmor/mount.c b/security/apparmor/mount.c
index 17081c8dbefa..8fb937f48363 100644
--- a/security/apparmor/mount.c
+++ b/security/apparmor/mount.c
@@ -49,7 +49,7 @@ static void audit_mnt_flags(struct audit_buffer *ab, unsigned long flags)
 	if (flags & MS_NODIRATIME)
 		audit_log_format(ab, ", nodiratime");
 	if (flags & MS_BIND)
-		audit_log_format(ab, flags & MS_REC ? ", rbind" : ", bind");
+		audit_log_format(ab, "%s", flags & MS_REC ? ", rbind" : ", bind");
 	if (flags & MS_MOVE)
 		audit_log_format(ab, ", move");
 	if (flags & MS_SILENT)
@@ -57,16 +57,16 @@ static void audit_mnt_flags(struct audit_buffer *ab, unsigned long flags)
 	if (flags & MS_POSIXACL)
 		audit_log_format(ab, ", acl");
 	if (flags & MS_UNBINDABLE)
-		audit_log_format(ab, flags & MS_REC ? ", runbindable" :
+		audit_log_format(ab, "%s", flags & MS_REC ? ", runbindable" :
 				 ", unbindable");
 	if (flags & MS_PRIVATE)
-		audit_log_format(ab, flags & MS_REC ? ", rprivate" :
+		audit_log_format(ab, "%s", flags & MS_REC ? ", rprivate" :
 				 ", private");
 	if (flags & MS_SLAVE)
-		audit_log_format(ab, flags & MS_REC ? ", rslave" :
+		audit_log_format(ab, "%s", flags & MS_REC ? ", rslave" :
 				 ", slave");
 	if (flags & MS_SHARED)
-		audit_log_format(ab, flags & MS_REC ? ", rshared" :
+		audit_log_format(ab, "%s", flags & MS_REC ? ", rshared" :
 				 ", shared");
 	if (flags & MS_RELATIME)
 		audit_log_format(ab, ", relatime");
diff --git a/sound/soc/stm/stm32_sai_sub.c b/sound/soc/stm/stm32_sai_sub.c
index 48e629ac2d88..1c8ed244d758 100644
--- a/sound/soc/stm/stm32_sai_sub.c
+++ b/sound/soc/stm/stm32_sai_sub.c
@@ -526,7 +526,7 @@ static int stm32_sai_set_sysclk(struct snd_soc_dai *cpu_dai,
 
 		ret = clk_set_rate_exclusive(sai->sai_mclk, freq);
 		if (ret) {
-			dev_err(cpu_dai->dev,
+			dev_err(cpu_dai->dev, "%s",
 				ret == -EBUSY ?
 				"Active streams have incompatible rates" :
 				"Could not set mclk rate\n");
diff --git a/sound/soc/ti/omap-mcbsp-st.c b/sound/soc/ti/omap-mcbsp-st.c
index 1a3fe854e856..5029a7ef66f2 100644
--- a/sound/soc/ti/omap-mcbsp-st.c
+++ b/sound/soc/ti/omap-mcbsp-st.c
@@ -246,9 +246,12 @@ static ssize_t st_taps_show(struct device *dev,
 	int i;
 
 	spin_lock_irq(&mcbsp->lock);
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wformat-security"
 	for (i = 0; i < st_data->nr_taps; i++)
 		status += sprintf(&buf[status], (i ? ", %d" : "%d"),
 				  st_data->taps[i]);
+#pragma GCC diagnostic pop
 	if (i)
 		status += sprintf(&buf[status], "\n");
 	spin_unlock_irq(&mcbsp->lock);
-- 
