From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Nicolas Iooss <nicolas.iooss_linux@m4x.org>
Date: Sat, 8 Oct 2016 14:39:21 +0200
Subject: [PATCH] {PLUGIN} Add printk format checker plugin

This plugin helped to detect the following bugs:
- 901d805c33fc ("UBSAN: fix typo in format string")
- 7703773ef1d8 ("brcmfmac: fix pmksa->bssid usage")
- 4c171636bc2b ("[media] v4l: rcar_fdp1: use %4.4s to format a 4-byte
  string")

It has also detected some bugs reported and fixed by other people:
- 7d129adff3af ("rtlwifi: rtl8192de: Fix misleading REG_MCUFWDL
  information")
---
 drivers/accel/habanalabs/common/decoder.c     |   3 +-
 drivers/accel/habanalabs/gaudi2/gaudi2.c      |  21 +-
 .../accel/habanalabs/gaudi2/gaudi2_security.c |   8 +-
 drivers/accel/habanalabs/goya/goya.c          |   7 +-
 drivers/android/binder.c                      |   2 +-
 drivers/block/rbd.c                           |   6 +
 drivers/fpga/xilinx-spi.c                     |   3 +
 .../gpu/drm/amd/amdgpu/amdgpu_ras_eeprom.c    |   6 +
 drivers/gpu/drm/msm/disp/dpu1/dpu_kms.c       |   2 +-
 drivers/hv/vmbus_drv.c                        |   3 +-
 drivers/hwtracing/intel_th/pti.c              |   3 +
 drivers/i2c/busses/i2c-bcm-iproc.c            |   2 +-
 drivers/i3c/master.c                          |   3 +
 drivers/iio/adc/ad7606.c                      |   3 +
 drivers/input/joystick/analog.c               |  13 +-
 drivers/md/bcache/sysfs.c                     |   3 +
 drivers/md/dm-ebs-target.c                    |   9 +-
 drivers/media/i2c/ccs/ccs-reg-access.c        |   2 +-
 .../net/ethernet/fungible/funcore/fun_queue.c |   9 +-
 drivers/net/ethernet/intel/i40e/i40e_main.c   |   4 +-
 drivers/net/ethernet/ti/davinci_emac.c        |   2 +-
 drivers/net/ethernet/ti/netcp_ethss.c         |   4 +-
 drivers/net/wireless/ath/ath10k/wmi.c         |   2 +-
 drivers/net/wireless/ath/ath11k/mac.c         |   2 +-
 drivers/net/wireless/ath/ath12k/wmi.c         |   2 +-
 .../wireless/intel/iwlwifi/mvm/debugfs-vif.c  |   6 +-
 drivers/net/wireless/silabs/wfx/hif_rx.c      |   2 +-
 drivers/of/platform.c                         |  25 +-
 drivers/of/unittest.c                         |   6 +
 drivers/platform/x86/asus-laptop.c            |   4 +-
 drivers/rtc/rtc-ds1307.c                      |   3 +
 drivers/scsi/bnx2fc/bnx2fc_fcoe.c             |   2 +-
 drivers/scsi/fcoe/fcoe.c                      |   2 +-
 drivers/scsi/fcoe/fcoe_transport.c            |   4 +-
 drivers/scsi/hpsa.c                           |   2 +-
 drivers/scsi/qedf/qedf_main.c                 |   2 +-
 drivers/scsi/qedi/qedi_main.c                 |   7 +-
 drivers/scsi/smartpqi/smartpqi_init.c         |   2 +-
 drivers/staging/pi433/pi433_if.c              |   3 +-
 drivers/target/iscsi/iscsi_target_auth.c      |   8 +-
 drivers/target/target_core_pr.c               |   2 +-
 drivers/usb/gadget/function/f_uac1.c          |   5 +
 drivers/usb/gadget/function/f_uac2.c          |   6 +
 fs/afs/dir.c                                  |   5 +-
 fs/crypto/keysetup.c                          |   2 +-
 fs/nfsd/nfsctl.c                              |   9 +-
 fs/nfsd/trace.h                               |   2 +-
 fs/overlayfs/inode.c                          |   3 +
 fs/reiserfs/Makefile                          |  16 +
 include/trace/events/dlm.h                    |   6 +-
 kernel/bpf/btf.c                              |   6 +
 kernel/trace/trace_output.c                   |   7 +-
 lib/bitmap.c                                  |   7 +-
 mm/damon/dbgfs.c                              |   6 +-
 net/ipv4/sysctl_net_ipv4.c                    |   2 +-
 net/tipc/crypto.c                             |   3 +
 scripts/Makefile.gcc-plugins                  |   7 +
 scripts/gcc-plugins/Kconfig                   |   7 +
 scripts/gcc-plugins/printk_format_plugin.c    | 919 ++++++++++++++++++
 security/apparmor/mount.c                     |  10 +-
 sound/soc/apple/mca.c                         |   4 +-
 sound/soc/intel/boards/sof_sdw.c              |   7 +-
 sound/soc/stm/stm32_sai_sub.c                 |   2 +-
 sound/soc/ti/omap-mcbsp-st.c                  |   3 +
 tools/lib/bpf/relo_core.c                     |   6 +
 65 files changed, 1157 insertions(+), 97 deletions(-)
 create mode 100644 scripts/gcc-plugins/printk_format_plugin.c

diff --git a/drivers/accel/habanalabs/common/decoder.c b/drivers/accel/habanalabs/common/decoder.c
index c03a6da45d00..bc1547b32187 100644
--- a/drivers/accel/habanalabs/common/decoder.c
+++ b/drivers/accel/habanalabs/common/decoder.c
@@ -19,7 +19,6 @@
 
 static void dec_print_abnrm_intr_source(struct hl_device *hdev, u32 irq_status)
 {
-	const char *format = "abnormal interrupt source:%s%s%s%s%s%s\n";
 	char *intr_source[6] = {"Unknown", "", "", "", "", ""};
 	int i = 0;
 
@@ -39,7 +38,7 @@ static void dec_print_abnrm_intr_source(struct hl_device *hdev, u32 irq_status)
 	if (irq_status & VCMD_IRQ_STATUS_RESET_MASK)
 		intr_source[i++] = " RESET";
 
-	dev_err(hdev->dev, format, intr_source[0], intr_source[1],
+	dev_err(hdev->dev, "abnormal interrupt source:%s%s%s%s%s%s\n", intr_source[0], intr_source[1],
 		intr_source[2], intr_source[3], intr_source[4], intr_source[5]);
 }
 
diff --git a/drivers/accel/habanalabs/gaudi2/gaudi2.c b/drivers/accel/habanalabs/gaudi2/gaudi2.c
index 9126c802934b..839b6420bca6 100644
--- a/drivers/accel/habanalabs/gaudi2/gaudi2.c
+++ b/drivers/accel/habanalabs/gaudi2/gaudi2.c
@@ -7000,7 +7000,6 @@ static bool gaudi2_get_edma_idle_status(struct hl_device *hdev, u64 *mask_arr, u
 	u32 qm_glbl_sts0, qm_glbl_sts1, qm_cgm_sts, dma_core_sts0, dma_core_sts1;
 	struct asic_fixed_properties *prop = &hdev->asic_prop;
 	unsigned long *mask = (unsigned long *) mask_arr;
-	const char *edma_fmt = "%-6d%-6d%-9s%#-14x%#-15x%#x\n";
 	bool is_idle = true, is_eng_idle;
 	int engine_idx, i, j;
 	u64 offset;
@@ -7036,7 +7035,7 @@ static bool gaudi2_get_edma_idle_status(struct hl_device *hdev, u64 *mask_arr, u
 				set_bit(engine_idx, mask);
 
 			if (e)
-				hl_engine_data_sprintf(e, edma_fmt, i, j, is_eng_idle ? "Y" : "N",
+				hl_engine_data_sprintf(e, "%-6d%-6d%-9s%#-14x%#-15x%#x\n", i, j, is_eng_idle ? "Y" : "N",
 							qm_glbl_sts0, dma_core_sts0, dma_core_sts1);
 		}
 	}
@@ -7049,7 +7048,6 @@ static bool gaudi2_get_pdma_idle_status(struct hl_device *hdev, u64 *mask_arr, u
 {
 	u32 qm_glbl_sts0, qm_glbl_sts1, qm_cgm_sts, dma_core_sts0, dma_core_sts1;
 	unsigned long *mask = (unsigned long *) mask_arr;
-	const char *pdma_fmt = "%-6d%-9s%#-14x%#-15x%#x\n";
 	bool is_idle = true, is_eng_idle;
 	int engine_idx, i;
 	u64 offset;
@@ -7077,7 +7075,7 @@ static bool gaudi2_get_pdma_idle_status(struct hl_device *hdev, u64 *mask_arr, u
 			set_bit(engine_idx, mask);
 
 		if (e)
-			hl_engine_data_sprintf(e, pdma_fmt, i, is_eng_idle ? "Y" : "N",
+			hl_engine_data_sprintf(e, "%-6d%-9s%#-14x%#-15x%#x\n", i, is_eng_idle ? "Y" : "N",
 						qm_glbl_sts0, dma_core_sts0, dma_core_sts1);
 	}
 
@@ -7088,7 +7086,6 @@ static bool gaudi2_get_nic_idle_status(struct hl_device *hdev, u64 *mask_arr, u8
 		struct engines_data *e)
 {
 	unsigned long *mask = (unsigned long *) mask_arr;
-	const char *nic_fmt = "%-5d%-9s%#-14x%#-12x\n";
 	u32 qm_glbl_sts0, qm_glbl_sts1, qm_cgm_sts;
 	bool is_idle = true, is_eng_idle;
 	int engine_idx, i;
@@ -7123,7 +7120,7 @@ static bool gaudi2_get_nic_idle_status(struct hl_device *hdev, u64 *mask_arr, u8
 			set_bit(engine_idx, mask);
 
 		if (e)
-			hl_engine_data_sprintf(e, nic_fmt, i, is_eng_idle ? "Y" : "N",
+			hl_engine_data_sprintf(e, "%-5d%-6s%#-14x%#x\n", i, is_eng_idle ? "Y" : "N",
 						qm_glbl_sts0, qm_cgm_sts);
 	}
 
@@ -7135,7 +7132,6 @@ static bool gaudi2_get_mme_idle_status(struct hl_device *hdev, u64 *mask_arr, u8
 {
 	u32 qm_glbl_sts0, qm_glbl_sts1, qm_cgm_sts, mme_arch_sts;
 	unsigned long *mask = (unsigned long *) mask_arr;
-	const char *mme_fmt = "%-5d%-6s%-9s%#-14x%#x\n";
 	bool is_idle = true, is_eng_idle;
 	int engine_idx, i;
 	u64 offset;
@@ -7161,7 +7157,7 @@ static bool gaudi2_get_mme_idle_status(struct hl_device *hdev, u64 *mask_arr, u8
 		is_idle &= is_eng_idle;
 
 		if (e)
-			hl_engine_data_sprintf(e, mme_fmt, i, "N",
+			hl_engine_data_sprintf(e, "%-5d%-6s%-9s%#-14x%#x\n", i, "N",
 				is_eng_idle ? "Y" : "N",
 				qm_glbl_sts0,
 				mme_arch_sts);
@@ -7242,8 +7238,6 @@ static bool gaudi2_get_decoder_idle_status(struct hl_device *hdev, u64 *mask_arr
 {
 	struct asic_fixed_properties *prop = &hdev->asic_prop;
 	unsigned long *mask = (unsigned long *) mask_arr;
-	const char *pcie_dec_fmt = "%-10d%-9s%#x\n";
-	const char *dec_fmt = "%-6d%-5d%-9s%#x\n";
 	bool is_idle = true, is_eng_idle;
 	u32 dec_swreg15, dec_enabled_bit;
 	int engine_idx, i, j;
@@ -7273,7 +7267,7 @@ static bool gaudi2_get_decoder_idle_status(struct hl_device *hdev, u64 *mask_arr
 				set_bit(engine_idx, mask);
 
 			if (e)
-				hl_engine_data_sprintf(e, dec_fmt, i, j,
+				hl_engine_data_sprintf(e, "%-6d%-5d%-9s%#x\n", i, j,
 							is_eng_idle ? "Y" : "N", dec_swreg15);
 		}
 	}
@@ -7299,7 +7293,7 @@ static bool gaudi2_get_decoder_idle_status(struct hl_device *hdev, u64 *mask_arr
 			set_bit(engine_idx, mask);
 
 		if (e)
-			hl_engine_data_sprintf(e, pcie_dec_fmt, i,
+			hl_engine_data_sprintf(e, "%-10d%-9s%#x\n", i,
 						is_eng_idle ? "Y" : "N", dec_swreg15);
 	}
 
@@ -7309,7 +7303,6 @@ static bool gaudi2_get_decoder_idle_status(struct hl_device *hdev, u64 *mask_arr
 static bool gaudi2_get_rotator_idle_status(struct hl_device *hdev, u64 *mask_arr, u8 mask_len,
 		struct engines_data *e)
 {
-	const char *rot_fmt = "%-6d%-5d%-9s%#-14x%#-14x%#x\n";
 	unsigned long *mask = (unsigned long *) mask_arr;
 	u32 qm_glbl_sts0, qm_glbl_sts1, qm_cgm_sts;
 	bool is_idle = true, is_eng_idle;
@@ -7337,7 +7330,7 @@ static bool gaudi2_get_rotator_idle_status(struct hl_device *hdev, u64 *mask_arr
 			set_bit(engine_idx, mask);
 
 		if (e)
-			hl_engine_data_sprintf(e, rot_fmt, i, 0, is_eng_idle ? "Y" : "N",
+			hl_engine_data_sprintf(e, "%-6d%-5d%-9s%#-14x%#-14x%#x\n", i, 0, is_eng_idle ? "Y" : "N",
 						qm_glbl_sts0, qm_glbl_sts1, qm_cgm_sts);
 	}
 
diff --git a/drivers/accel/habanalabs/gaudi2/gaudi2_security.c b/drivers/accel/habanalabs/gaudi2/gaudi2_security.c
index 694735f9e6e6..892b1a7fcea3 100644
--- a/drivers/accel/habanalabs/gaudi2/gaudi2_security.c
+++ b/drivers/accel/habanalabs/gaudi2/gaudi2_security.c
@@ -3822,9 +3822,6 @@ void gaudi2_pb_print_security_errors(struct hl_device *hdev, u32 block_addr, u32
 					u32 offended_addr)
 {
 	int i = 0;
-	const char *error_format =
-		"Security error at block 0x%x, offending address 0x%x\n"
-		"Cause 0x%x: %s %s %s %s %s %s %s %s\n";
 	char *mcause[8] = {"Unknown", "", "", "", "", "", "", "" };
 
 	if (!cause)
@@ -3854,7 +3851,10 @@ void gaudi2_pb_print_security_errors(struct hl_device *hdev, u32 block_addr, u32
 	if (cause & SPECIAL_GLBL_ERR_CAUSE_EXT_UNMAPPED_WR)
 		mcause[i++] = "APB_EXT_UNMAPPED_WR";
 
-	dev_err_ratelimited(hdev->dev, error_format, block_addr, offended_addr,
+	dev_err_ratelimited(hdev->dev,
+			"Security error at block 0x%x, offending address 0x%x\n"
+			"Cause 0x%x: %s %s %s %s %s %s %s %s\n",
+			block_addr, offended_addr,
 			cause, mcause[0], mcause[1], mcause[2], mcause[3],
 			mcause[4], mcause[5], mcause[6], mcause[7]);
 }
diff --git a/drivers/accel/habanalabs/goya/goya.c b/drivers/accel/habanalabs/goya/goya.c
index 703bfa22aec1..e4f96820a59b 100644
--- a/drivers/accel/habanalabs/goya/goya.c
+++ b/drivers/accel/habanalabs/goya/goya.c
@@ -5137,8 +5137,8 @@ int goya_cpucp_info_get(struct hl_device *hdev)
 static bool goya_is_device_idle(struct hl_device *hdev, u64 *mask_arr, u8 mask_len,
 				struct engines_data *e)
 {
-	const char *fmt = "%-5d%-9s%#-14x%#-16x%#x\n";
-	const char *dma_fmt = "%-5d%-9s%#-14x%#x\n";
+#define fmt "%-5d%-9s%#-14x%#-16x%#x\n"
+#define dma_fmt "%-5d%-9s%#-14x%#x\n"
 	unsigned long *mask = (unsigned long *)mask_arr;
 	u32 qm_glbl_sts0, cmdq_glbl_sts0, dma_core_sts0, tpc_cfg_sts,
 		mme_arch_sts;
@@ -5209,7 +5209,8 @@ static bool goya_is_device_idle(struct hl_device *hdev, u64 *mask_arr, u8 mask_l
 				cmdq_glbl_sts0, mme_arch_sts);
 		hl_engine_data_sprintf(e, "\n");
 	}
-
+#undef dma_fmt
+#undef fmt
 	return is_idle;
 }
 
diff --git a/drivers/android/binder.c b/drivers/android/binder.c
index 8fb7672021ee..317d4ff4c7ff 100644
--- a/drivers/android/binder.c
+++ b/drivers/android/binder.c
@@ -6439,7 +6439,7 @@ static void print_binder_transaction_log_entry(struct seq_file *m,
 	 * done printing the fields of the entry
 	 */
 	smp_rmb();
-	seq_printf(m, debug_id && debug_id == READ_ONCE(e->debug_id_done) ?
+	seq_printf(m, "%s", debug_id && debug_id == READ_ONCE(e->debug_id_done) ?
 			"\n" : " (incomplete)\n");
 }
 
diff --git a/drivers/block/rbd.c b/drivers/block/rbd.c
index 632751ddb287..7d1ccc6edaba 100644
--- a/drivers/block/rbd.c
+++ b/drivers/block/rbd.c
@@ -1446,9 +1446,15 @@ __rbd_obj_add_osd_request(struct rbd_obj_request *obj_req,
 	ceph_oloc_copy(&req->r_base_oloc, &rbd_dev->header_oloc);
 	req->r_base_oloc.pool = rbd_dev->layout.pool_id;
 
+/* FIXME this change should not be mandatory with the printk checker plugin
+ * (need to find the formats of a conditional)
+ */
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wformat-security"
 	ret = ceph_oid_aprintf(&req->r_base_oid, GFP_NOIO, name_format,
 			       rbd_dev->header.object_prefix,
 			       obj_req->ex.oe_objno);
+#pragma GCC diagnostic pop
 	if (ret)
 		return ERR_PTR(ret);
 
diff --git a/drivers/fpga/xilinx-spi.c b/drivers/fpga/xilinx-spi.c
index e1a227e7ff2a..abded4874a85 100644
--- a/drivers/fpga/xilinx-spi.c
+++ b/drivers/fpga/xilinx-spi.c
@@ -203,9 +203,12 @@ static int xilinx_spi_write_complete(struct fpga_manager *mgr,
 			return ret;
 		}
 
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wformat-security"
 		dev_err(&mgr->dev,
 			ret ? "CRC error or invalid device\n"
 			: "Missing sync word or incomplete bitstream\n");
+#pragma GCC diagnostic pop
 	} else {
 		dev_err(&mgr->dev, "Timeout after config data transfer\n");
 	}
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras_eeprom.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras_eeprom.c
index c2c2a7718613..5c1d2fc011f0 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ras_eeprom.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ras_eeprom.c
@@ -913,12 +913,15 @@ static ssize_t amdgpu_ras_debugfs_table_read(struct file *f, char __user *buf,
 		u8 data[tbl_hdr_fmt_size + 1];
 		loff_t lpos;
 
+		__diag_push()
+		__diag_ignore(GCC, 4, "-Wformat-security", "tbl_hdr_fmt is constant");
 		snprintf(data, sizeof(data), tbl_hdr_fmt,
 			 control->tbl_hdr.header,
 			 control->tbl_hdr.version,
 			 control->tbl_hdr.first_rec_offset,
 			 control->tbl_hdr.tbl_size,
 			 control->tbl_hdr.checksum);
+		__diag_pop()
 
 		data_len -= *pos;
 		data_len = min_t(size_t, data_len, size);
@@ -968,6 +971,8 @@ static ssize_t amdgpu_ras_debugfs_table_read(struct file *f, char __user *buf,
 			if (res)
 				goto Out;
 			__decode_table_record_from_buf(control, &record, dare);
+			__diag_push()
+			__diag_ignore(GCC, 4, "-Wformat-security", "rec_hdr_fmt is constant");
 			snprintf(data, sizeof(data), rec_hdr_fmt,
 				 s,
 				 RAS_INDEX_TO_OFFSET(control, ai),
@@ -978,6 +983,7 @@ static ssize_t amdgpu_ras_debugfs_table_read(struct file *f, char __user *buf,
 				 record.mem_channel,
 				 record.mcumc_id,
 				 record.retired_page);
+			__diag_pop()
 
 			data_len = min_t(size_t, rec_hdr_fmt_size - r, size);
 			if (copy_to_user(buf, &data[r], data_len)) {
diff --git a/drivers/gpu/drm/msm/disp/dpu1/dpu_kms.c b/drivers/gpu/drm/msm/disp/dpu1/dpu_kms.c
index 0e7a68714e9e..10e4d198eb55 100644
--- a/drivers/gpu/drm/msm/disp/dpu1/dpu_kms.c
+++ b/drivers/gpu/drm/msm/disp/dpu1/dpu_kms.c
@@ -219,7 +219,7 @@ static int dpu_regset32_show(struct seq_file *s, void *data)
 	for (i = 0; i < regset->blk_len; i += 4) {
 		addr = regset->offset + i;
 		if ((addr & 0xF) == 0x0)
-			seq_printf(s, i ? "\n[%x]" : "[%x]", addr);
+			seq_printf(s, "%s[%x]", i ? "\n" : "", addr);
 		seq_printf(s, " %08x", readl_relaxed(base + i));
 	}
 	seq_puts(s, "\n");
diff --git a/drivers/hv/vmbus_drv.c b/drivers/hv/vmbus_drv.c
index 1c65a6dfb9fa..5996194a608f 100644
--- a/drivers/hv/vmbus_drv.c
+++ b/drivers/hv/vmbus_drv.c
@@ -653,9 +653,8 @@ __ATTRIBUTE_GROUPS(vmbus_bus);
 static int vmbus_uevent(const struct device *device, struct kobj_uevent_env *env)
 {
 	const struct hv_device *dev = device_to_hv_device(device);
-	const char *format = "MODALIAS=vmbus:%*phN";
 
-	return add_uevent_var(env, format, UUID_SIZE, &dev->dev_type);
+	return add_uevent_var(env, "MODALIAS=vmbus:%*phN", UUID_SIZE, &dev->dev_type);
 }
 
 static const struct hv_vmbus_device_id *
diff --git a/drivers/hwtracing/intel_th/pti.c b/drivers/hwtracing/intel_th/pti.c
index 09132ab8bc23..9c4ef6ced667 100644
--- a/drivers/hwtracing/intel_th/pti.c
+++ b/drivers/hwtracing/intel_th/pti.c
@@ -258,8 +258,11 @@ static ssize_t lpp_dest_show(struct device *dev, struct device_attribute *attr,
 		if (!(pti->lpp_dest_mask & BIT(i)))
 			continue;
 
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wformat-security"
 		ret += scnprintf(buf + ret, PAGE_SIZE - ret,
 				 fmt, lpp_dest_str[i]);
+#pragma GCC diagnostic pop
 	}
 
 	if (ret)
diff --git a/drivers/i2c/busses/i2c-bcm-iproc.c b/drivers/i2c/busses/i2c-bcm-iproc.c
index 85d8a6b04885..0bff4c906c08 100644
--- a/drivers/i2c/busses/i2c-bcm-iproc.c
+++ b/drivers/i2c/busses/i2c-bcm-iproc.c
@@ -325,7 +325,7 @@ static void bcm_iproc_i2c_check_slave_status(
 
 	val = (val >> S_CMD_STATUS_SHIFT) & S_CMD_STATUS_MASK;
 	if (val == S_CMD_STATUS_TIMEOUT || val == S_CMD_STATUS_MASTER_ABORT) {
-		dev_err(iproc_i2c->device, (val == S_CMD_STATUS_TIMEOUT) ?
+		dev_err(iproc_i2c->device, "%s", (val == S_CMD_STATUS_TIMEOUT) ?
 			"slave random stretch time timeout\n" :
 			"Master aborted read transaction\n");
 		/* re-initialize i2c for recovery */
diff --git a/drivers/i3c/master.c b/drivers/i3c/master.c
index 08aeb69a7800..23260b84d54a 100644
--- a/drivers/i3c/master.c
+++ b/drivers/i3c/master.c
@@ -221,8 +221,11 @@ static ssize_t hdrcap_show(struct device *dev,
 		if (!hdrcap_strings[mode])
 			continue;
 
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wformat-security"
 		ret = sprintf(buf + offset, offset ? " %s" : "%s",
 			      hdrcap_strings[mode]);
+#pragma GCC diagnostic pop
 		if (ret < 0)
 			goto out;
 
diff --git a/drivers/iio/adc/ad7606.c b/drivers/iio/adc/ad7606.c
index 1928d9ae5bcf..a7ff2e4450ff 100644
--- a/drivers/iio/adc/ad7606.c
+++ b/drivers/iio/adc/ad7606.c
@@ -205,8 +205,11 @@ static ssize_t ad7606_show_avail(char *buf, const unsigned int *vals,
 	int i;
 
 	for (i = 0; i < n; i++) {
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wformat-security"
 		len += scnprintf(buf + len, PAGE_SIZE - len,
 			micros ? "0.%06u " : "%u ", vals[i]);
+#pragma GCC diagnostic pop
 	}
 	buf[len - 1] = '\n';
 
diff --git a/drivers/input/joystick/analog.c b/drivers/input/joystick/analog.c
index 0c9e172a9818..55e0baabf17b 100644
--- a/drivers/input/joystick/analog.c
+++ b/drivers/input/joystick/analog.c
@@ -350,10 +350,17 @@ static void analog_name(struct analog *analog)
 
 	if (analog->mask & ANALOG_HAT_FCS)
 		seq_buf_printf(&s, " FCS");
-	if (analog->mask & ANALOG_ANY_CHF)
-		seq_buf_printf(&s, (analog->mask & ANALOG_SAITEK) ? " Saitek" : " CHF");
+	if (analog->mask & ANALOG_ANY_CHF) {
+		if (analog->mask & ANALOG_SAITEK)
+			seq_buf_printf(&s, " Saitek");
+		else
+			seq_buf_printf(&s, " CHF");
+	}
 
-	seq_buf_printf(&s, (analog->mask & ANALOG_GAMEPAD) ? " gamepad" : " joystick");
+	if (analog->mask & ANALOG_GAMEPAD)
+		seq_buf_printf(&s, " gamepad");
+	else
+		seq_buf_printf(&s, " joystick");
 }
 
 /*
diff --git a/drivers/md/bcache/sysfs.c b/drivers/md/bcache/sysfs.c
index c6f677059214..996ad77593eb 100644
--- a/drivers/md/bcache/sysfs.c
+++ b/drivers/md/bcache/sysfs.c
@@ -160,9 +160,12 @@ static ssize_t bch_snprint_string_list(char *buf,
 	char *out = buf;
 	size_t i;
 
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wformat-security"
 	for (i = 0; list[i]; i++)
 		out += scnprintf(out, buf + size - out,
 				i == selected ? "[%s] " : "%s ", list[i]);
+#pragma GCC diagnostic pop
 
 	out[-1] = '\n';
 	return out - buf;
diff --git a/drivers/md/dm-ebs-target.c b/drivers/md/dm-ebs-target.c
index 435b45201f4d..e02cf1da2919 100644
--- a/drivers/md/dm-ebs-target.c
+++ b/drivers/md/dm-ebs-target.c
@@ -400,8 +400,13 @@ static void ebs_status(struct dm_target *ti, status_type_t type,
 		*result = '\0';
 		break;
 	case STATUSTYPE_TABLE:
-		snprintf(result, maxlen, ec->u_bs_set ? "%s %llu %u %u" : "%s %llu %u",
-			 ec->dev->name, (unsigned long long) ec->start, ec->e_bs, ec->u_bs);
+		if (ec->u_bs_set) {
+			snprintf(result, maxlen, "%s %llu %u %u",
+				 ec->dev->name, (unsigned long long) ec->start, ec->e_bs, ec->u_bs);
+		} else {
+			snprintf(result, maxlen, "%s %llu %u",
+				 ec->dev->name, (unsigned long long) ec->start, ec->e_bs);
+		}
 		break;
 	case STATUSTYPE_IMA:
 		*result = '\0';
diff --git a/drivers/media/i2c/ccs/ccs-reg-access.c b/drivers/media/i2c/ccs/ccs-reg-access.c
index 25993445f4fe..8d420340da2a 100644
--- a/drivers/media/i2c/ccs/ccs-reg-access.c
+++ b/drivers/media/i2c/ccs/ccs-reg-access.c
@@ -394,7 +394,7 @@ int ccs_write_data_regs(struct ccs_sensor *sensor, struct ccs_reg *regs,
 
 			bin2hex(printbuf, regdata, msg.len);
 			dev_dbg(&client->dev,
-				"writing msr reg 0x%4.4x value 0x%s\n",
+				"writing msr reg 0x%4.4x value 0x %s\n",
 				regs->addr + j, printbuf);
 
 			put_unaligned_be16(regs->addr + j, buf);
diff --git a/drivers/net/ethernet/fungible/funcore/fun_queue.c b/drivers/net/ethernet/fungible/funcore/fun_queue.c
index 8ab9f68434f5..3708dfeae822 100644
--- a/drivers/net/ethernet/fungible/funcore/fun_queue.c
+++ b/drivers/net/ethernet/fungible/funcore/fun_queue.c
@@ -551,8 +551,13 @@ int fun_request_irq(struct fun_queue *funq, const char *devname,
 	funq->irq_handler = handler;
 	funq->irq_data = data;
 
-	snprintf(funq->irqname, sizeof(funq->irqname),
-		 funq->qid ? "%s-q[%d]" : "%s-adminq", devname, funq->qid);
+	if (funq->qid) {
+		snprintf(funq->irqname, sizeof(funq->irqname),
+			 "%s-q[%d]", devname, funq->qid);
+	} else {
+		snprintf(funq->irqname, sizeof(funq->irqname),
+			 "%s-adminq", devname);
+	}
 
 	rc = request_irq(funq_irq(funq), handler, 0, funq->irqname, data);
 	if (rc)
diff --git a/drivers/net/ethernet/intel/i40e/i40e_main.c b/drivers/net/ethernet/intel/i40e/i40e_main.c
index b847bd105b16..6ca5e755b381 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@ -9291,7 +9291,7 @@ void i40e_do_reset(struct i40e_pf *pf, u32 reset_flags, bool lock_acquired)
 		 */
 		i40e_prep_for_reset(pf);
 		i40e_reset_and_rebuild(pf, true, lock_acquired);
-		dev_info(&pf->pdev->dev,
+		dev_info(&pf->pdev->dev, "%s",
 			 pf->flags & I40E_FLAG_DISABLE_FW_LLDP ?
 			 "FW LLDP is disabled\n" :
 			 "FW LLDP is enabled\n");
@@ -15922,7 +15922,7 @@ static int i40e_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	 lldp_status == I40E_GET_FW_LLDP_STATUS_ENABLED) ?
 		(pf->flags &= ~I40E_FLAG_DISABLE_FW_LLDP) :
 		(pf->flags |= I40E_FLAG_DISABLE_FW_LLDP);
-	dev_info(&pdev->dev,
+	dev_info(&pdev->dev, "%s",
 		 (pf->flags & I40E_FLAG_DISABLE_FW_LLDP) ?
 			"FW LLDP is disabled\n" :
 			"FW LLDP is enabled\n");
diff --git a/drivers/net/ethernet/ti/davinci_emac.c b/drivers/net/ethernet/ti/davinci_emac.c
index 2eb9d5a32588..951a3750382f 100644
--- a/drivers/net/ethernet/ti/davinci_emac.c
+++ b/drivers/net/ethernet/ti/davinci_emac.c
@@ -312,7 +312,7 @@ struct emac_priv {
 	struct napi_struct napi;
 	char mac_addr[6];
 	void __iomem *remap_addr;
-	u32 emac_base_phys;
+	phys_addr_t emac_base_phys;
 	void __iomem *emac_base;
 	void __iomem *ctrl_base;
 	struct cpdma_ctlr *dma;
diff --git a/drivers/net/ethernet/ti/netcp_ethss.c b/drivers/net/ethernet/ti/netcp_ethss.c
index 2adf82a32bf6..c78f481bd6c2 100644
--- a/drivers/net/ethernet/ti/netcp_ethss.c
+++ b/drivers/net/ethernet/ti/netcp_ethss.c
@@ -2350,7 +2350,7 @@ static int gbe_slave_open(struct gbe_intf *gbe_intf)
 				slave->slave_num);
 			return -ENODEV;
 		}
-		dev_dbg(priv->dev, "phy found: id is: 0x%s\n",
+		dev_dbg(priv->dev, "phy found: id is: %s\n", /* BUG? */
 			phydev_name(slave->phy));
 		phy_start(slave->phy);
 	}
@@ -3193,7 +3193,7 @@ static void init_secondary_ports(struct gbe_priv *gbe_dev,
 			dev_err(dev, "phy not found for slave %d\n",
 				slave->slave_num);
 		} else {
-			dev_dbg(dev, "phy found: id is: 0x%s\n",
+			dev_dbg(dev, "phy found: id is: %s\n", /* BUG? */
 				phydev_name(slave->phy));
 			phy_start(slave->phy);
 		}
diff --git a/drivers/net/wireless/ath/ath10k/wmi.c b/drivers/net/wireless/ath/ath10k/wmi.c
index 980d4124fa28..df7272cef5a1 100644
--- a/drivers/net/wireless/ath/ath10k/wmi.c
+++ b/drivers/net/wireless/ath/ath10k/wmi.c
@@ -7467,7 +7467,7 @@ ath10k_wmi_op_gen_peer_set_param(struct ath10k *ar, u32 vdev_id,
 	ether_addr_copy(cmd->peer_macaddr.addr, peer_addr);
 
 	ath10k_dbg(ar, ATH10K_DBG_WMI,
-		   "wmi vdev %d peer 0x%pM set param %d value %d\n",
+		   "wmi vdev %d peer %pM set param %d value %d\n", /* BUG? Only place with 0x%pM */
 		   vdev_id, peer_addr, param_id, param_value);
 	return skb;
 }
diff --git a/drivers/net/wireless/ath/ath11k/mac.c b/drivers/net/wireless/ath/ath11k/mac.c
index 1c93f1afccc5..6c1701dfbdf8 100644
--- a/drivers/net/wireless/ath/ath11k/mac.c
+++ b/drivers/net/wireless/ath/ath11k/mac.c
@@ -3564,7 +3564,7 @@ static void ath11k_mac_op_bss_info_changed(struct ieee80211_hw *hw,
 
 		ath11k_dbg(ar->ab, ATH11K_DBG_MAC, "mac arp_addr_cnt %d vif->addr %pM, offload_addr %pI4\n",
 			   vif->cfg.arp_addr_cnt,
-			   vif->addr, arvif->arp_ns_offload.ipv4_addr);
+			   vif->addr, arvif->arp_ns_offload.ipv4_addr[0]);
 	}
 
 	mutex_unlock(&ar->conf_mutex);
diff --git a/drivers/net/wireless/ath/ath12k/wmi.c b/drivers/net/wireless/ath/ath12k/wmi.c
index 7ae0bb78b2b5..ba7900aa687c 100644
--- a/drivers/net/wireless/ath/ath12k/wmi.c
+++ b/drivers/net/wireless/ath/ath12k/wmi.c
@@ -1204,7 +1204,7 @@ int ath12k_wmi_set_peer_param(struct ath12k *ar, const u8 *peer_addr,
 	cmd->param_value = cpu_to_le32(param_val);
 
 	ath12k_dbg(ar->ab, ATH12K_DBG_WMI,
-		   "WMI vdev %d peer 0x%pM set param %d value %d\n",
+		   "WMI vdev %d peer 0x %pM set param %d value %d\n",
 		   vdev_id, peer_addr, param_id, param_val);
 
 	ret = ath12k_wmi_cmd_send(wmi, skb, WMI_PEER_SET_PARAM_CMDID);
diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/debugfs-vif.c b/drivers/net/wireless/intel/iwlwifi/mvm/debugfs-vif.c
index 3613b1fdc5d9..6e25a7fb0b97 100644
--- a/drivers/net/wireless/intel/iwlwifi/mvm/debugfs-vif.c
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/debugfs-vif.c
@@ -523,7 +523,7 @@ static ssize_t iwl_dbgfs_low_latency_read(struct file *file,
 {
 	struct ieee80211_vif *vif = file->private_data;
 	struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
-	char format[] = "traffic=%d\ndbgfs=%d\nvcmd=%d\nvif_type=%d\n"
+	const char format[] = "traffic=%d\ndbgfs=%d\nvcmd=%d\nvif_type=%d\n"
 			"dbgfs_force_enable=%d\ndbgfs_force=%d\nactual=%d\n";
 
 	/*
@@ -533,7 +533,9 @@ static ssize_t iwl_dbgfs_low_latency_read(struct file *file,
 	char buf[sizeof(format) + 1] = {};
 	int len;
 
-	len = scnprintf(buf, sizeof(buf) - 1, format,
+	len = scnprintf(buf, sizeof(buf) - 1,
+			"traffic=%d\ndbgfs=%d\nvcmd=%d\nvif_type=%d\n"
+			"dbgfs_force_enable=%d\ndbgfs_force=%d\nactual=%d\n",
 			!!(mvmvif->low_latency & LOW_LATENCY_TRAFFIC),
 			!!(mvmvif->low_latency & LOW_LATENCY_DEBUGFS),
 			!!(mvmvif->low_latency & LOW_LATENCY_VCMD),
diff --git a/drivers/net/wireless/silabs/wfx/hif_rx.c b/drivers/net/wireless/silabs/wfx/hif_rx.c
index 64ca8acb8e4f..084c7c990271 100644
--- a/drivers/net/wireless/silabs/wfx/hif_rx.c
+++ b/drivers/net/wireless/silabs/wfx/hif_rx.c
@@ -226,7 +226,7 @@ static int wfx_hif_generic_indication(struct wfx_dev *wdev,
 	case HIF_GENERIC_INDICATION_TYPE_RAW:
 		return 0;
 	case HIF_GENERIC_INDICATION_TYPE_STRING:
-		dev_info(wdev->dev, "firmware says: %s\n", (char *)&body->data);
+		{char *body_data=(char *)&body->data;dev_info(wdev->dev, "firmware says: %s\n", body_data);}
 		return 0;
 	case HIF_GENERIC_INDICATION_TYPE_RX_STATS:
 		mutex_lock(&wdev->rx_stats_lock);
diff --git a/drivers/of/platform.c b/drivers/of/platform.c
index 21d9f263b3cd..d1b384426a27 100644
--- a/drivers/of/platform.c
+++ b/drivers/of/platform.c
@@ -86,13 +86,24 @@ static void of_device_make_bus_id(struct device *dev)
 		 */
 		reg = of_get_property(node, "reg", NULL);
 		if (reg && (addr = of_translate_address(node, reg)) != OF_BAD_ADDR) {
-			if (!of_property_read_u32(node, "mask", &mask))
-				dev_set_name(dev, dev_name(dev) ? "%llx.%x.%pOFn:%s" : "%llx.%x.%pOFn",
-					     addr, ffs(mask) - 1, node, dev_name(dev));
-
-			else
-				dev_set_name(dev, dev_name(dev) ? "%llx.%pOFn:%s" : "%llx.%pOFn",
-					     addr, node, dev_name(dev));
+			if (!of_property_read_u32(node, "mask", &mask)) {
+				if (dev_name(dev)) {
+					dev_set_name(dev, "%llx.%x.%pOFn:%s",
+							 addr, ffs(mask) - 1, node, dev_name(dev));
+				} else {
+					dev_set_name(dev, "%llx.%x.%pOFn",
+							 addr, ffs(mask) - 1, node);
+				}
+
+			} else {
+				if (dev_name(dev)) {
+					dev_set_name(dev, "%llx.%pOFn:%s",
+							 addr, node, dev_name(dev));
+				} else {
+					dev_set_name(dev, "%llx.%pOFn",
+							 addr, node);
+				}
+			}
 			return;
 		}
 
diff --git a/drivers/of/unittest.c b/drivers/of/unittest.c
index 2191c0136531..9f53e453ca6e 100644
--- a/drivers/of/unittest.c
+++ b/drivers/of/unittest.c
@@ -288,7 +288,10 @@ static void __init of_unittest_printf_one(struct device_node *np, const char *fm
 
 	/* Baseline; check conversion with a large size limit */
 	memset(buf, 0xff, buf_size);
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wformat-security"
 	size = snprintf(buf, buf_size - 2, fmt, np);
+#pragma GCC diagnostic pop
 
 	/* use strcmp() instead of strncmp() here to be absolutely sure strings match */
 	unittest((strcmp(buf, expected) == 0) && (buf[size+1] == 0xff),
@@ -300,7 +303,10 @@ static void __init of_unittest_printf_one(struct device_node *np, const char *fm
 	for (i = 0; i < 2; i++, size--) {
 		/* Clear the buffer, and make sure it works correctly still */
 		memset(buf, 0xff, buf_size);
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wformat-security"
 		snprintf(buf, size+1, fmt, np);
+#pragma GCC diagnostic pop
 		unittest(strncmp(buf, expected, size) == 0 && (buf[size+1] == 0xff),
 			"snprintf failed; size=%i fmt='%s' expected='%s' rslt='%s'\n",
 			size, fmt, expected, buf);
diff --git a/drivers/platform/x86/asus-laptop.c b/drivers/platform/x86/asus-laptop.c
index 761029f39314..198c4304a84e 100644
--- a/drivers/platform/x86/asus-laptop.c
+++ b/drivers/platform/x86/asus-laptop.c
@@ -899,11 +899,11 @@ static ssize_t infos_show(struct device *dev, struct device_attribute *attr,
 		snprintf(buf, 9, "%s", asus->dsdt_info->oem_table_id);
 		len += sprintf(page + len, "OEM table id       : %s\n", buf);
 		snprintf(buf, 16, "%x", asus->dsdt_info->oem_revision);
-		len += sprintf(page + len, "OEM revision       : 0x%s\n", buf);
+		len += sprintf(page + len, "OEM revision       : 0x %s\n", buf); /* Silence false positive "0x%s" warning */
 		snprintf(buf, 5, "%s", asus->dsdt_info->asl_compiler_id);
 		len += sprintf(page + len, "ASL comp vendor id : %s\n", buf);
 		snprintf(buf, 16, "%x", asus->dsdt_info->asl_compiler_revision);
-		len += sprintf(page + len, "ASL comp revision  : 0x%s\n", buf);
+		len += sprintf(page + len, "ASL comp revision  : 0x %s\n", buf); /* Silence false positive "0x%s" warning */
 	}
 
 	return len;
diff --git a/drivers/rtc/rtc-ds1307.c b/drivers/rtc/rtc-ds1307.c
index e86ba84df6cb..9434c0e5f88a 100644
--- a/drivers/rtc/rtc-ds1307.c
+++ b/drivers/rtc/rtc-ds1307.c
@@ -1219,7 +1219,10 @@ static ssize_t frequency_test_show(struct device *dev,
 
 	regmap_read(ds1307->regmap, M41TXX_REG_CONTROL, &ctrl_reg);
 
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wformat-security"
 	return sysfs_emit(buf, (ctrl_reg & M41TXX_BIT_FT) ? "on\n" : "off\n");
+#pragma GCC diagnostic pop
 }
 
 static DEVICE_ATTR_RW(frequency_test);
diff --git a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c b/drivers/scsi/bnx2fc/bnx2fc_fcoe.c
index 05ddbb9bb7d8..caba260d5367 100644
--- a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c
+++ b/drivers/scsi/bnx2fc/bnx2fc_fcoe.c
@@ -1132,7 +1132,7 @@ static int bnx2fc_vport_create(struct fc_vport *vport, bool disabled)
 	if (rc) {
 		fcoe_wwn_to_str(vport->port_name, buf, sizeof(buf));
 		printk(KERN_ERR PFX "Failed to create vport, "
-		       "WWPN (0x%s) already exists\n",
+		       "WWPN (0x %s) already exists\n", /* Silence false positive "0x%s" warning */
 		       buf);
 		return rc;
 	}
diff --git a/drivers/scsi/fcoe/fcoe.c b/drivers/scsi/fcoe/fcoe.c
index f1429f270170..a3763de4d377 100644
--- a/drivers/scsi/fcoe/fcoe.c
+++ b/drivers/scsi/fcoe/fcoe.c
@@ -2655,7 +2655,7 @@ static int fcoe_vport_create(struct fc_vport *vport, bool disabled)
 	if (rc) {
 		fcoe_wwn_to_str(vport->port_name, buf, sizeof(buf));
 		printk(KERN_ERR "fcoe: Failed to create vport, "
-			"WWPN (0x%s) already exists\n",
+			"WWPN (0x %s) already exists\n", /* Silence false positive "0x%s" warning */
 			buf);
 		return rc;
 	}
diff --git a/drivers/scsi/fcoe/fcoe_transport.c b/drivers/scsi/fcoe/fcoe_transport.c
index 46b0bf237be1..49e30220a64e 100644
--- a/drivers/scsi/fcoe/fcoe_transport.c
+++ b/drivers/scsi/fcoe/fcoe_transport.c
@@ -259,7 +259,7 @@ int fcoe_validate_vport_create(struct fc_vport *vport)
 	fcoe_wwn_to_str(vport->port_name, buf, sizeof(buf));
 	/* Check if the wwpn is not same as that of the lport */
 	if (!memcmp(&n_port->wwpn, &vport->port_name, sizeof(u64))) {
-		LIBFCOE_TRANSPORT_DBG("vport WWPN 0x%s is same as that of the "
+		LIBFCOE_TRANSPORT_DBG("vport WWPN 0x %s is same as that of the " /* Silence false positive "0x%s" warning */
 				      "base port WWPN\n", buf);
 		rc = -EINVAL;
 		goto out;
@@ -268,7 +268,7 @@ int fcoe_validate_vport_create(struct fc_vport *vport)
 	/* Check if there is any existing vport with same wwpn */
 	list_for_each_entry(vn_port, &n_port->vports, list) {
 		if (!memcmp(&vn_port->wwpn, &vport->port_name, sizeof(u64))) {
-			LIBFCOE_TRANSPORT_DBG("vport with given WWPN 0x%s "
+			LIBFCOE_TRANSPORT_DBG("vport with given WWPN 0x %s " /* Silence false positive "0x%s" warning */
 					      "already exists\n", buf);
 			rc = -EINVAL;
 			break;
diff --git a/drivers/scsi/hpsa.c b/drivers/scsi/hpsa.c
index af18d20f3079..0708735c85a7 100644
--- a/drivers/scsi/hpsa.c
+++ b/drivers/scsi/hpsa.c
@@ -6856,7 +6856,7 @@ static int fill_cmd(struct CommandList *c, u8 cmd, struct ctlr_info *h,
 			c->Request.CDB[9] = 0;
 			break;
 		default:
-			dev_warn(&h->pdev->dev, "unknown command 0x%c\n", cmd);
+			dev_warn(&h->pdev->dev, "unknown command 0x%02x\n", cmd);
 			BUG();
 		}
 	} else if (cmd_type == TYPE_MSG) {
diff --git a/drivers/scsi/qedf/qedf_main.c b/drivers/scsi/qedf/qedf_main.c
index 3b64de81ea0d..fdb7d52e1e56 100644
--- a/drivers/scsi/qedf/qedf_main.c
+++ b/drivers/scsi/qedf/qedf_main.c
@@ -1829,7 +1829,7 @@ static int qedf_vport_create(struct fc_vport *vport, bool disabled)
 	if (rc) {
 		fcoe_wwn_to_str(vport->port_name, buf, sizeof(buf));
 		QEDF_WARN(&(base_qedf->dbg_ctx), "Failed to create vport, "
-			   "WWPN (0x%s) already exists.\n", buf);
+			   "WWPN (0x %s) already exists.\n", buf); /* Silence false positive "0x%s" warning */
 		return rc;
 	}
 
diff --git a/drivers/scsi/qedi/qedi_main.c b/drivers/scsi/qedi/qedi_main.c
index 45d359554182..ac1245b42bf8 100644
--- a/drivers/scsi/qedi/qedi_main.c
+++ b/drivers/scsi/qedi/qedi_main.c
@@ -2047,7 +2047,8 @@ static ssize_t qedi_show_boot_eth_info(void *data, int type, char *buf)
 	int rc = 1;
 	u32 ipv6_en, dhcp_en, ip_len;
 	struct nvm_iscsi_block *block;
-	char *fmt, *ip, *sub, *gw;
+	char *ip, *sub, *gw;
+	const char *fmt;
 
 	block = qedi_get_nvram_block(qedi);
 	if (!block)
@@ -2075,6 +2076,9 @@ static ssize_t qedi_show_boot_eth_info(void *data, int type, char *buf)
 		ip_len = ipv6_en ? 5 : 8;
 	}
 
+
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wformat-security"
 	switch (type) {
 	case ISCSI_BOOT_ETH_IP_ADDR:
 		rc = snprintf(buf, ip_len, fmt, ip);
@@ -2107,6 +2111,7 @@ static ssize_t qedi_show_boot_eth_info(void *data, int type, char *buf)
 		rc = 0;
 		break;
 	}
+#pragma GCC diagnostic pop
 
 	return rc;
 }
diff --git a/drivers/scsi/smartpqi/smartpqi_init.c b/drivers/scsi/smartpqi/smartpqi_init.c
index a90a5a31ffa5..7339f5eb8afb 100644
--- a/drivers/scsi/smartpqi/smartpqi_init.c
+++ b/drivers/scsi/smartpqi/smartpqi_init.c
@@ -647,7 +647,7 @@ static int pqi_build_raid_path_request(struct pqi_ctrl_info *ctrl_info,
 		put_unaligned_be16(cdb_length, &cdb[7]);
 		break;
 	default:
-		dev_err(&ctrl_info->pci_dev->dev, "unknown command 0x%c\n", cmd);
+		dev_err(&ctrl_info->pci_dev->dev, "unknown command 0x%02x\n", cmd);
 		break;
 	}
 
diff --git a/drivers/staging/pi433/pi433_if.c b/drivers/staging/pi433/pi433_if.c
index f08fdf06d566..fb508db33e27 100644
--- a/drivers/staging/pi433/pi433_if.c
+++ b/drivers/staging/pi433/pi433_if.c
@@ -1106,7 +1106,7 @@ static int pi433_debugfs_regs_show(struct seq_file *m, void *p)
 	struct pi433_device *dev;
 	u8 reg_data[114];
 	int i;
-	char *fmt = "0x%02x, 0x%02x\n";
+#define fmt "0x%02x, 0x%02x\n"
 	int ret;
 
 	dev = m->private;
@@ -1143,6 +1143,7 @@ static int pi433_debugfs_regs_show(struct seq_file *m, void *p)
 	seq_printf(m, fmt, REG_TESTPA2, reg_data[REG_TESTPA2]);
 	seq_printf(m, fmt, REG_TESTDAGC, reg_data[REG_TESTDAGC]);
 	seq_printf(m, fmt, REG_TESTAFC, reg_data[REG_TESTAFC]);
+#undef fmt
 
 out_unlock:
 	mutex_unlock(&dev->rx_lock);
diff --git a/drivers/target/iscsi/iscsi_target_auth.c b/drivers/target/iscsi/iscsi_target_auth.c
index c8a248bd11be..95ad4674829d 100644
--- a/drivers/target/iscsi/iscsi_target_auth.c
+++ b/drivers/target/iscsi/iscsi_target_auth.c
@@ -59,10 +59,10 @@ static int chap_gen_challenge(
 	/*
 	 * Set CHAP_C, and copy the generated challenge into c_str.
 	 */
-	*c_len += sprintf(c_str + *c_len, "CHAP_C=0x%s", challenge_asciihex);
+	*c_len += sprintf(c_str + *c_len, "CHAP_C=0x %s", challenge_asciihex); /* False positives of "0x%s" */
 	*c_len += 1;
 
-	pr_debug("[%s] Sending CHAP_C=0x%s\n\n", (caller) ? "server" : "client",
+	pr_debug("[%s] Sending CHAP_C=0x %s\n\n", (caller) ? "server" : "client",
 			challenge_asciihex);
 
 out:
@@ -550,10 +550,10 @@ static int chap_server_compute_hash(
 	 * Convert response from binary hex to ascii hext.
 	 */
 	bin2hex(response, digest, chap->digest_size);
-	*nr_out_len += sprintf(nr_out_ptr + *nr_out_len, "CHAP_R=0x%s",
+	*nr_out_len += sprintf(nr_out_ptr + *nr_out_len, "CHAP_R=0x %s", /* Silence false positive "0x%s" warning, but this introduces a bug */
 			response);
 	*nr_out_len += 1;
-	pr_debug("[server] Sending CHAP_R=0x%s\n", response);
+	pr_debug("[server] Sending CHAP_R=0x %s\n", response); /* Silence false positive "0x%s" warning */
 	auth_ret = 0;
 out:
 	kfree_sensitive(desc);
diff --git a/drivers/target/target_core_pr.c b/drivers/target/target_core_pr.c
index d19ec4e6a4c0..b21ba7d2ba21 100644
--- a/drivers/target/target_core_pr.c
+++ b/drivers/target/target_core_pr.c
@@ -50,7 +50,7 @@ void core_pr_dump_initiator_port(
 		return;
 	}
 
-	snprintf(buf, size, ",i,0x%s", pr_reg->pr_reg_isid);
+	snprintf(buf, size, ",i,0x %s", pr_reg->pr_reg_isid); /* Silence false positive "0x%s" warning */
 }
 
 enum register_type {
diff --git a/drivers/usb/gadget/function/f_uac1.c b/drivers/usb/gadget/function/f_uac1.c
index 6f0e1d803dc2..e4d1594d61c4 100644
--- a/drivers/usb/gadget/function/f_uac1.c
+++ b/drivers/usb/gadget/function/f_uac1.c
@@ -1447,9 +1447,14 @@ static struct configfs_item_operations f_uac1_item_ops = {
 #define uac1_kstrtos16			kstrtos16
 #define uac1_kstrtobool(s, base, res)	kstrtobool((s), (res))
 
+/*
 static const char *u32_fmt = "%u\n";
 static const char *s16_fmt = "%hd\n";
 static const char *bool_fmt = "%u\n";
+*/
+#define u32_fmt "%u\n"
+#define s16_fmt "%hd\n"
+#define bool_fmt "%u\n"
 
 #define UAC1_ATTRIBUTE(type, name)					\
 static ssize_t f_uac1_opts_##name##_show(				\
diff --git a/drivers/usb/gadget/function/f_uac2.c b/drivers/usb/gadget/function/f_uac2.c
index 0219cd79493a..1d1eb1311e9a 100644
--- a/drivers/usb/gadget/function/f_uac2.c
+++ b/drivers/usb/gadget/function/f_uac2.c
@@ -1873,10 +1873,16 @@ static struct configfs_item_operations f_uac2_item_ops = {
 #define uac2_kstrtos16 kstrtos16
 #define uac2_kstrtobool(s, base, res) kstrtobool((s), (res))
 
+/*
 static const char *u8_fmt = "%u\n";
 static const char *u32_fmt = "%u\n";
 static const char *s16_fmt = "%hd\n";
 static const char *bool_fmt = "%u\n";
+*/
+#define u8_fmt "%u\n"
+#define u32_fmt "%u\n"
+#define s16_fmt "%hd\n"
+#define bool_fmt "%u\n"
 
 #define UAC2_ATTRIBUTE(type, name)					\
 static ssize_t f_uac2_opts_##name##_show(struct config_item *item,	\
diff --git a/fs/afs/dir.c b/fs/afs/dir.c
index 5219182e52e1..564514225982 100644
--- a/fs/afs/dir.c
+++ b/fs/afs/dir.c
@@ -206,8 +206,11 @@ static void afs_dir_dump(struct afs_vnode *dvnode, struct afs_read *req)
 
 		size = min_t(loff_t, folio_size(folio), req->actual_len - folio_pos(folio));
 		for (offset = 0; offset < size; offset += sizeof(*block)) {
+			/* Be nice with printk checker */
+			u8 *block_u8;
 			block = kmap_local_folio(folio, offset);
-			pr_warn("[%02lx] %32phN\n", folio_index(folio) + offset, block);
+			block_u8 = (u8 *)block;
+			pr_warn("[%02lx] %32phN\n", folio_index(folio) + offset, block_u8);
 			kunmap_local(block);
 		}
 	}
diff --git a/fs/crypto/keysetup.c b/fs/crypto/keysetup.c
index 361f41ef46c7..0b8fce35fcc5 100644
--- a/fs/crypto/keysetup.c
+++ b/fs/crypto/keysetup.c
@@ -418,7 +418,7 @@ static bool fscrypt_valid_master_key_size(const struct fscrypt_master_key *mk,
 			     "key with %s %*phN is too short (got %u bytes, need %u+ bytes)",
 			     master_key_spec_type(&mk->mk_spec),
 			     master_key_spec_len(&mk->mk_spec),
-			     (u8 *)&mk->mk_spec.u,
+			     (u8 *)&mk->mk_spec.u.__reserved,
 			     mk->mk_secret.size, min_keysize);
 		return false;
 	}
diff --git a/fs/nfsd/nfsctl.c b/fs/nfsd/nfsctl.c
index b4fd7a7062d5..efdf85b0e3ca 100644
--- a/fs/nfsd/nfsctl.c
+++ b/fs/nfsd/nfsctl.c
@@ -500,7 +500,6 @@ static ssize_t
 nfsd_print_version_support(struct nfsd_net *nn, char *buf, int remaining,
 		const char *sep, unsigned vers, int minor)
 {
-	const char *format = minor < 0 ? "%s%c%u" : "%s%c%u.%u";
 	bool supported = !!nfsd_vers(nn, vers, NFSD_TEST);
 
 	if (vers == 4 && minor >= 0 &&
@@ -513,7 +512,13 @@ nfsd_print_version_support(struct nfsd_net *nn, char *buf, int remaining,
 		 * +4, unless -4.0 is present.
 		 */
 		return 0;
-	return snprintf(buf, remaining, format, sep,
+	/* FIXME this change should not be mandatory with the printk checker plugin
+	 * (need to find the formats of a conditional)
+	 */
+	if (minor < 0)
+		return snprintf(buf, remaining, "%s%c%u", sep,
+				supported ? '+' : '-', vers);
+	return snprintf(buf, remaining, "%s%c%u.%u", sep,
 			supported ? '+' : '-', vers, minor);
 }
 
diff --git a/fs/nfsd/trace.h b/fs/nfsd/trace.h
index ddd33effab6a..278ba69109b7 100644
--- a/fs/nfsd/trace.h
+++ b/fs/nfsd/trace.h
@@ -766,7 +766,7 @@ TRACE_EVENT(nfsd_writeverf_reset,
 		memcpy(__entry->verifier, nn->writeverf,
 		       NFS4_VERIFIER_SIZE);
 	),
-	TP_printk("boot_time=%16llx xid=0x%08x error=%d new verifier=0x%s",
+	TP_printk("boot_time=%16llx xid=0x%08x error=%d new verifier=0x %s",
 		__entry->boot_time, __entry->xid, __entry->error,
 		__print_hex_str(__entry->verifier, NFS4_VERIFIER_SIZE)
 	)
diff --git a/fs/overlayfs/inode.c b/fs/overlayfs/inode.c
index 541cf3717fc2..64454e72d405 100644
--- a/fs/overlayfs/inode.c
+++ b/fs/overlayfs/inode.c
@@ -1092,8 +1092,11 @@ static int ovl_set_nlink_common(struct dentry *dentry,
 	char buf[13];
 	int len;
 
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wformat-security"
 	len = snprintf(buf, sizeof(buf), format,
 		       (int) (inode->i_nlink - realinode->i_nlink));
+#pragma GCC diagnostic pop
 
 	if (WARN_ON(len >= sizeof(buf)))
 		return -EIO;
diff --git a/fs/reiserfs/Makefile b/fs/reiserfs/Makefile
index bd29c58ccbd8..31324124b84b 100644
--- a/fs/reiserfs/Makefile
+++ b/fs/reiserfs/Makefile
@@ -10,6 +10,22 @@ reiserfs-objs := bitmap.o do_balan.o namei.o inode.o file.o dir.o fix_node.o \
 		 hashes.o tail_conversion.o journal.o resize.o \
 		 item_ops.o ioctl.o xattr.o lock.o
 
+# Disable printk format checker in some files
+-include scripts/Makefile.gcc-plugins
+CFLAGS_dir.o += $(DISABLE_PRINTK_FORMAT_PLUGIN)
+CFLAGS_do_balan.o += $(DISABLE_PRINTK_FORMAT_PLUGIN)
+CFLAGS_fix_node.o += $(DISABLE_PRINTK_FORMAT_PLUGIN)
+CFLAGS_ibalance.o += $(DISABLE_PRINTK_FORMAT_PLUGIN)
+CFLAGS_inode.o += $(DISABLE_PRINTK_FORMAT_PLUGIN)
+CFLAGS_item_ops.o += $(DISABLE_PRINTK_FORMAT_PLUGIN)
+CFLAGS_lbalance.o += $(DISABLE_PRINTK_FORMAT_PLUGIN)
+CFLAGS_namei.o += $(DISABLE_PRINTK_FORMAT_PLUGIN)
+CFLAGS_prints.o += $(DISABLE_PRINTK_FORMAT_PLUGIN)
+CFLAGS_super.o += $(DISABLE_PRINTK_FORMAT_PLUGIN)
+CFLAGS_stree.o += $(DISABLE_PRINTK_FORMAT_PLUGIN)
+CFLAGS_tail_conversion.o += $(DISABLE_PRINTK_FORMAT_PLUGIN)
+CFLAGS_xattr.o += $(DISABLE_PRINTK_FORMAT_PLUGIN)
+
 ifeq ($(CONFIG_REISERFS_PROC_INFO),y)
 reiserfs-objs += procfs.o
 endif
diff --git a/include/trace/events/dlm.h b/include/trace/events/dlm.h
index 2b09574e1243..b6a79ea134ef 100644
--- a/include/trace/events/dlm.h
+++ b/include/trace/events/dlm.h
@@ -375,7 +375,7 @@ DECLARE_EVENT_CLASS(dlm_rcom_template,
 	TP_printk("dst=%u h_seq=%u h_version=%s h_lockspace=%u h_nodeid=%u "
 		  "h_length=%u h_cmd=%s rc_type=%s rc_result=%d "
 		  "rc_id=%llu rc_seq=%llu rc_seq_reply=%llu "
-		  "rc_buf=0x%s", __entry->dst, __entry->h_seq,
+		  "rc_buf=0x %s", __entry->dst, __entry->h_seq,
 		  show_message_version(__entry->h_version),
 		  __entry->h_lockspace, __entry->h_nodeid, __entry->h_length,
 		  show_header_cmd(__entry->h_cmd),
@@ -471,7 +471,7 @@ TRACE_EVENT(dlm_send_message,
 		  "m_parent_remid=%u m_exflags=%s m_sbflags=%s m_flags=%s "
 		  "m_lvbseq=%u m_hash=%u m_status=%d m_grmode=%s "
 		  "m_rqmode=%s m_bastmode=%s m_asts=%d m_result=%d "
-		  "m_extra=0x%s res_name=0x%s", __entry->dst,
+		  "m_extra=0x %s res_name=0x %s", __entry->dst,
 		  __entry->h_seq, show_message_version(__entry->h_version),
 		  __entry->h_lockspace, __entry->h_nodeid, __entry->h_length,
 		  show_header_cmd(__entry->h_cmd),
@@ -565,7 +565,7 @@ TRACE_EVENT(dlm_recv_message,
 		  "m_parent_remid=%u m_exflags=%s m_sbflags=%s m_flags=%s "
 		  "m_lvbseq=%u m_hash=%u m_status=%d m_grmode=%s "
 		  "m_rqmode=%s m_bastmode=%s m_asts=%d m_result=%d "
-		  "m_extra=0x%s", __entry->dst,
+		  "m_extra=0x %s", __entry->dst,
 		  __entry->h_seq, show_message_version(__entry->h_version),
 		  __entry->h_lockspace, __entry->h_nodeid, __entry->h_length,
 		  show_header_cmd(__entry->h_cmd),
diff --git a/kernel/bpf/btf.c b/kernel/bpf/btf.c
index 6b682b8e4b50..d3055ee60bbf 100644
--- a/kernel/bpf/btf.c
+++ b/kernel/bpf/btf.c
@@ -4101,9 +4101,12 @@ static s32 btf_enum_check_meta(struct btf_verifier_env *env,
 		if (env->log.level == BPF_LOG_KERNEL)
 			continue;
 		fmt_str = btf_type_kflag(t) ? "\t%s val=%d\n" : "\t%s val=%u\n";
+		__diag_push()
+		__diag_ignore(GCC, 4, "-Wformat-security", "fmt_str is constant");
 		btf_verifier_log(env, fmt_str,
 				 __btf_name_by_offset(btf, enums[i].name_off),
 				 enums[i].val);
+		__diag_pop()
 	}
 
 	return meta_needed;
@@ -4210,9 +4213,12 @@ static s32 btf_enum64_check_meta(struct btf_verifier_env *env,
 			continue;
 
 		fmt_str = btf_type_kflag(t) ? "\t%s val=%lld\n" : "\t%s val=%llu\n";
+		__diag_push()
+		__diag_ignore(GCC, 4, "-Wformat-security", "fmt_str is constant");
 		btf_verifier_log(env, fmt_str,
 				 __btf_name_by_offset(btf, enums[i].name_off),
 				 btf_enum64_value(enums + i));
+		__diag_pop()
 	}
 
 	return meta_needed;
diff --git a/kernel/trace/trace_output.c b/kernel/trace/trace_output.c
index 0d5b61b7fd57..9393500bfdcd 100644
--- a/kernel/trace/trace_output.c
+++ b/kernel/trace/trace_output.c
@@ -221,11 +221,14 @@ trace_print_hex_seq(struct trace_seq *p, const unsigned char *buf, int buf_len,
 	const char *ret = trace_seq_buffer_ptr(p);
 	const char *fmt = concatenate ? "%*phN" : "%*ph";
 
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wformat-security"
 	for (i = 0; i < buf_len; i += 16) {
 		if (!concatenate && i != 0)
 			trace_seq_putc(p, ' ');
 		trace_seq_printf(p, fmt, min(buf_len - i, 16), &buf[i]);
 	}
+#pragma GCC diagnostic pop
 	trace_seq_putc(p, 0);
 
 	return ret;
@@ -326,8 +329,8 @@ void trace_event_printf(struct trace_iterator *iter, const char *fmt, ...)
 EXPORT_SYMBOL(trace_event_printf);
 
 static __printf(3, 0)
-int trace_output_raw(struct trace_iterator *iter, char *name,
-		     char *fmt, va_list ap)
+int trace_output_raw(struct trace_iterator *iter, const char *name,
+		     const char *fmt, va_list ap)
 {
 	struct trace_seq *s = &iter->seq;
 
diff --git a/lib/bitmap.c b/lib/bitmap.c
index 1c81413c51f8..75c23d9001cd 100644
--- a/lib/bitmap.c
+++ b/lib/bitmap.c
@@ -512,11 +512,14 @@ EXPORT_SYMBOL(bitmap_print_to_pagebuf);
 static int bitmap_print_to_buf(bool list, char *buf, const unsigned long *maskp,
 		int nmaskbits, loff_t off, size_t count)
 {
-	const char *fmt = list ? "%*pbl\n" : "%*pb\n";
 	ssize_t size;
 	void *data;
 
-	data = kasprintf(GFP_KERNEL, fmt, nmaskbits, maskp);
+	if (list) {
+		data = kasprintf(GFP_KERNEL, "%*pbl\n", nmaskbits, maskp);
+	} else {
+		data = kasprintf(GFP_KERNEL, "%*pb\n", nmaskbits, maskp);
+	}
 	if (!data)
 		return -ENOMEM;
 
diff --git a/mm/damon/dbgfs.c b/mm/damon/dbgfs.c
index 124f0f8c97b7..e11da3d30c47 100644
--- a/mm/damon/dbgfs.c
+++ b/mm/damon/dbgfs.c
@@ -1003,7 +1003,11 @@ static ssize_t dbgfs_monitor_on_read(struct file *file,
 	bool monitor_on = damon_nr_running_ctxs() != 0;
 	int len;
 
-	len = scnprintf(monitor_on_buf, 5, monitor_on ? "on\n" : "off\n");
+	if (monitor_on) {
+		len = scnprintf(monitor_on_buf, 5, "on\n");
+	} else {
+		len = scnprintf(monitor_on_buf, 5, "off\n");
+	}
 
 	return simple_read_from_buffer(buf, count, ppos, monitor_on_buf, len);
 }
diff --git a/net/ipv4/sysctl_net_ipv4.c b/net/ipv4/sysctl_net_ipv4.c
index 88dfe51e68f3..f12ae8813bad 100644
--- a/net/ipv4/sysctl_net_ipv4.c
+++ b/net/ipv4/sysctl_net_ipv4.c
@@ -278,7 +278,7 @@ static int sscanf_key(char *buf, __le32 *key)
 		for (i = 0; i < ARRAY_SIZE(user_key); i++)
 			key[i] = cpu_to_le32(user_key[i]);
 	}
-	pr_debug("proc TFO key set 0x%x-%x-%x-%x <- 0x%s: %u\n",
+	pr_debug("proc TFO key set 0x%x-%x-%x-%x <- 0x %s: %u\n", /* False-positive of 0x%s */
 		 user_key[0], user_key[1], user_key[2], user_key[3], buf, ret);
 
 	return ret;
diff --git a/net/tipc/crypto.c b/net/tipc/crypto.c
index 577fa5af33ec..d3e65e664feb 100644
--- a/net/tipc/crypto.c
+++ b/net/tipc/crypto.c
@@ -2134,8 +2134,11 @@ static char *tipc_key_change_dump(struct tipc_key old, struct tipc_key new,
 			s = "pen";
 		else
 			s = "-";
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wformat-security"
 		i += scnprintf(buf + i, 32 - i,
 			       (k != KEY_3) ? "%s " : "%s", s);
+#pragma GCC diagnostic pop
 	}
 	if (key != &new) {
 		i += scnprintf(buf + i, 32 - i, "] -> ");
diff --git a/scripts/Makefile.gcc-plugins b/scripts/Makefile.gcc-plugins
index e4deaf5fa571..6274da70e70c 100644
--- a/scripts/Makefile.gcc-plugins
+++ b/scripts/Makefile.gcc-plugins
@@ -8,6 +8,13 @@ ifdef CONFIG_GCC_PLUGIN_LATENT_ENTROPY
 endif
 export DISABLE_LATENT_ENTROPY_PLUGIN
 
+gcc-plugin-$(CONFIG_GCC_PLUGIN_SANCOV)		+= sancov_plugin.so
+
+gcc-plugin-$(CONFIG_GCC_PLUGIN_PRINTK_FORMAT)	+= printk_format_plugin.so
+ifdef CONFIG_GCC_PLUGIN_PRINTK_FORMAT
+  DISABLE_PRINTK_FORMAT_PLUGIN			+= -fplugin-arg-printk_format_plugin-disable
+endif
+
 gcc-plugin-$(CONFIG_GCC_PLUGIN_STRUCTLEAK)	+= structleak_plugin.so
 gcc-plugin-cflags-$(CONFIG_GCC_PLUGIN_STRUCTLEAK_VERBOSE)	\
 		+= -fplugin-arg-structleak_plugin-verbose
diff --git a/scripts/gcc-plugins/Kconfig b/scripts/gcc-plugins/Kconfig
index e383cda05367..5c95a0914d1c 100644
--- a/scripts/gcc-plugins/Kconfig
+++ b/scripts/gcc-plugins/Kconfig
@@ -50,4 +50,11 @@ config GCC_PLUGIN_ARM_SSP_PER_TASK
 	bool
 	depends on GCC_PLUGINS && ARM
 
+config GCC_PLUGIN_PRINTK_FORMAT
+	bool "Check printk format strings"
+	depends on GCC_PLUGINS
+	help
+	  Check printk format strings with kernel specs.
+	  This is complementary to -Wformat-security and -Wformat=2 flags.
+
 endif
diff --git a/scripts/gcc-plugins/printk_format_plugin.c b/scripts/gcc-plugins/printk_format_plugin.c
new file mode 100644
index 000000000000..a650ca070e14
--- /dev/null
+++ b/scripts/gcc-plugins/printk_format_plugin.c
@@ -0,0 +1,919 @@
+/*
+ * Copyright 2016-2023 by Nicolas Iooss
+ *
+ * Check printf format string with kernel-style formatting
+ */
+
+#include "gcc-common.h"
+
+int plugin_is_GPL_compatible;
+
+static struct plugin_info printk_format_plugin_info = {
+	.version	= "20230312",
+	.help		= "Printk format checker\n",
+};
+
+/**
+ * Identifier match helpers
+ */
+static bool identifier_is(const_tree identifier, const char *str)
+{
+	size_t len = strlen(str);
+
+	if (!identifier)
+		return false;
+
+	return IDENTIFIER_LENGTH(identifier) == len && !strncmp(str, IDENTIFIER_POINTER(identifier), len);
+}
+
+/**
+ * Verify that the given value is an integer
+ */
+static bool is_integer_type(const_tree value)
+{
+	if (TREE_CODE(TREE_TYPE(value)) == INTEGER_TYPE)
+		return true;
+	if (TREE_CODE(TREE_TYPE(value)) == ENUMERAL_TYPE)
+		return true;
+	return false;
+}
+
+/**
+ * Check that the given type is 8-bit integer
+ */
+static bool is_8bit_int_type(const_tree value)
+{
+	return TREE_CODE(value) == INTEGER_TYPE &&
+		(TREE_INT_CST_ELT_CHECK(TYPE_SIZE(value), 0) == 8);
+}
+
+/**
+ * Check that the given type is 16-bit integer
+ */
+static bool is_16bit_int_type(const_tree value)
+{
+	return TREE_CODE(value) == INTEGER_TYPE &&
+		(TREE_INT_CST_ELT_CHECK(TYPE_SIZE(value), 0) == 16);
+}
+
+/**
+ * Check that the given type is 32-bit integer
+ */
+static bool is_32bit_int_type(const_tree value)
+{
+	return TREE_CODE(value) == INTEGER_TYPE &&
+		(TREE_INT_CST_ELT_CHECK(TYPE_SIZE(value), 0) == 32);
+}
+
+/**
+ * Verify that the given value is a float
+ */
+static bool is_float_type(const_tree value)
+{
+	if (TREE_CODE(TREE_TYPE(value)) == REAL_TYPE)
+		return true;
+	return false;
+}
+
+/**
+ * Verify that the given value is a string
+ */
+static bool is_string_type(const_tree value, const char *format)
+{
+	if (TREE_CODE(TREE_TYPE(value)) == POINTER_TYPE) {
+		const_tree subtype = TREE_TYPE(TREE_TYPE(value));
+		/* Check for char* */
+		if (is_8bit_int_type(subtype))
+			return true;
+
+		/* Check for void* */
+		if (TREE_CODE(subtype) == VOID_TYPE)
+			return true;
+
+		/* Check for pointer to char[] */
+		if (TREE_CODE(subtype) == ARRAY_TYPE && is_8bit_int_type(TREE_TYPE(subtype)))
+			return true;
+
+		if (!strncmp(format, "%4.4s", 5) || !strncmp(format, "%.4s", 4)) {
+			/* Check for acpi_name* ... */
+			if (TREE_CODE(subtype) == INTEGER_TYPE && identifier_is(TYPE_IDENTIFIER(subtype), "acpi_name"))
+				return true;
+			if (TREE_CODE(subtype) == UNION_TYPE && identifier_is(TYPE_IDENTIFIER(subtype), "acpi_name_union"))
+				return true;
+			if (TREE_CODE(subtype) == INTEGER_TYPE && identifier_is(TYPE_IDENTIFIER(subtype), "uint32_t"))
+				return true;
+			if (TREE_CODE(subtype) == INTEGER_TYPE && identifier_is(TYPE_IDENTIFIER(subtype), "int"))
+				return true;
+			if (TREE_CODE(subtype) == INTEGER_TYPE && identifier_is(TYPE_IDENTIFIER(subtype), "unsigned int"))
+				return true;
+			if (TREE_CODE(subtype) == INTEGER_TYPE && identifier_is(TYPE_IDENTIFIER(subtype), "u32"))
+				return true;
+			if (TREE_CODE(subtype) == INTEGER_TYPE && identifier_is(TYPE_IDENTIFIER(subtype), "__u32"))
+				return true;
+			if (TREE_CODE(subtype) == INTEGER_TYPE && identifier_is(TYPE_IDENTIFIER(subtype), "__le32"))
+				return true;
+		}
+		if (!strncmp(format, "%.8s", 4)) {
+			if (TREE_CODE(subtype) == INTEGER_TYPE && identifier_is(TYPE_IDENTIFIER(subtype), "u64"))
+				return true;
+			if (TREE_CODE(subtype) == INTEGER_TYPE && identifier_is(TYPE_IDENTIFIER(subtype), "__u64"))
+				return true;
+		}
+		/* occurrence in sound/pci/mixart/mixart_core.c XXX: there is a cast to char* in the source code which seems to be lost by gcc :( */
+		if (TREE_CODE(subtype) == INTEGER_TYPE && identifier_is(TYPE_IDENTIFIER(subtype), "u32"))
+			return true;
+		if (TREE_CODE(subtype) == INTEGER_TYPE && identifier_is(TYPE_IDENTIFIER(subtype), "__be32"))
+			return true;
+		if (TREE_CODE(subtype) == INTEGER_TYPE && identifier_is(TYPE_IDENTIFIER(subtype), "u16"))
+			return true;
+		if (TREE_CODE(subtype) == ARRAY_TYPE && TREE_CODE(TREE_TYPE(subtype)) == INTEGER_TYPE)
+			return true;
+	}
+	return false;
+}
+
+/**
+ * Verify that the associated pointer type is valid
+ * c.f. Documentation/core-api/printk-formats.rst
+ */
+static bool is_fmtpointer_type(const_tree value, const char *ptr_format)
+{
+	const_tree subtype;
+
+	/* First, value need to be a pointer */
+	if (TREE_CODE(TREE_TYPE(value)) != POINTER_TYPE) {
+fprintf(stderr, "NOT PTR\n");
+		return false;
+	}
+
+	subtype = TREE_TYPE(TREE_TYPE(value));
+
+	switch (*ptr_format) {
+	/* Order of formats taken from Documentation/core-api/printk-formats.rst */
+
+	case 'S':
+	case 's':
+	case 'B':
+		/* Can be a pointer to anything */
+		return true;
+
+	/* Kernel pointers */
+	case 'K':
+		return true;
+
+	/* Unmodified Addresses */
+	case 'x':
+		return true;
+
+	/* Symbolic error names */
+	case 'e':
+		if (TREE_CODE(subtype) == VOID_TYPE)
+			return true;
+		return true;
+
+	/* Struct Resources */
+	case 'r':
+	case 'R':
+		if (TREE_CODE(subtype) == RECORD_TYPE &&
+		    identifier_is(TYPE_IDENTIFIER(subtype), "resource"))
+			return true;
+		break;
+
+	/* Physical addresses types phys_addr_t and DMA addresses types dma_addr_t */
+	case 'a':
+		/* As some code mixes both dma_addr_t and phys_addr_t with %pad
+		 * and %pap, accept both types.
+		 */
+		if (TREE_CODE(subtype) == INTEGER_TYPE && (
+		    identifier_is(TYPE_IDENTIFIER(subtype), "dma_addr_t") ||
+		    identifier_is(TYPE_IDENTIFIER(subtype), "long long unsigned int") ||
+		    identifier_is(TYPE_IDENTIFIER(subtype), "long unsigned int") ||
+		    identifier_is(TYPE_IDENTIFIER(subtype), "phys_addr_t") ||
+		    identifier_is(TYPE_IDENTIFIER(subtype), "resource_size_t") ||
+		    identifier_is(TYPE_IDENTIFIER(subtype), "u32") ||
+		    identifier_is(TYPE_IDENTIFIER(subtype), "u64")))
+			return true;
+		break;
+
+	/* Raw buffer */
+	case 'E':
+		if (is_8bit_int_type(subtype))
+			return true;
+		if (TREE_CODE(subtype) == ARRAY_TYPE && is_8bit_int_type(TREE_TYPE(subtype)))
+			return true;
+		if (TREE_CODE(subtype) == INTEGER_TYPE)
+			return true;
+		if (TREE_CODE(subtype) == VOID_TYPE)
+			return true;
+		break;
+	case 'h':
+		if (TREE_CODE(subtype) == INTEGER_TYPE)
+			return true;
+		if (TREE_CODE(subtype) == ARRAY_TYPE &&
+		    TREE_CODE(TREE_TYPE(subtype)) == INTEGER_TYPE)
+			return true;
+		if (TREE_CODE(subtype) == VOID_TYPE)
+			return true;
+		if (TREE_CODE(subtype) == RECORD_TYPE && (
+		    identifier_is(TYPE_IDENTIFIER(subtype), "atio_from_isp") ||
+		    identifier_is(TYPE_IDENTIFIER(subtype), "be_id_t") ||
+		    identifier_is(TYPE_IDENTIFIER(subtype), "fun_admin_req_common") ||
+		    identifier_is(TYPE_IDENTIFIER(subtype), "guid_t") ||
+		    identifier_is(TYPE_IDENTIFIER(subtype), "h_misc") ||
+		    identifier_is(TYPE_IDENTIFIER(subtype), "i2c_hid_desc") ||
+		    identifier_is(TYPE_IDENTIFIER(subtype), "nvme_feat_auto_pst") ||
+		    identifier_is(TYPE_IDENTIFIER(subtype), "ovl_fh") ||
+		    identifier_is(TYPE_IDENTIFIER(subtype), "stateid_opaque_t") ||
+		    identifier_is(TYPE_IDENTIFIER(subtype), "uwb_rceb") ||
+		    identifier_is(TYPE_IDENTIFIER(subtype), "vnt_mac_set_key")))
+			return true;
+		if (TREE_CODE(subtype) == ARRAY_TYPE &&
+		    TREE_CODE(TREE_TYPE(subtype)) == RECORD_TYPE &&
+		    identifier_is(TYPE_IDENTIFIER(TREE_TYPE(subtype)), "v4l2_rds_data"))
+			return true;
+		break;
+
+	/* MAC/FDDI addresses */
+	case 'M':
+	case 'm':
+		if (TREE_CODE(subtype) == INTEGER_TYPE)
+			return true;
+		if (TREE_CODE(subtype) == VOID_TYPE)
+			return true;
+		if (TREE_CODE(subtype) == ARRAY_TYPE &&
+		    is_8bit_int_type(TREE_TYPE(subtype)))
+			return true;
+		if (TREE_CODE(subtype) == RECORD_TYPE &&
+		    identifier_is(TYPE_IDENTIFIER(subtype), "bdaddr_t"))
+			return true;
+		if (TREE_CODE(subtype) == RECORD_TYPE &&
+		    identifier_is(TYPE_IDENTIFIER(subtype), "mac_addr"))
+			return true;
+		if (TREE_CODE(subtype) == RECORD_TYPE &&
+		    identifier_is(TYPE_IDENTIFIER(subtype), "wmi_mac_addr"))
+			return true;
+		break;
+
+	/* IPv4/IPv6 addresses */
+	case 'I':
+	case 'i':
+		if (ptr_format[1] == '4') {
+			if (TREE_CODE(subtype) == RECORD_TYPE && identifier_is(TYPE_IDENTIFIER(subtype), "in_addr"))
+				return true;
+			if (TREE_CODE(subtype) == INTEGER_TYPE && (
+			    is_8bit_int_type(subtype) ||
+			    is_32bit_int_type(subtype) ||
+			    identifier_is(TYPE_IDENTIFIER(subtype), "long unsigned int")))
+				return true;
+			if (TREE_CODE(subtype) == ARRAY_TYPE &&
+			    TREE_CODE(TREE_TYPE(subtype)) == INTEGER_TYPE)
+				return true;
+			if (TREE_CODE(subtype) == VOID_TYPE)
+				return true;
+		} else if (ptr_format[1] == '6') {
+			if (TREE_CODE(subtype) == RECORD_TYPE && identifier_is(TYPE_IDENTIFIER(subtype), "in6_addr"))
+				return true;
+			if (is_8bit_int_type(subtype))
+				return true;
+			if (TREE_CODE(subtype) == ARRAY_TYPE &&
+			    TREE_CODE(TREE_TYPE(subtype)) == INTEGER_TYPE)
+				return true;
+			if (TREE_CODE(subtype) == VOID_TYPE)
+				return true;
+			if (TREE_CODE(subtype) == INTEGER_TYPE &&
+			    identifier_is(TYPE_IDENTIFIER(subtype), "u32"))
+				return true;
+		} else if (ptr_format[1] == 'S') {
+			if (TREE_CODE(subtype) == RECORD_TYPE && (
+			    identifier_is(TYPE_IDENTIFIER(subtype), "sockaddr") ||
+			    identifier_is(TYPE_IDENTIFIER(subtype), "__kernel_sockaddr_storage") ||
+			    identifier_is(TYPE_IDENTIFIER(subtype), "sockaddr_in") ||
+			    identifier_is(TYPE_IDENTIFIER(subtype), "sockaddr_in6")))
+				return true;
+			if (TREE_CODE(subtype) == ARRAY_TYPE &&
+			    TREE_CODE(TREE_TYPE(subtype)) == INTEGER_TYPE &&
+			    is_8bit_int_type(TREE_TYPE(subtype)))
+				return true;
+		}
+		if (TREE_CODE(subtype) == UNION_TYPE) /* FIXME: detect sockaddr union */
+			return true;
+		break;
+
+	/* UUID/GUID addresses */
+	case 'U':
+		if (is_8bit_int_type(subtype))
+			return true;
+		if (TREE_CODE(subtype) == ARRAY_TYPE && is_8bit_int_type(TREE_TYPE(subtype)))
+			return true;
+		if (TREE_CODE(subtype) == RECORD_TYPE && (
+		    identifier_is(TYPE_IDENTIFIER(subtype), "ceph_fsid") ||
+		    identifier_is(TYPE_IDENTIFIER(subtype), "efi_guid_t") ||
+		    identifier_is(TYPE_IDENTIFIER(subtype), "guid_t") ||
+		    identifier_is(TYPE_IDENTIFIER(subtype), "orangefs_khandle") ||
+		    identifier_is(TYPE_IDENTIFIER(subtype), "uuid_be") ||
+		    identifier_is(TYPE_IDENTIFIER(subtype), "uuid_le") ||
+		    identifier_is(TYPE_IDENTIFIER(subtype), "uuid_t")))
+			return true;
+		break;
+
+	/* dentry names */
+	case 'd':
+		if (TREE_CODE(subtype) == RECORD_TYPE &&
+		    identifier_is(TYPE_IDENTIFIER(subtype), "dentry"))
+			return true;
+		if (TREE_CODE(subtype) == VOID_TYPE) /* for NULL */
+			return true;
+		break;
+	case 'D':
+		if (TREE_CODE(subtype) == RECORD_TYPE &&
+		    identifier_is(TYPE_IDENTIFIER(subtype), "file"))
+			return true;
+		if (TREE_CODE(subtype) == VOID_TYPE) /* for NULL */
+			return true;
+		break;
+
+	/* block_device names */
+	case 'g':
+		if (TREE_CODE(subtype) == RECORD_TYPE &&
+		    identifier_is(TYPE_IDENTIFIER(subtype), "block_device"))
+			return true;
+		break;
+
+	/* struct va_format */
+	case 'V':
+		if (TREE_CODE(subtype) == RECORD_TYPE &&
+		    identifier_is(TYPE_IDENTIFIER(subtype), "va_format"))
+			return true;
+		break;
+
+	/* struct clk */
+	case 'C':
+		if (TREE_CODE(subtype) == RECORD_TYPE &&
+		    identifier_is(TYPE_IDENTIFIER(subtype), "clk"))
+			return true;
+		break;
+
+	/* struct rtc_time */
+	case 't':
+		if (ptr_format[1] == 'R') {
+			if (TREE_CODE(subtype) == RECORD_TYPE &&
+				identifier_is(TYPE_IDENTIFIER(subtype), "rtc_time"))
+				return true;
+		} else if (ptr_format[1] == 'T') {
+			if (TREE_CODE(subtype) == INTEGER_TYPE &&
+				identifier_is(TYPE_IDENTIFIER(subtype), "time64_t"))
+				return true;
+			if (TREE_CODE(subtype) == RECORD_TYPE &&
+				identifier_is(TYPE_IDENTIFIER(subtype), "timespec64"))
+				return true;
+		} else if (ptr_format[1] == '\0') {
+			/* test in lib/test_printf.c */
+			if (TREE_CODE(subtype) == RECORD_TYPE &&
+				identifier_is(TYPE_IDENTIFIER(subtype), "rtc_time"))
+				return true;
+		}
+		break;
+
+	/* bitmap and its derivatives such as cpumask and nodemask */
+	case 'b':
+		if (TREE_CODE(subtype) == INTEGER_TYPE)
+			return true;
+		if (TREE_CODE(subtype) == VOID_TYPE)
+			return true;
+		if (TREE_CODE(subtype) == ARRAY_TYPE &&
+		    TREE_CODE(TREE_TYPE(subtype)) == INTEGER_TYPE)
+			return true;
+		if (TREE_CODE(subtype) == RECORD_TYPE && (
+		    identifier_is(TYPE_IDENTIFIER(subtype), "cpumask") ||
+		    identifier_is(TYPE_IDENTIFIER(subtype), "cpumask_t")))
+			return true;
+		break;
+
+	/* Flags bitfields such as page flags, gfp_flags */
+	case 'G':
+		if (TREE_CODE(subtype) == INTEGER_TYPE &&
+		    identifier_is(TYPE_IDENTIFIER(subtype), "gfp_t"))
+			return true;
+		if (TREE_CODE(subtype) == INTEGER_TYPE &&
+		    identifier_is(TYPE_IDENTIFIER(subtype), "long unsigned int"))
+			return true;
+		if (TREE_CODE(subtype) == INTEGER_TYPE &&
+		    identifier_is(TYPE_IDENTIFIER(subtype), "unsigned int"))
+			return true;
+		if (TREE_CODE(subtype) == INTEGER_TYPE &&
+		    identifier_is(TYPE_IDENTIFIER(subtype), "vm_flags_t"))
+			return true;
+		break;
+
+	/* Network device features */
+	case 'N':
+		if (ptr_format[1] == 'F') {
+			if (TREE_CODE(subtype) == INTEGER_TYPE &&
+			    identifier_is(TYPE_IDENTIFIER(subtype), "netdev_features_t"))
+				return true;
+			if (TREE_CODE(subtype) == INTEGER_TYPE &&
+			    identifier_is(TYPE_IDENTIFIER(subtype), "long long unsigned int"))
+				return true;
+		}
+		break;
+
+	/* kobject based struct */
+	case 'O':
+		if (ptr_format[1] == 'F') {
+			if (TREE_CODE(subtype) == VOID_TYPE)
+				return true;
+			if (TREE_CODE(subtype) == RECORD_TYPE &&
+			    identifier_is(TYPE_IDENTIFIER(subtype), "device_node"))
+				return true;
+		}
+		break;
+
+	/* Fwnode handles */
+	case 'f':
+		if (ptr_format[1] == 'w') {
+			if (TREE_CODE(subtype) == RECORD_TYPE &&
+			    identifier_is(TYPE_IDENTIFIER(subtype), "fwnode_handle"))
+				return true;
+		}
+		break;
+
+	/* V4L2 and DRM FourCC code (pixel format) */
+	case '4':
+		if (ptr_format[1] == 'c' && ptr_format[2] == 'c') {
+			if (TREE_CODE(subtype) == INTEGER_TYPE && identifier_is(TYPE_IDENTIFIER(subtype), "__u32"))
+				return true;
+			if (TREE_CODE(subtype) == INTEGER_TYPE && identifier_is(TYPE_IDENTIFIER(subtype), "u32"))
+				return true;
+			if (TREE_CODE(subtype) == INTEGER_TYPE && identifier_is(TYPE_IDENTIFIER(subtype), "uint32_t"))
+				return true;
+		}
+		break;
+
+	/* Raw pointers (everything else after %p) */
+	case '\0':
+	case '\t':
+	case '\n':
+	case ' ':
+	case '!':
+	case '"':
+	case '#':
+	case '$':
+	case '%':
+	case '\'':
+	case '(':
+	case ')':
+	case '+':
+	case ',':
+	case '-':
+	case '.':
+	case '/':
+	case '0':
+	case ':':
+	case ';':
+	case '<':
+	case '=':
+	case '>':
+	case '?':
+	case '@':
+	case '[':
+	case '\\':
+	case ']':
+	case '^':
+	case '_':
+	case '{':
+	case '|':
+	case '}':
+		return true;
+	}
+
+	debug_tree(value);
+	return false;
+}
+
+/* Function from Emese's initify_plugin
+ * https://github.com/ephox-gcc-plugins/initify/blob/master/initify_plugin.c
+ */
+static const_tree get_string_cst(const_tree var)
+{
+	if (var == NULL_TREE)
+		return NULL_TREE;
+
+	if (TREE_CODE(var) == STRING_CST)
+		return var;
+
+	switch (TREE_CODE_CLASS(TREE_CODE(var))) {
+	case tcc_expression:
+	case tcc_reference: {
+		int i;
+
+		for (i = 0; i < TREE_OPERAND_LENGTH(var); i++) {
+			const_tree ret = get_string_cst(TREE_OPERAND(var, i));
+
+			if (ret != NULL_TREE)
+				return ret;
+		}
+		break;
+	case tcc_declaration:
+		/* const char [] variable with known content */
+		if (TYPE_READONLY(var)) {
+			const_tree subtype = TREE_TYPE(var);
+			if (TREE_CODE(subtype) == ARRAY_TYPE && is_8bit_int_type(TREE_TYPE(subtype))) {
+				return get_string_cst(DECL_INITIAL(var));
+			}
+		}
+		break;
+	}
+
+	default:
+		break;
+	}
+	return NULL_TREE;
+}
+
+/**
+ * Get the printf format attribute of a function, or NULL_TREE if it does not exist
+ *
+ * The first parameter of the printf attribute is given by:
+ *    TREE_INT_CST_ELT(TREE_VALUE(ret), 0)
+ * and the second one by:
+ *    TREE_INT_CST_ELT(TREE_VALUE(TREE_CHAIN(ret)), 0)
+ */
+static const_tree get_printf_attribute(location_t loc, const_tree fntype)
+{
+	const_tree attr, attrval;
+
+	/* Look up "format" attribute in declaration type */
+	attr = lookup_attribute("format", TYPE_ATTRIBUTES(fntype));
+	if (attr == NULL_TREE)
+		return NULL_TREE;
+
+	/* Filter "printf" value */
+	attrval = TREE_VALUE(attr);
+	if (attrval == NULL_TREE)
+		return NULL_TREE;
+	if (identifier_is(TREE_VALUE(attrval), "printf") ||
+	    identifier_is(TREE_VALUE(attrval), "__printf__") ||
+	    identifier_is(TREE_VALUE(attrval), "gnu_printf")) {
+		return TREE_CHAIN(attrval);
+	}
+
+	/* Ignore "scanf" format attribute */
+	if (identifier_is(TREE_VALUE(attrval), "scanf") ||
+	    identifier_is(TREE_VALUE(attrval), "__scanf__") ||
+	    identifier_is(TREE_VALUE(attrval), "gnu_scanf")) {
+		return NULL_TREE;
+	}
+	warning_at(loc, OPT_Wall, G_("Unknown format parameter %s\n"),
+		   IDENTIFIER_POINTER(TREE_VALUE(attrval)));
+	return NULL_TREE;
+}
+
+/**
+ * Get the type of the specified argument in the function declaration
+ *
+ * argidx = 1 for the first argument, 2 for the second one, etc.
+ */
+static const_tree get_fct_arg_type(const_tree fntype, HOST_WIDE_INT argidx)
+{
+	const_tree arg_type;
+	function_args_iterator arg_iter;
+
+	gcc_assert(argidx > 0);
+	FOREACH_FUNCTION_ARGS(fntype, arg_type, arg_iter) {
+		argidx -= 1;
+		if (!argidx)
+			return arg_type;
+	}
+	/* the call should has been made with "argidx <= gimple_call_num_args(call_stmt)" */
+	gcc_assert(false);
+}
+
+/**
+ * Analyze the calls to functions using printf-formatted arguments in a GIMPLE
+ * statement
+ */
+static void analyze_statement(gimple stmt)
+{
+	gcall *call_stmt;
+	const_tree printf_attr, fmtarg_type;
+	HOST_WIDE_INT fmt_idx, arg_idx;
+	const_tree fntype, format_tree, arg_tree;
+	int format_length;
+	const char *format;
+	unsigned int argnum;
+
+	/* Get the function declaration */
+	call_stmt = as_a_gcall(stmt);
+	fntype = gimple_call_fntype(call_stmt);
+	if (fntype == NULL_TREE) {
+		/* This happens when calling var_arg(), multiplication
+		 * overflow, ASAN...
+		 */
+		if (gimple_call_internal_p(call_stmt)) {
+			return;
+		}
+		warning_at(gimple_location(stmt), 0,
+			   G_("Unable to get the function type\n"));
+		debug_gimple_stmt(stmt); /* TODO remove? */
+		return;
+	}
+
+	/* Get the printf format attribute */
+	printf_attr = get_printf_attribute(gimple_location(stmt), fntype);
+	if (!printf_attr)
+		return;
+	fmt_idx = TREE_INT_CST_ELT(TREE_VALUE(printf_attr), 0);
+	arg_idx = TREE_INT_CST_ELT(TREE_VALUE(TREE_CHAIN(printf_attr)), 0);
+
+	/* Sanity checks on the number of arguments */
+	argnum = gimple_call_num_args(call_stmt);
+	if (fmt_idx < 1 || fmt_idx > argnum) {
+		warning_at(gimple_location(stmt), OPT_Wformat_,
+			   G_("Invalid call to function with attribute __printf(%lu, %lu)\n"),
+			   fmt_idx, arg_idx);
+		return;
+	}
+	if (arg_idx < 0 || arg_idx > argnum + 1) {
+		warning_at(gimple_location(stmt), OPT_Wformat_,
+			   G_("Invalid call to function with attribute __printf(%lu, %lu)\n"),
+			   fmt_idx, arg_idx);
+		return;
+	}
+
+	/* Warn if the format attribute type is not const char* */
+	fmtarg_type = get_fct_arg_type(fntype, fmt_idx);
+	if (TREE_CODE(fmtarg_type) != POINTER_TYPE ||
+	    !is_8bit_int_type(TREE_TYPE(fmtarg_type))) {
+		warning_at(gimple_location(stmt), OPT_Wformat_,
+			G_("Unexpected type for printf format attribute (not a char*)\n"));
+	} else if (!TYPE_READONLY(TREE_TYPE(fmtarg_type))) {
+		warning_at(gimple_location(stmt), OPT_Wformat_,
+			   G_("Call to a function with a non-const char* format\n"));
+	}
+
+	/* Do not play with va_args-based functions */
+	if (arg_idx == 0)
+		return;
+
+	/* Skip NULL format */
+	format_tree = gimple_call_arg(call_stmt, fmt_idx - 1);
+	if (TREE_CODE(format_tree) == INTEGER_CST &&
+	    TREE_INT_CST_ELT_CHECK(format_tree, 0) == 0)
+		return;
+
+	/* Retrieve the format string */
+	format_tree = get_string_cst(format_tree);
+	if (format_tree == NULL_TREE) {
+		warning_at(gimple_location(call_stmt), OPT_Wformat_security,
+			   G_("Call with a non-constant string\n"));
+		return;
+	}
+	gcc_assert(TREE_CODE(format_tree) == STRING_CST);
+	format_length = TREE_STRING_LENGTH(format_tree);
+	if (!format_length)
+		return;
+	format = TREE_STRING_POINTER(format_tree);
+	if (strnlen(format, format_length) != (size_t)(format_length - 1)) {
+		/* drivers/isdn/hardware/eicon/ uses dprintf("\000\377", ...)
+		 * as a legitimate way, with no % sign.
+		 */
+		if (format[0] != '\0' || memchr(format, '%', format_length)) {
+			warning_at(gimple_location(call_stmt), OPT_Wformat_,
+				   G_("Call with a a format which contains nul character\n"));
+		}
+		return;
+	}
+
+	while (*format) {
+		bool found, has_hex_prefix = false;
+		const char *subs_start = format;
+		unsigned int star_count = 0;
+
+		/* Found errors such as "0x%d" */
+		if (format[0] == '0' && format[1] == 'x' && format[2] == '%') {
+			/* go to the % sign and skip over format modifiers */
+			format += 2;
+			has_hex_prefix = true;
+		}
+
+		/* Skip normal characters */
+		if (*format != '%') {
+			format++;
+			continue;
+		}
+
+		/* Skip "%%" */
+		if (format[1] == '%') {
+			format += 2;
+			continue;
+		}
+
+		/* Found a % sign, skip format prefix */
+		found = true;
+		while (found) {
+			format++;
+			switch (*format) {
+			case '-':
+			case '+':
+			case ' ':
+			case '.':
+			case '#':
+			case '0': case '1': case '2': case '3': case '4':
+			case '5': case '6': case '7': case '8': case '9':
+			case 'h': case 'l': case 'L': case 't':
+			case 'z':
+				break;
+			case '*':
+				/* There may be several stars, like "%*.*s" */
+				star_count++;
+				break;
+			default:
+				found = false;
+			}
+		}
+
+		/* Get the current argument for the format */
+		if (arg_idx > argnum) {
+			warning_at(gimple_location(call_stmt), OPT_Wformat_,
+				   G_("Not enough arguments for format\n"));
+			return;
+		}
+		arg_tree = gimple_call_arg(call_stmt, arg_idx - 1);
+		arg_idx++;
+
+		while (star_count) {
+			/* size argument is an integer */
+			if (!is_integer_type(arg_tree)) {
+				warning_at(gimple_location(call_stmt),
+					   OPT_Wformat_,
+					   G_("Argument for the size of %.*s is not an integer\n"),
+					   (int)(format + 1 - subs_start), subs_start);
+			}
+
+			/* Get the next argument */
+			if (arg_idx > argnum) {
+				warning_at(gimple_location(call_stmt),
+					   OPT_Wformat_,
+					   G_("Not enough arguments for format\n"));
+				return;
+			}
+			arg_tree = gimple_call_arg(call_stmt, arg_idx - 1);
+			arg_idx++;
+			star_count--;
+		}
+
+		/* Check the format for hexadecimal. Allow:
+		 * - 0x%x, 0x%lx, 0x%X...
+		 * - 0x%p without any pointer modifier
+		 * - 0x%pK, 0x%pad, 0x*phN...
+		 */
+#define ALLOW_0xPTR_CHARS "abhKx:-.;,'/ )]\t\n"
+		if (has_hex_prefix && !(strchr("xX", *format) ||
+		    (*format == 'p' && memchr(ALLOW_0xPTR_CHARS, format[1], sizeof(ALLOW_0xPTR_CHARS))))) {
+			warning_at(gimple_location(call_stmt),
+				   OPT_Wformat_,
+				   G_("Bad format with 0x prefix: %.*s\n"),
+				   (int)(format + 1 - subs_start), subs_start);
+			/* Do not continue nor return in order to check the
+			 * consistency of the argument type too/
+			 */
+		}
+
+		/* Check the format */
+		switch (*format) {
+		case 'c':
+		case 'd':
+		case 'i':
+		case 'o':
+		case 'u':
+		case 'x':
+		case 'X':
+			/* integer type */
+			if (!is_integer_type(arg_tree)) {
+				warning_at(gimple_location(call_stmt),
+					   OPT_Wformat_,
+					   G_("Argument for %.*s is not an integer\n"),
+					   (int)(format + 1 - subs_start), subs_start);
+			}
+			format++;
+			break;
+		case 'f':
+			/* float type */
+			if (!is_float_type(arg_tree)) {
+				warning_at(gimple_location(call_stmt),
+					   OPT_Wformat_,
+					   G_("Argument for %.*s is not a float\n"),
+					   (int)(format + 1 - subs_start), subs_start);
+			}
+			format++;
+			break;
+		case 's':
+			if (*(format - 1) != 'l') {
+				/* string type */
+				if (!is_string_type(arg_tree, subs_start)) {
+					warning_at(gimple_location(call_stmt),
+						   OPT_Wformat_,
+						   G_("Argument for %.*s is not a string\n"),
+						   (int)(format + 1 - subs_start), subs_start);
+				}
+			} else {
+				/* UTF-16 string type %ls */
+				if (TREE_CODE(TREE_TYPE(arg_tree)) != POINTER_TYPE) {
+					warning_at(gimple_location(call_stmt),
+						   OPT_Wformat_,
+						   G_("Argument for %.*s is not a pointer\n"),
+						   (int)(format + 1 - subs_start), subs_start);
+				} else {
+					const_tree subtype = TREE_TYPE(TREE_TYPE(arg_tree));
+					if (is_16bit_int_type(subtype) ||
+					    (TREE_CODE(subtype) == ARRAY_TYPE && is_16bit_int_type(TREE_TYPE(subtype)))) {
+					} else {
+						debug_tree(arg_tree);
+						warning_at(gimple_location(call_stmt),
+							   OPT_Wformat_,
+							   G_("Argument for %.*s is not a UTF-16 string\n"),
+							   (int)(format + 1 - subs_start), subs_start);
+					}
+				}
+			}
+			format++;
+			break;
+		case 'p':
+			/* pointer type */
+			if (!is_fmtpointer_type(arg_tree, format + 1)) {
+				warning_at(gimple_location(call_stmt),
+					   OPT_Wformat_,
+					   G_("Argument for %.*s is not a pointer with a matching type\n"),
+					   (int)(format + 2 - subs_start), subs_start);
+			}
+			format++;
+			break;
+		default:
+			warning_at(gimple_location(call_stmt), OPT_Wformat_,
+				   G_("Unexpected format %s\n"), format);
+			format++;
+		}
+	}
+}
+
+static unsigned int printk_format_execute(void)
+{
+	basic_block bb;
+
+	FOR_EACH_BB_FN(bb, cfun) {
+		gimple_stmt_iterator gsi;
+
+		for (gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi)) {
+			gimple stmt;
+
+			/* Get the statement */
+			stmt = gsi_stmt(gsi);
+			if (!is_gimple_call(stmt))
+				continue;
+
+			analyze_statement(stmt);
+		}
+	}
+
+	return 0;
+}
+
+#define PASS_NAME printk_format
+
+#define NO_GATE
+#define TODO_FLAGS_FINISH TODO_dump_func
+
+#include "gcc-generate-gimple-pass.h"
+
+int plugin_init(struct plugin_name_args *plugin_info, struct plugin_gcc_version *version)
+{
+	const char * const plugin_name = plugin_info->base_name;
+	const int argc = plugin_info->argc;
+	const struct plugin_argument * const argv = plugin_info->argv;
+	int i;
+	bool enabled = true;
+
+	PASS_INFO(printk_format, "ssa", 1, PASS_POS_INSERT_AFTER);
+
+	if (!plugin_default_version_check(version, &gcc_version)) {
+		error(G_("incompatible gcc/plugin versions"));
+		return 1;
+	}
+
+	for (i = 0; i < argc; ++i) {
+		if (!(strcmp(argv[i].key, "disable"))) {
+			enabled = false;
+			continue;
+		}
+		error(G_("unknown option '-fplugin-arg-%s-%s'"), plugin_name, argv[i].key);
+	}
+
+	register_callback(plugin_name, PLUGIN_INFO, NULL,
+				&printk_format_plugin_info);
+	if (enabled) {
+		register_callback(plugin_name, PLUGIN_PASS_MANAGER_SETUP, NULL,
+					&printk_format_pass_info);
+	}
+
+	return 0;
+}
diff --git a/security/apparmor/mount.c b/security/apparmor/mount.c
index cdfa430ae216..19c0565f4b9e 100644
--- a/security/apparmor/mount.c
+++ b/security/apparmor/mount.c
@@ -49,7 +49,7 @@ static void audit_mnt_flags(struct audit_buffer *ab, unsigned long flags)
 	if (flags & MS_NODIRATIME)
 		audit_log_format(ab, ", nodiratime");
 	if (flags & MS_BIND)
-		audit_log_format(ab, flags & MS_REC ? ", rbind" : ", bind");
+		audit_log_format(ab, "%s", flags & MS_REC ? ", rbind" : ", bind");
 	if (flags & MS_MOVE)
 		audit_log_format(ab, ", move");
 	if (flags & MS_SILENT)
@@ -57,16 +57,16 @@ static void audit_mnt_flags(struct audit_buffer *ab, unsigned long flags)
 	if (flags & MS_POSIXACL)
 		audit_log_format(ab, ", acl");
 	if (flags & MS_UNBINDABLE)
-		audit_log_format(ab, flags & MS_REC ? ", runbindable" :
+		audit_log_format(ab, "%s", flags & MS_REC ? ", runbindable" :
 				 ", unbindable");
 	if (flags & MS_PRIVATE)
-		audit_log_format(ab, flags & MS_REC ? ", rprivate" :
+		audit_log_format(ab, "%s", flags & MS_REC ? ", rprivate" :
 				 ", private");
 	if (flags & MS_SLAVE)
-		audit_log_format(ab, flags & MS_REC ? ", rslave" :
+		audit_log_format(ab, "%s", flags & MS_REC ? ", rslave" :
 				 ", slave");
 	if (flags & MS_SHARED)
-		audit_log_format(ab, flags & MS_REC ? ", rshared" :
+		audit_log_format(ab, "%s", flags & MS_REC ? ", rshared" :
 				 ", shared");
 	if (flags & MS_RELATIME)
 		audit_log_format(ab, ", relatime");
diff --git a/sound/soc/apple/mca.c b/sound/soc/apple/mca.c
index ce77934f3eef..16059c591131 100644
--- a/sound/soc/apple/mca.c
+++ b/sound/soc/apple/mca.c
@@ -898,10 +898,10 @@ static struct dma_chan *mca_request_dma_channel(struct mca_cluster *cl, unsigned
 	bool is_tx = (stream == SNDRV_PCM_STREAM_PLAYBACK);
 #ifndef USE_RXB_FOR_CAPTURE
 	char *name = devm_kasprintf(cl->host->dev, GFP_KERNEL,
-				    is_tx ? "tx%da" : "rx%da", cl->no);
+				    "%s%da", is_tx ? "tx" : "rx", cl->no);
 #else
 	char *name = devm_kasprintf(cl->host->dev, GFP_KERNEL,
-				    is_tx ? "tx%da" : "rx%db", cl->no);
+				    "%s%d%s", is_tx ? "tx" : "rx", cl->no, is_tx ? "a" : "b");
 #endif
 	return of_dma_request_slave_channel(cl->host->dev->of_node, name);
 
diff --git a/sound/soc/intel/boards/sof_sdw.c b/sound/soc/intel/boards/sof_sdw.c
index 51b9449633a1..fe65572ce4f4 100644
--- a/sound/soc/intel/boards/sof_sdw.c
+++ b/sound/soc/intel/boards/sof_sdw.c
@@ -847,7 +847,6 @@ static int create_codec_dai_name(struct device *dev,
 		unsigned int sdw_version, unique_id, mfg_id;
 		unsigned int link_id, part_id, class_id;
 		int codec_index, comp_index;
-		char *codec_str;
 		u64 adr;
 
 		adr = link->adr_d[i].adr;
@@ -862,15 +861,13 @@ static int create_codec_dai_name(struct device *dev,
 		comp_index = i - adr_index + offset;
 		if (is_unique_device(link, sdw_version, mfg_id, part_id,
 				     class_id, i)) {
-			codec_str = "sdw:%01x:%04x:%04x:%02x";
 			codec[comp_index].name =
-				devm_kasprintf(dev, GFP_KERNEL, codec_str,
+				devm_kasprintf(dev, GFP_KERNEL, "sdw:%01x:%04x:%04x:%02x",
 					       link_id, mfg_id, part_id,
 					       class_id);
 		} else {
-			codec_str = "sdw:%01x:%04x:%04x:%02x:%01x";
 			codec[comp_index].name =
-				devm_kasprintf(dev, GFP_KERNEL, codec_str,
+				devm_kasprintf(dev, GFP_KERNEL, "sdw:%01x:%04x:%04x:%02x:%01x",
 					       link_id, mfg_id, part_id,
 					       class_id, unique_id);
 		}
diff --git a/sound/soc/stm/stm32_sai_sub.c b/sound/soc/stm/stm32_sai_sub.c
index f6695dee353b..c7c7bfb3b682 100644
--- a/sound/soc/stm/stm32_sai_sub.c
+++ b/sound/soc/stm/stm32_sai_sub.c
@@ -575,7 +575,7 @@ static int stm32_sai_set_sysclk(struct snd_soc_dai *cpu_dai,
 
 		ret = clk_set_rate_exclusive(sai->sai_mclk, freq);
 		if (ret) {
-			dev_err(cpu_dai->dev,
+			dev_err(cpu_dai->dev, "%s",
 				ret == -EBUSY ?
 				"Active streams have incompatible rates" :
 				"Could not set mclk rate\n");
diff --git a/sound/soc/ti/omap-mcbsp-st.c b/sound/soc/ti/omap-mcbsp-st.c
index 8163f453bf36..60ed51b4d107 100644
--- a/sound/soc/ti/omap-mcbsp-st.c
+++ b/sound/soc/ti/omap-mcbsp-st.c
@@ -243,9 +243,12 @@ static ssize_t st_taps_show(struct device *dev,
 	int i;
 
 	spin_lock_irq(&mcbsp->lock);
+	__diag_push()
+	__diag_ignore(GCC, 4, "-Wformat-security", "The format is known")
 	for (i = 0; i < st_data->nr_taps; i++)
 		status += sysfs_emit_at(buf, status, (i ? ", %d" : "%d"),
 					st_data->taps[i]);
+	__diag_pop()
 	if (i)
 		status += sysfs_emit_at(buf, status, "\n");
 	spin_unlock_irq(&mcbsp->lock);
diff --git a/tools/lib/bpf/relo_core.c b/tools/lib/bpf/relo_core.c
index a26b2f5fa0fc..3fd8739409d0 100644
--- a/tools/lib/bpf/relo_core.c
+++ b/tools/lib/bpf/relo_core.c
@@ -1191,7 +1191,10 @@ int bpf_core_format_spec(char *buf, size_t buf_sz, const struct bpf_core_spec *s
 			e = btf_enum(t) + spec->raw_spec[0];
 			s = btf__name_by_offset(spec->btf, e->name_off);
 			fmt_str = BTF_INFO_KFLAG(t->info) ? "::%s = %d" : "::%s = %u";
+			__diag_push()
+			__diag_ignore(GCC, 4, "-Wformat-security", "fmt_str is constant");
 			append_buf(fmt_str, s, e->val);
+			__diag_pop()
 		} else {
 			const struct btf_enum64 *e;
 			const char *fmt_str;
@@ -1199,7 +1202,10 @@ int bpf_core_format_spec(char *buf, size_t buf_sz, const struct bpf_core_spec *s
 			e = btf_enum64(t) + spec->raw_spec[0];
 			s = btf__name_by_offset(spec->btf, e->name_off);
 			fmt_str = BTF_INFO_KFLAG(t->info) ? "::%s = %lld" : "::%s = %llu";
+			__diag_push()
+			__diag_ignore(GCC, 4, "-Wformat-security", "fmt_str is constant");
 			append_buf(fmt_str, s, (unsigned long long)btf_enum64_value(e));
+			__diag_pop()
 		}
 		return len;
 	}
-- 
