From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Nicolas Iooss <nicolas.iooss_linux@m4x.org>
Date: Sat, 8 Oct 2016 14:45:13 +0200
Subject: [PATCH] {PLUGIN} Introduce a pointer dereference checker

This first version is a PoC draft which is not meant to go upstream.
This plugin addresses to problems which ought to be splitted in two
plugins: consistent calls to memcpy()-like functions (with two pointers
which would have the same "depth" but are void*), and bad use of & on a
pointer in a function taking void*. This second case leads to waaaay too
many false positives to be viable in the long run.

The main reason why with plugin is dirty is that it introduces a call to
__same_pointer_depths_chk() empty function at each memcpy/memove call,
so that even compiler-optimized code can be analyzed. A better approach
would be to attach the plugin to a pass where memcpy() calls have not
yet been optimized away. How is this done?

This plugins helped to detect the following bugs:
- 61ab0d403bbd ("ASoC: Intel: Atom: add a missing star in a memcpy
  call")
- ae6c33ba6e37 ("printk: fix parsing of "brl=" option")
- 238b323a681d ("libnvdimm, namespace: fix the type of name variable")

It has also detected some bugs reported and fixed by other people:
- 91c42b72f8e8 ("i40iw: Use correct src address in memcpy to rdma stats
  counters")
- eec11535ca3d ("hfs: fix hfs_readdir()")
---
 arch/Kconfig                                       |   6 +
 arch/arm/boot/compressed/decompress.c              |   2 +
 arch/arm/boot/compressed/string.c                  |   7 +
 arch/arm/include/asm/string.h                      |  12 +
 arch/x86/boot/compressed/misc.c                    |   4 +
 arch/x86/boot/compressed/string.c                  |   5 +
 arch/x86/boot/string.h                             |   4 +
 arch/x86/events/core.c                             |   9 +-
 arch/x86/include/asm/string_32.h                   |  24 +-
 arch/x86/include/asm/string_64.h                   |  18 +
 arch/x86/lib/memcpy_32.c                           |   3 +
 arch/x86/math-emu/fpu_entry.c                      |   7 +-
 drivers/acpi/property.c                            |  10 +-
 drivers/base/property.c                            |   2 +-
 drivers/block/DAC960.c                             |   2 +-
 drivers/dma/cppi41.c                               |   4 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c             |   2 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c             |  10 +-
 drivers/gpu/drm/drm_bufs.c                         |   4 +-
 drivers/gpu/drm/radeon/radeon_cs.c                 |   2 +-
 drivers/iio/industrialio-buffer.c                  |   2 +-
 drivers/isdn/i4l/isdn_common.c                     |   4 +-
 drivers/misc/ibmasm/lowlevel.c                     |   4 +-
 drivers/misc/mic/scif/scif_fd.c                    |   6 +-
 .../ethernet/netronome/nfp/nfpcore/nfp_resource.c  |   2 +-
 drivers/net/virtio_net.c                           |   2 +-
 drivers/net/wireless/ti/wlcore/main.c              |  15 +-
 drivers/scsi/csiostor/csio_hw.c                    |   6 +-
 drivers/scsi/pm8001/pm8001_ctl.c                   |   4 +-
 drivers/scsi/pm8001/pm8001_hwi.c                   |   2 +-
 drivers/staging/gdm724x/hci_packet.h               |   2 +-
 .../atomisp2/css2400/runtime/rmgr/src/rmgr_vbuf.c  |   6 +-
 drivers/staging/rtl8192e/rtl8192e/r8192E_cmdpkt.c  |   2 +-
 drivers/staging/rtl8192e/rtl8192e/rtl_core.c       |   4 +-
 drivers/staging/rtl8192u/r8192U_core.c             |   2 +-
 drivers/staging/rtl8192u/r819xU_cmdpkt.c           |   2 +-
 drivers/staging/rtl8192u/r819xU_firmware.c         |   2 +-
 drivers/thermal/int340x_thermal/int3402_thermal.c  |   2 +-
 drivers/usb/core/devio.c                           |  12 +-
 drivers/xen/xenbus/xenbus_xs.c                     |   4 +-
 fs/cifs/cifsacl.c                                  |  12 +-
 include/asm-generic/asm-prototypes.h               |   6 +
 include/linux/compiler.h                           |  23 ++
 include/linux/string.h                             |  16 +
 include/sound/pcm.h                                |  16 +-
 kernel/bpf/hashtab.c                               |   8 +-
 kernel/debug/kdb/kdb_support.c                     |  10 +-
 kernel/trace/trace.c                               |   7 +-
 kernel/trace/trace_functions.c                     |   6 +-
 kernel/trace/trace_kprobe.c                        |  32 +-
 kernel/workqueue.c                                 |   2 +-
 mm/percpu-vm.c                                     |   7 +-
 mm/slub.c                                          |   6 +-
 net/core/drop_monitor.c                            |  10 +-
 net/ipv4/netfilter/nf_nat_snmp_basic.c             |   8 +-
 net/phonet/socket.c                                |   7 +-
 net/rxrpc/key.c                                    |   2 +-
 net/rxrpc/rxkad.c                                  |   2 +-
 scripts/Makefile.gcc-plugins                       |   2 +
 scripts/gcc-plugins/deref_checker_plugin.c         | 408 +++++++++++++++++++++
 security/apparmor/apparmorfs.c                     |  11 +-
 sound/core/pcm_native.c                            |   2 +-
 62 files changed, 735 insertions(+), 90 deletions(-)
 create mode 100644 scripts/gcc-plugins/deref_checker_plugin.c

diff --git a/arch/Kconfig b/arch/Kconfig
index 0daa66e4285d..8dbae916fb25 100644
--- a/arch/Kconfig
+++ b/arch/Kconfig
@@ -513,6 +513,12 @@ config GCC_PLUGIN_PRINTK_FORMAT
 	  Check printk format strings with kernel specs.
 	  This is complementary to -Wformat-security and -Wformat=2 flags.
 
+config GCC_PLUGIN_DEREF_CHECKER
+	bool "Check pointer derefecencing in function calls"
+	depends on GCC_PLUGINS
+	help
+	  Check function calls involving pointers about some consistencies.
+
 config HAVE_CC_STACKPROTECTOR
 	bool
 	help
diff --git a/arch/arm/boot/compressed/decompress.c b/arch/arm/boot/compressed/decompress.c
index f3a4bedd1afc..685243c54bc5 100644
--- a/arch/arm/boot/compressed/decompress.c
+++ b/arch/arm/boot/compressed/decompress.c
@@ -48,8 +48,10 @@ extern int memcmp(const void *cs, const void *ct, size_t count);
 #endif
 
 #ifdef CONFIG_KERNEL_XZ
+#ifndef CONFIG_GCC_PLUGIN_DEREF_CHECKER
 #define memmove memmove
 #define memcpy memcpy
+#endif
 #include "../../../../lib/decompress_unxz.c"
 #endif
 
diff --git a/arch/arm/boot/compressed/string.c b/arch/arm/boot/compressed/string.c
index 689467448736..6fe0739fc08d 100644
--- a/arch/arm/boot/compressed/string.c
+++ b/arch/arm/boot/compressed/string.c
@@ -6,6 +6,13 @@
 
 #include <linux/string.h>
 
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+/* Disable definitions with __same_pointer_depths_chk */
+#undef memcmp
+#undef memcpy
+#undef memmove
+#endif
+
 void *memcpy(void *__dest, __const void *__src, size_t __n)
 {
 	int i = 0;
diff --git a/arch/arm/include/asm/string.h b/arch/arm/include/asm/string.h
index cf4f3aad0fc1..18589ae11bcb 100644
--- a/arch/arm/include/asm/string.h
+++ b/arch/arm/include/asm/string.h
@@ -38,4 +38,16 @@ extern void __memzero(void *ptr, __kernel_size_t n);
 		(__p);							\
 	})
 
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+#define memcpy(t, f, l) ({ __same_pointer_depths_chk(t, f); memcpy(t, f, l); })
+#define memmove(t, f, l) ({ __same_pointer_depths_chk(t, f); memmove(t, f, l); })
+/* Tell the plugin that the difference is intentional */
+static noinline void *memcpy_with_cast(void *dest, const void *src, size_t count)
+{
+    return memcpy(dest, src, count);
+}
+#else
+#define memcpy_with_cast memcpy
+#endif
+
 #endif
diff --git a/arch/x86/boot/compressed/misc.c b/arch/x86/boot/compressed/misc.c
index a0838ab929f2..adf72be156a0 100644
--- a/arch/x86/boot/compressed/misc.c
+++ b/arch/x86/boot/compressed/misc.c
@@ -34,6 +34,10 @@
 #undef memcpy
 #undef memset
 #define memzero(s, n)	memset((s), 0, (n))
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+/* The macro conflicts with the function definition below */
+#undef memmove
+#endif
 #define memmove		memmove
 
 /* Functions used by the included decompressor code below. */
diff --git a/arch/x86/boot/compressed/string.c b/arch/x86/boot/compressed/string.c
index cea140ce6b42..009ed75127b5 100644
--- a/arch/x86/boot/compressed/string.c
+++ b/arch/x86/boot/compressed/string.c
@@ -9,6 +9,11 @@
 
 #include "../string.c"
 
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+#undef memcpy
+#undef memmove
+#endif
+
 #ifdef CONFIG_X86_32
 static void *__memcpy(void *dest, const void *src, size_t n)
 {
diff --git a/arch/x86/boot/string.h b/arch/x86/boot/string.h
index 2203b6902096..92e3fb8ddb2c 100644
--- a/arch/x86/boot/string.h
+++ b/arch/x86/boot/string.h
@@ -15,7 +15,11 @@ int memcmp(const void *s1, const void *s2, size_t len);
  * do "undef memcpy" in .c file and link against right string.c
  */
 #ifndef __clang__ /* PR18415 */
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+#define memcpy(d,s,l) ({ __same_pointer_depths_chk(d, s);__builtin_memcpy(d,s,l);})
+#else
 #define memcpy(d,s,l) __builtin_memcpy(d,s,l)
+#endif
 #define memset(d,c,l) __builtin_memset(d,c,l)
 #define memcmp	__builtin_memcmp
 #endif
diff --git a/arch/x86/events/core.c b/arch/x86/events/core.c
index 8e3db8f642a7..75e08f40bafb 100644
--- a/arch/x86/events/core.c
+++ b/arch/x86/events/core.c
@@ -2445,7 +2445,14 @@ perf_callchain_user(struct perf_callchain_entry_ctx *entry, struct pt_regs *regs
 		if (!valid_user_frame(fp, sizeof(frame)))
 			break;
 
-		bytes = __copy_from_user_nmi(&frame.next_frame, fp, sizeof(*fp));
+		/* make the pointer checker plugin happy about
+		 * copying userspace data into a pointer
+		 */
+		{
+			unsigned long next_frame;
+			bytes = __copy_from_user_nmi(&next_frame, fp, sizeof(*fp));
+			frame.next_frame = (struct stack_frame *)next_frame;
+		}
 		if (bytes != 0)
 			break;
 		bytes = __copy_from_user_nmi(&frame.return_address, fp + 1, sizeof(*fp));
diff --git a/arch/x86/include/asm/string_32.h b/arch/x86/include/asm/string_32.h
index e9ee84873de5..26e2fc4a94da 100644
--- a/arch/x86/include/asm/string_32.h
+++ b/arch/x86/include/asm/string_32.h
@@ -32,6 +32,7 @@ extern size_t strlen(const char *s);
 static __always_inline void *__memcpy(void *to, const void *from, size_t n)
 {
 	int d0, d1, d2;
+	__same_pointer_depths_chk(to, from);
 	asm volatile("rep ; movsl\n\t"
 		     "movl %4,%%ecx\n\t"
 		     "andl $3,%%ecx\n\t"
@@ -52,6 +53,7 @@ static __always_inline void *__constant_memcpy(void *to, const void *from,
 					       size_t n)
 {
 	long esi, edi;
+	__same_pointer_depths_chk(to, from);
 	if (!n)
 		return to;
 
@@ -155,6 +157,7 @@ extern void *memcpy(void *, const void *, size_t);
 
 static inline void *__constant_memcpy3d(void *to, const void *from, size_t len)
 {
+	__same_pointer_depths_chk(to, from);
 	if (len < 512)
 		return __constant_memcpy(to, from, len);
 	return _mmx_memcpy(to, from, len);
@@ -162,15 +165,17 @@ static inline void *__constant_memcpy3d(void *to, const void *from, size_t len)
 
 static inline void *__memcpy3d(void *to, const void *from, size_t len)
 {
+	__same_pointer_depths_chk(to, from);
 	if (len < 512)
 		return __memcpy(to, from, len);
 	return _mmx_memcpy(to, from, len);
 }
 
 #define memcpy(t, f, n)				\
+	({ __same_pointer_depths_chk(t, f); \
 	(__builtin_constant_p((n))		\
 	 ? __constant_memcpy3d((t), (f), (n))	\
-	 : __memcpy3d((t), (f), (n)))
+	 : __memcpy3d((t), (f), (n)));})
 
 #else
 
@@ -181,24 +186,35 @@ static inline void *__memcpy3d(void *to, const void *from, size_t len)
 #ifndef CONFIG_KMEMCHECK
 
 #if (__GNUC__ >= 4)
-#define memcpy(t, f, n) __builtin_memcpy(t, f, n)
+#define memcpy(t, f, n) ({ __same_pointer_depths_chk(t, f); __builtin_memcpy(t, f, n);})
 #else
 #define memcpy(t, f, n)				\
+	({ __same_pointer_depths_chk(t, f); \
 	(__builtin_constant_p((n))		\
 	 ? __constant_memcpy((t), (f), (n))	\
-	 : __memcpy((t), (f), (n)))
+	 : __memcpy((t), (f), (n)));})
 #endif
 #else
 /*
  * kmemcheck becomes very happy if we use the REP instructions unconditionally,
  * because it means that we know both memory operands in advance.
  */
-#define memcpy(t, f, n) __memcpy((t), (f), (n))
+#define memcpy(t, f, n) ({ __same_pointer_depths_chk(t, f); __memcpy((t), (f), (n));})
 #endif
 
 #endif
 #endif /* !CONFIG_FORTIFY_SOURCE */
 
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+/* Tell the plugin that the difference is intentional */
+static noinline void *memcpy_with_cast(void *dest, const void *src, size_t count)
+{
+    return memcpy(dest, src, count);
+}
+#else
+#define memcpy_with_cast memcpy
+#endif
+
 #define __HAVE_ARCH_MEMMOVE
 void *memmove(void *dest, const void *src, size_t n);
 
diff --git a/arch/x86/include/asm/string_64.h b/arch/x86/include/asm/string_64.h
index 2a8c822de1fc..ede694ce3a84 100644
--- a/arch/x86/include/asm/string_64.h
+++ b/arch/x86/include/asm/string_64.h
@@ -10,6 +10,7 @@
 static __always_inline void *__inline_memcpy(void *to, const void *from, size_t n)
 {
 	unsigned long d0, d1, d2;
+	__same_pointer_depths_chk(to, from);
 	asm volatile("rep ; movsl\n\t"
 		     "testb $2,%b4\n\t"
 		     "je 1f\n\t"
@@ -68,6 +69,19 @@ char *strcpy(char *dest, const char *src);
 char *strcat(char *dest, const char *src);
 int strcmp(const char *cs, const char *ct);
 
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+#define __memcmp(s, t, l) ({ __same_pointer_depths_chk(s, t); __memcmp(s, t, l); })
+#define __memcpy(t, f, l) ({ __same_pointer_depths_chk(t, f); __memcpy(t, f, l); })
+#define __memmove(t, f, l) ({ __same_pointer_depths_chk(t, f); __memmove(t, f, l); })
+/* Tell the plugin that the difference is intentional */
+static noinline void *memcpy_with_cast(void *dest, const void *src, size_t count)
+{
+    return memcpy(dest, src, count);
+}
+#else
+#define memcpy_with_cast memcpy
+#endif
+
 #if defined(CONFIG_KASAN) && !defined(__SANITIZE_ADDRESS__)
 
 /*
@@ -84,6 +98,10 @@ int strcmp(const char *cs, const char *ct);
 #define __NO_FORTIFY /* FORTIFY_SOURCE uses __builtin_memcpy, etc. */
 #endif
 
+#elif defined(CONFIG_GCC_PLUGIN_DEREF_CHECKER)
+#define memcmp(s, t, l) ({ __same_pointer_depths_chk(s, t); memcmp(s, t, l); })
+#define memcpy(t, f, l) ({ __same_pointer_depths_chk(t, f); memcpy(t, f, l); })
+#define memmove(t, f, l) ({ __same_pointer_depths_chk(t, f); memmove(t, f, l); })
 #endif
 
 #define __HAVE_ARCH_MEMCPY_MCSAFE 1
diff --git a/arch/x86/lib/memcpy_32.c b/arch/x86/lib/memcpy_32.c
index 2eab7d0bfedd..de0c93633894 100644
--- a/arch/x86/lib/memcpy_32.c
+++ b/arch/x86/lib/memcpy_32.c
@@ -3,6 +3,9 @@
 
 #undef memcpy
 #undef memset
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+#undef memmove
+#endif
 
 __visible void *memcpy(void *to, const void *from, size_t n)
 {
diff --git a/arch/x86/math-emu/fpu_entry.c b/arch/x86/math-emu/fpu_entry.c
index 0203baefb5c0..60ab1963c47c 100644
--- a/arch/x86/math-emu/fpu_entry.c
+++ b/arch/x86/math-emu/fpu_entry.c
@@ -113,6 +113,7 @@ void math_emulate(struct math_emu_info *info)
 	unsigned long code_limit = 0;	/* Initialized to stop compiler warnings */
 	struct desc_struct code_descriptor;
 	struct fpu *fpu = &current->thread.fpu;
+	u_char __user **peip;
 
 	fpu__activate_curr(fpu);
 
@@ -166,7 +167,8 @@ void math_emulate(struct math_emu_info *info)
 
 	FPU_lookahead = !(FPU_EFLAGS & X86_EFLAGS_TF);
 
-	if (!valid_prefix(&byte1, (u_char __user **) & FPU_EIP,
+	peip = (u_char __user **) & FPU_EIP;
+	if (!valid_prefix(&byte1, peip,
 			  &addr_modes.override)) {
 		RE_ENTRANT_CHECK_OFF;
 		printk
@@ -530,7 +532,8 @@ void math_emulate(struct math_emu_info *info)
 
 	if (FPU_lookahead && !need_resched()) {
 		FPU_ORIG_EIP = FPU_EIP - code_base;
-		if (valid_prefix(&byte1, (u_char __user **) & FPU_EIP,
+		peip = (u_char __user **) & FPU_EIP;
+		if (valid_prefix(&byte1, peip,
 				 &addr_modes.override))
 			goto do_another_FPU_instruction;
 	}
diff --git a/drivers/acpi/property.c b/drivers/acpi/property.c
index 917c789f953d..c04f8047752f 100644
--- a/drivers/acpi/property.c
+++ b/drivers/acpi/property.c
@@ -856,9 +856,13 @@ static int acpi_data_prop_read(struct acpi_device_data *data,
 		ret = acpi_copy_property_array_u64(items, (u64 *)val, nval);
 		break;
 	case DEV_PROP_STRING:
-		ret = acpi_copy_property_array_string(
-			items, (char **)val,
-			min_t(u32, nval, obj->package.count));
+		{
+			/* Play nice with the pointer deref checker */
+			char **valp = (char **)val;
+			ret = acpi_copy_property_array_string(
+				items, valp,
+				min_t(u32, nval, obj->package.count));
+		}
 		break;
 	default:
 		ret = -EINVAL;
diff --git a/drivers/base/property.c b/drivers/base/property.c
index edf02c1b5845..4dddb119cc6a 100644
--- a/drivers/base/property.c
+++ b/drivers/base/property.c
@@ -148,7 +148,7 @@ static int pset_prop_read_string_array(struct property_set *pset,
 				       const char **strings, size_t nval)
 {
 	const struct property_entry *prop;
-	const void *pointer;
+	const char *const *pointer; /* Play nice with the pointer deref checker */
 	size_t array_len, length;
 
 	/* Find out the array length. */
diff --git a/drivers/block/DAC960.c b/drivers/block/DAC960.c
index f174d3324e5e..e0efa09c5ee9 100644
--- a/drivers/block/DAC960.c
+++ b/drivers/block/DAC960.c
@@ -3731,7 +3731,7 @@ static void DAC960_V1_ProcessCompletedCommand(DAC960_Command_T *Command)
 	      Controller->V1.PendingRebuildFlag = NewEnquiry->RebuildFlag;
 	      Controller->V1.RebuildFlagPending = true;
 	    }
-	  memcpy(&Controller->V1.Enquiry, &Controller->V1.NewEnquiry,
+	  memcpy(&Controller->V1.Enquiry, Controller->V1.NewEnquiry, /* BUG! */
 		 sizeof(DAC960_V1_Enquiry_T));
 	}
       else if (CommandOpcode == DAC960_V1_PerformEventLogOperation)
diff --git a/drivers/dma/cppi41.c b/drivers/dma/cppi41.c
index f7e965f63274..229d1478795e 100644
--- a/drivers/dma/cppi41.c
+++ b/drivers/dma/cppi41.c
@@ -274,12 +274,12 @@ static struct cppi41_channel *desc_to_chan(struct cppi41_dd *cdd, u32 desc)
 	return c;
 }
 
-static void cppi_writel(u32 val, void *__iomem *mem)
+static void cppi_writel(u32 val, void __iomem *mem)
 {
 	__raw_writel(val, mem);
 }
 
-static u32 cppi_readl(void *__iomem *mem)
+static u32 cppi_readl(void __iomem *mem)
 {
 	return __raw_readl(mem);
 }
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c
index 5599c01b265d..4e8d672adf8b 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c
@@ -106,7 +106,7 @@ static int amdgpu_cs_parser_init(struct amdgpu_cs_parser *p, void *data)
 	}
 
 	for (i = 0; i < p->nchunks; i++) {
-		struct drm_amdgpu_cs_chunk __user **chunk_ptr = NULL;
+		struct drm_amdgpu_cs_chunk __user *chunk_ptr = NULL; /* harmless BUG */
 		struct drm_amdgpu_cs_chunk user_chunk;
 		uint32_t __user *cdata;
 
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c
index 5795f81369f0..a6c8528eab57 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c
@@ -1044,9 +1044,12 @@ static int amdgpu_vm_update_level(struct amdgpu_device *adev,
 
 	WARN_ON(vm->use_cpu_for_update && shadow);
 	if (vm->use_cpu_for_update && !shadow) {
-		r = amdgpu_bo_kmap(parent->bo, (void **)&pd_addr);
+		/* Be nice with pointer deref checker */
+		void *pd_addr_ptr;
+		r = amdgpu_bo_kmap(parent->bo, &pd_addr_ptr);
 		if (r)
 			return r;
+		pd_addr = (uint64_t)(uintptr_t)pd_addr_ptr;
 		r = amdgpu_vm_bo_wait(adev, parent->bo);
 		if (unlikely(r)) {
 			amdgpu_bo_kunmap(parent->bo);
@@ -1315,9 +1318,12 @@ static int amdgpu_vm_update_ptes(struct amdgpu_pte_update_params *params,
 			nptes = AMDGPU_VM_PTE_COUNT(adev) - (addr & mask);
 
 		if (use_cpu_update) {
-			r = amdgpu_bo_kmap(pt, (void *)&pe_start);
+			/* Be nice with pointer deref checker */
+			void *pe_start_ptr;
+			r = amdgpu_bo_kmap(pt, &pe_start_ptr);
 			if (r)
 				return r;
+			pe_start = (uint64_t)(uintptr_t)pe_start_ptr;
 		} else
 			pe_start = amdgpu_bo_gpu_offset(pt);
 
diff --git a/drivers/gpu/drm/drm_bufs.c b/drivers/gpu/drm/drm_bufs.c
index 1ee84dd802d4..e25ffa74e16e 100644
--- a/drivers/gpu/drm/drm_bufs.c
+++ b/drivers/gpu/drm/drm_bufs.c
@@ -1517,6 +1517,8 @@ static int map_one_buf(void *data, int idx, unsigned long virtual,
 {
 	struct drm_buf_map *request = data;
 	unsigned long address = virtual + buf->offset;	/* *** */
+	/* make the pointer checker plugin happy about copying an unsigned long to an void __user* */
+	unsigned long *preqaddr = (unsigned long *)&request->list[idx].address;
 
 	if (copy_to_user(&request->list[idx].idx, &buf->idx,
 			 sizeof(request->list[0].idx)))
@@ -1526,7 +1528,7 @@ static int map_one_buf(void *data, int idx, unsigned long virtual,
 		return -EFAULT;
 	if (clear_user(&request->list[idx].used, sizeof(int)))
 		return -EFAULT;
-	if (copy_to_user(&request->list[idx].address, &address,
+	if (copy_to_user(preqaddr, &address,
 			 sizeof(address)))
 		return -EFAULT;
 	return 0;
diff --git a/drivers/gpu/drm/radeon/radeon_cs.c b/drivers/gpu/drm/radeon/radeon_cs.c
index 00b22af70f5c..ea1f836129f7 100644
--- a/drivers/gpu/drm/radeon/radeon_cs.c
+++ b/drivers/gpu/drm/radeon/radeon_cs.c
@@ -299,7 +299,7 @@ int radeon_cs_parser_init(struct radeon_cs_parser *p, void *data)
 		return -ENOMEM;
 	}
 	for (i = 0; i < p->nchunks; i++) {
-		struct drm_radeon_cs_chunk __user **chunk_ptr = NULL;
+		struct drm_radeon_cs_chunk __user *chunk_ptr = NULL;
 		struct drm_radeon_cs_chunk user_chunk;
 		uint32_t __user *cdata;
 
diff --git a/drivers/iio/industrialio-buffer.c b/drivers/iio/industrialio-buffer.c
index d2b465140a6b..7b035aeb3c84 100644
--- a/drivers/iio/industrialio-buffer.c
+++ b/drivers/iio/industrialio-buffer.c
@@ -1308,7 +1308,7 @@ int iio_buffer_alloc_sysfs_and_mask(struct iio_dev *indio_dev)
 		goto error_free_scan_mask;
 	}
 	if (buffer->scan_el_attrs)
-		memcpy(buffer->scan_el_group.attrs, buffer->scan_el_attrs,
+		memcpy(buffer->scan_el_group.attrs, buffer->scan_el_attrs->attrs, /* BUG? I did not understand this code */
 		       sizeof(buffer->scan_el_group.attrs[0])*attrcount_orig);
 	attrn = attrcount_orig;
 
diff --git a/drivers/isdn/i4l/isdn_common.c b/drivers/isdn/i4l/isdn_common.c
index 89b09c51ab7c..c286065c6aff 100644
--- a/drivers/isdn/i4l/isdn_common.c
+++ b/drivers/isdn/i4l/isdn_common.c
@@ -1640,7 +1640,9 @@ isdn_ioctl(struct file *file, uint cmd, ulong arg)
 				return -EINVAL;
 		case IIOCDBGVAR:
 			if (arg) {
-				if (copy_to_user(argp, &dev, sizeof(ulong)))
+				/* Make the pointer checker plugin happy about copying a pointer into a buffer */
+				ulong dev_value = (ulong)dev;
+				if (copy_to_user(argp, &dev_value, sizeof(ulong)))
 					return -EFAULT;
 				return 0;
 			} else
diff --git a/drivers/misc/ibmasm/lowlevel.c b/drivers/misc/ibmasm/lowlevel.c
index 5319ea261c05..a1863712df83 100644
--- a/drivers/misc/ibmasm/lowlevel.c
+++ b/drivers/misc/ibmasm/lowlevel.c
@@ -47,7 +47,7 @@ int ibmasm_send_i2o_message(struct service_processor *sp)
 	message = get_i2o_message(sp->base_address, mfa);
 
 	memcpy_toio(&message->header, &header, sizeof(struct i2o_header));
-	memcpy_toio(&message->data, command->buffer, command_size);
+	memcpy_toio(message->data, command->buffer, command_size); /* BUG? */
 
 	set_mfa_inbound(sp->base_address, mfa);
 
@@ -74,7 +74,7 @@ irqreturn_t ibmasm_interrupt_handler(int irq, void * dev_id)
 	mfa = get_mfa_outbound(base_address);
 	if (valid_mfa(mfa)) {
 		struct i2o_message *msg = get_i2o_message(base_address, mfa);
-		ibmasm_receive_message(sp, &msg->data, incoming_data_size(msg));
+		ibmasm_receive_message(sp, msg->data, incoming_data_size(msg)); /* BUG? */
 	} else
 		dbg("didn't get a valid MFA\n");
 
diff --git a/drivers/misc/mic/scif/scif_fd.c b/drivers/misc/mic/scif/scif_fd.c
index f7e826142a72..d011669a6a16 100644
--- a/drivers/misc/mic/scif/scif_fd.c
+++ b/drivers/misc/mic/scif/scif_fd.c
@@ -173,7 +173,11 @@ static long scif_fdioctl(struct file *f, unsigned int cmd, unsigned long arg)
 		struct list_head *pos, *tmpq;
 
 		/* Finally replace the pointer to the accepted endpoint */
-		if (copy_from_user(&newep, argp, sizeof(void *)))
+		/* Slient the pointer deref checker here even though the code looks strange:
+		 * how is the kernel pointer which is obtained by userspace sanitized?
+		 */
+		void *__user *argpp = (void *__user *)argp;
+		if (copy_from_user(&newep, argpp, sizeof(void *)))
 			return -EFAULT;
 
 		/* Remove form the user accept queue */
diff --git a/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_resource.c b/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_resource.c
index 072612263dab..d9efc65bd344 100644
--- a/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_resource.c
+++ b/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_resource.c
@@ -107,7 +107,7 @@ static int nfp_cpp_resource_find(struct nfp_cpp *cpp, struct nfp_resource *res)
 	strncpy(name_pad, res->name, sizeof(name_pad));
 
 	/* Search for a matching entry */
-	if (!memcmp(name_pad, NFP_RESOURCE_TBL_NAME "\0\0\0\0\0\0\0\0", 8)) {
+	if (!memcmp(name_pad, NFP_RESOURCE_TBL_NAME, 8)) {
 		nfp_err(cpp, "Grabbing device lock not supported\n");
 		return -EOPNOTSUPP;
 	}
diff --git a/drivers/net/virtio_net.c b/drivers/net/virtio_net.c
index f41ab0ea942a..3893f6bf032b 100644
--- a/drivers/net/virtio_net.c
+++ b/drivers/net/virtio_net.c
@@ -729,7 +729,7 @@ static struct sk_buff *receive_mergeable(struct net_device *dev,
 }
 
 static int receive_buf(struct virtnet_info *vi, struct receive_queue *rq,
-		       void *buf, unsigned int len, void **ctx)
+		       void *buf, unsigned int len, void *ctx /* BUG? */)
 {
 	struct net_device *dev = vi->dev;
 	struct sk_buff *skb;
diff --git a/drivers/net/wireless/ti/wlcore/main.c b/drivers/net/wireless/ti/wlcore/main.c
index 60aaa850fbd1..f8163bfded30 100644
--- a/drivers/net/wireless/ti/wlcore/main.c
+++ b/drivers/net/wireless/ti/wlcore/main.c
@@ -1461,7 +1461,20 @@ void wl1271_rx_filter_flatten_fields(struct wl12xx_rx_filter *filter,
 		field->flags = filter->fields[i].flags;
 		field->len = filter->fields[i].len;
 
-		memcpy(&field->pattern, filter->fields[i].pattern, field->len);
+		/* FIXME: how is it supposed to work?
+			struct wl12xx_rx_filter_field {
+				__le16 offset;
+				u8 len;
+				u8 flags;
+				u8 *pattern;
+			} __packed;
+		 * => offset to end of header (u8 pattern[0]) or allocated mem?
+		 * Let's guess that it is offset to end of header (need to check the allocation one day...)
+		 */
+		{
+			void *dst = &field->pattern;
+			memcpy(dst, filter->fields[i].pattern, field->len);
+		}
 		buf += sizeof(struct wl12xx_rx_filter_field) -
 			sizeof(u8 *) + field->len;
 	}
diff --git a/drivers/scsi/csiostor/csio_hw.c b/drivers/scsi/csiostor/csio_hw.c
index 2029ad225121..1e5acea213a3 100644
--- a/drivers/scsi/csiostor/csio_hw.c
+++ b/drivers/scsi/csiostor/csio_hw.c
@@ -3645,7 +3645,11 @@ csio_evtq_worker(struct work_struct *work)
 				break;
 
 			case CSIO_EVT_DEV_LOSS:
-				memcpy(&rn, evt_msg->data, sizeof(rn));
+				{
+					/* Play nice with the pointer deref checker */
+					const struct csio_rnode **src = (const struct csio_rnode **)(evt_msg->data);
+					memcpy(&rn, src, sizeof(rn));
+				}
 				csio_rnode_devloss_handler(rn);
 				break;
 
diff --git a/drivers/scsi/pm8001/pm8001_ctl.c b/drivers/scsi/pm8001/pm8001_ctl.c
index be8269c8d127..4748d85032ad 100644
--- a/drivers/scsi/pm8001/pm8001_ctl.c
+++ b/drivers/scsi/pm8001/pm8001_ctl.c
@@ -539,7 +539,7 @@ static int pm8001_set_nvmd(struct pm8001_hba_info *pm8001_ha)
 		return -ENOMEM;
 	}
 	payload = (struct pm8001_ioctl_payload *)ioctlbuffer;
-	memcpy((u8 *)&payload->func_specific, (u8 *)pm8001_ha->fw_image->data,
+	memcpy((u8 *)payload->func_specific, (u8 *)pm8001_ha->fw_image->data, /* BUG? */
 				pm8001_ha->fw_image->size);
 	payload->length = pm8001_ha->fw_image->size;
 	payload->id = 0;
@@ -590,7 +590,7 @@ static int pm8001_update_flash(struct pm8001_hba_info *pm8001_ha)
 			payload->length = 1024*16;
 			payload->id = 0;
 			fwControl =
-			      (struct fw_control_info *)&payload->func_specific;
+			      (struct fw_control_info *)payload->func_specific; /* BUG? */
 			fwControl->len = IOCTL_BUF_SIZE;   /* IN */
 			fwControl->size = partitionSize + HEADER_LEN;/* IN */
 			fwControl->retcode = 0;/* OUT */
diff --git a/drivers/scsi/pm8001/pm8001_hwi.c b/drivers/scsi/pm8001/pm8001_hwi.c
index 10546faac58c..d7f5585a1a31 100644
--- a/drivers/scsi/pm8001/pm8001_hwi.c
+++ b/drivers/scsi/pm8001/pm8001_hwi.c
@@ -4831,7 +4831,7 @@ int pm8001_chip_set_nvmd_req(struct pm8001_hba_info *pm8001_ha,
 		return -ENOMEM;
 	circularQ = &pm8001_ha->inbnd_q_tbl[0];
 	memcpy(pm8001_ha->memoryMap.region[NVMD].virt_ptr,
-		&ioctl_payload->func_specific,
+		ioctl_payload->func_specific, /* BUG? */
 		ioctl_payload->length);
 	memset(&nvmd_req, 0, sizeof(nvmd_req));
 	rc = pm8001_tag_alloc(pm8001_ha, &tag);
diff --git a/drivers/staging/gdm724x/hci_packet.h b/drivers/staging/gdm724x/hci_packet.h
index 22ce8b9477b6..080180c00f0e 100644
--- a/drivers/staging/gdm724x/hci_packet.h
+++ b/drivers/staging/gdm724x/hci_packet.h
@@ -44,7 +44,7 @@ struct hci_packet {
 struct tlv {
 	u8 type;
 	u8 len;
-	u8 *data[1];
+	u8 data[0];
 } __packed;
 
 struct sdu_header {
diff --git a/drivers/staging/media/atomisp/pci/atomisp2/css2400/runtime/rmgr/src/rmgr_vbuf.c b/drivers/staging/media/atomisp/pci/atomisp2/css2400/runtime/rmgr/src/rmgr_vbuf.c
index fa92d8da8f1c..dda5e3f37917 100644
--- a/drivers/staging/media/atomisp/pci/atomisp2/css2400/runtime/rmgr/src/rmgr_vbuf.c
+++ b/drivers/staging/media/atomisp/pci/atomisp2/css2400/runtime/rmgr/src/rmgr_vbuf.c
@@ -192,7 +192,11 @@ void ia_css_rmgr_uninit_vbuf(struct ia_css_rmgr_vbuf_pool *pool)
 			}
 		}
 		/* now free the pool handles list */
-		sh_css_free(pool->handles);
+		{
+			/* Be nice with pointer deref checker */
+			void *h = pool->handles;
+			sh_css_free(h);
+		}
 		pool->handles = NULL;
 	}
 }
diff --git a/drivers/staging/rtl8192e/rtl8192e/r8192E_cmdpkt.c b/drivers/staging/rtl8192e/rtl8192e/r8192E_cmdpkt.c
index 467287ae6c1c..f0a203d743dd 100644
--- a/drivers/staging/rtl8192e/rtl8192e/r8192E_cmdpkt.c
+++ b/drivers/staging/rtl8192e/rtl8192e/r8192E_cmdpkt.c
@@ -54,7 +54,7 @@ bool rtl92e_send_cmd_pkt(struct net_device *dev, u32 type, const void *data,
 			goto Failed;
 		}
 
-		memcpy((unsigned char *)(skb->cb), &dev, sizeof(dev));
+		memcpy_with_cast((unsigned char *)(skb->cb), &dev, sizeof(dev));
 		tcb_desc = (struct cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);
 		tcb_desc->queue_index = TXCMD_QUEUE;
 		tcb_desc->bCmdOrInit = type;
diff --git a/drivers/staging/rtl8192e/rtl8192e/rtl_core.c b/drivers/staging/rtl8192e/rtl8192e/rtl_core.c
index aca52654825b..df7c7ef5c753 100644
--- a/drivers/staging/rtl8192e/rtl8192e/rtl_core.c
+++ b/drivers/staging/rtl8192e/rtl8192e/rtl_core.c
@@ -1627,7 +1627,7 @@ static void _rtl92e_hard_data_xmit(struct sk_buff *skb, struct net_device *dev,
 		netdev_warn(dev, "%s(): queue index == TXCMD_QUEUE\n",
 			    __func__);
 
-	memcpy((unsigned char *)(skb->cb), &dev, sizeof(dev));
+	memcpy_with_cast((unsigned char *)(skb->cb), &dev, sizeof(dev));
 	skb_push(skb, priv->rtllib->tx_headroom);
 	ret = _rtl92e_tx(dev, skb);
 	if (ret != 0)
@@ -1656,7 +1656,7 @@ static int _rtl92e_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
 		}
 	}
 
-	memcpy((unsigned char *)(skb->cb), &dev, sizeof(dev));
+	memcpy_with_cast((unsigned char *)(skb->cb), &dev, sizeof(dev));
 	if (queue_index == TXCMD_QUEUE) {
 		_rtl92e_tx_cmd(dev, skb);
 		return 0;
diff --git a/drivers/staging/rtl8192u/r8192U_core.c b/drivers/staging/rtl8192u/r8192U_core.c
index 779ecdbc4e17..428b0f5f1a38 100644
--- a/drivers/staging/rtl8192u/r8192U_core.c
+++ b/drivers/staging/rtl8192u/r8192U_core.c
@@ -1040,7 +1040,7 @@ static int rtl8192_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
 
 	spin_lock_irqsave(&priv->tx_lock, flags);
 
-	memcpy((unsigned char *)(skb->cb), &dev, sizeof(dev));
+	memcpy_with_cast((unsigned char *)(skb->cb), &dev, sizeof(dev));
 	if (queue_index == TXCMD_QUEUE) {
 		skb_push(skb, USB_HWDESC_HEADER_LEN);
 		rtl819xU_tx_cmd(dev, skb);
diff --git a/drivers/staging/rtl8192u/r819xU_cmdpkt.c b/drivers/staging/rtl8192u/r819xU_cmdpkt.c
index 87ab3ba760fc..4a9e97556b36 100644
--- a/drivers/staging/rtl8192u/r819xU_cmdpkt.c
+++ b/drivers/staging/rtl8192u/r819xU_cmdpkt.c
@@ -38,7 +38,7 @@ rt_status SendTxCommandPacket(struct net_device *dev, void *pData, u32 DataLen)
 	skb  = dev_alloc_skb(USB_HWDESC_HEADER_LEN + DataLen + 4);
 	if (!skb)
 		return RT_STATUS_FAILURE;
-	memcpy((unsigned char *)(skb->cb), &dev, sizeof(dev));
+	memcpy_with_cast((unsigned char *)(skb->cb), &dev, sizeof(dev));
 	tcb_desc = (struct cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);
 	tcb_desc->queue_index = TXCMD_QUEUE;
 	tcb_desc->bCmdOrInit = DESC_PACKET_TYPE_NORMAL;
diff --git a/drivers/staging/rtl8192u/r819xU_firmware.c b/drivers/staging/rtl8192u/r819xU_firmware.c
index 35d1786703a7..c80ba723c2ba 100644
--- a/drivers/staging/rtl8192u/r819xU_firmware.c
+++ b/drivers/staging/rtl8192u/r819xU_firmware.c
@@ -66,7 +66,7 @@ static bool fw_download_code(struct net_device *dev, u8 *code_virtual_address,
 		skb  = dev_alloc_skb(USB_HWDESC_HEADER_LEN + frag_length + 4);
 		if (!skb)
 			return false;
-		memcpy((unsigned char *)(skb->cb), &dev, sizeof(dev));
+		memcpy_with_cast((unsigned char *)(skb->cb), &dev, sizeof(dev));
 		tcb_desc = (struct cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);
 		tcb_desc->queue_index = TXCMD_QUEUE;
 		tcb_desc->bCmdOrInit = DESC_PACKET_TYPE_INIT;
diff --git a/drivers/thermal/int340x_thermal/int3402_thermal.c b/drivers/thermal/int340x_thermal/int3402_thermal.c
index 8e90b3151a42..93840a11f6ff 100644
--- a/drivers/thermal/int340x_thermal/int3402_thermal.c
+++ b/drivers/thermal/int340x_thermal/int3402_thermal.c
@@ -20,7 +20,7 @@
 #define INT3402_THERMAL_EVENT		0x90
 
 struct int3402_thermal_data {
-	acpi_handle *handle;
+	acpi_handle handle; /* harmless bug: too many stars */
 	struct int34x_thermal_zone *int340x_zone;
 };
 
diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index ebe27595c4af..fe27bcdd2e0c 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -1891,12 +1891,13 @@ static struct async *reap_as(struct usb_dev_state *ps)
 static int proc_reapurb(struct usb_dev_state *ps, void __user *arg)
 {
 	struct async *as = reap_as(ps);
+	void __user * __user *parg = (void __user * __user *)arg;
 
 	if (as) {
 		int retval;
 
 		snoop(&ps->dev->dev, "reap %pK\n", as->userurb);
-		retval = processcompl(as, (void __user * __user *)arg);
+		retval = processcompl(as, parg);
 		free_async(as);
 		return retval;
 	}
@@ -1909,11 +1910,12 @@ static int proc_reapurbnonblock(struct usb_dev_state *ps, void __user *arg)
 {
 	int retval;
 	struct async *as;
+	void __user * __user *parg = (void __user * __user *)arg;
 
 	as = async_getcompleted(ps);
 	if (as) {
 		snoop(&ps->dev->dev, "reap %pK\n", as->userurb);
-		retval = processcompl(as, (void __user * __user *)arg);
+		retval = processcompl(as, parg);
 		free_async(as);
 	} else {
 		retval = (connected(ps) ? -EAGAIN : -ENODEV);
@@ -2033,12 +2035,13 @@ static int processcompl_compat(struct async *as, void __user * __user *arg)
 static int proc_reapurb_compat(struct usb_dev_state *ps, void __user *arg)
 {
 	struct async *as = reap_as(ps);
+	void __user * __user *parg = (void __user * __user *)arg;
 
 	if (as) {
 		int retval;
 
 		snoop(&ps->dev->dev, "reap %pK\n", as->userurb);
-		retval = processcompl_compat(as, (void __user * __user *)arg);
+		retval = processcompl_compat(as, parg);
 		free_async(as);
 		return retval;
 	}
@@ -2051,11 +2054,12 @@ static int proc_reapurbnonblock_compat(struct usb_dev_state *ps, void __user *ar
 {
 	int retval;
 	struct async *as;
+	void __user * __user *parg = (void __user * __user *)arg;
 
 	as = async_getcompleted(ps);
 	if (as) {
 		snoop(&ps->dev->dev, "reap %pK\n", as->userurb);
-		retval = processcompl_compat(as, (void __user * __user *)arg);
+		retval = processcompl_compat(as, parg);
 		free_async(as);
 	} else {
 		retval = (connected(ps) ? -EAGAIN : -ENODEV);
diff --git a/drivers/xen/xenbus/xenbus_xs.c b/drivers/xen/xenbus/xenbus_xs.c
index e46080214955..abde0fe24f9c 100644
--- a/drivers/xen/xenbus/xenbus_xs.c
+++ b/drivers/xen/xenbus/xenbus_xs.c
@@ -398,7 +398,9 @@ static char **split(char *strings, unsigned int len, unsigned int *num)
 		kfree(strings);
 		return ERR_PTR(-ENOMEM);
 	}
-	memcpy(&ret[*num], strings, len);
+	/* Be nice with pointer deref checker: the ned of ret is char* */
+	p = (char *)&ret[*num];
+	memcpy(p, strings, len);
 	kfree(strings);
 
 	strings = (char *)&ret[*num];
diff --git a/fs/cifs/cifsacl.c b/fs/cifs/cifsacl.c
index b98436f5c7c7..86ac27daa6c5 100644
--- a/fs/cifs/cifsacl.c
+++ b/fs/cifs/cifsacl.c
@@ -426,16 +426,20 @@ sid_to_id(struct cifs_sb_info *cifs_sb, struct cifs_sid *psid,
 	}
 
 	if (sidtype == SIDOWNER) {
-		kuid_t uid;
+		kuid_t uid, *ppayload_uid;
 		uid_t id;
-		memcpy(&id, &sidkey->payload.data[0], sizeof(uid_t));
+		/* Play nice with the pointer deref checker */
+		ppayload_uid = (kuid_t *)&sidkey->payload.data[0];
+		memcpy(&id, ppayload_uid, sizeof(uid_t));
 		uid = make_kuid(&init_user_ns, id);
 		if (uid_valid(uid))
 			fuid = uid;
 	} else {
-		kgid_t gid;
+		kgid_t gid, *ppayload_gid;
 		gid_t id;
-		memcpy(&id, &sidkey->payload.data[0], sizeof(gid_t));
+		/* Play nice with the pointer deref checker */
+		ppayload_gid = (kgid_t *)&sidkey->payload.data[0];
+		memcpy(&id, ppayload_gid, sizeof(gid_t));
 		gid = make_kgid(&init_user_ns, id);
 		if (gid_valid(gid))
 			fgid = gid;
diff --git a/include/asm-generic/asm-prototypes.h b/include/asm-generic/asm-prototypes.h
index 939869c772b1..7ea151802331 100644
--- a/include/asm-generic/asm-prototypes.h
+++ b/include/asm-generic/asm-prototypes.h
@@ -11,3 +11,9 @@ extern void *memset(void *, int, __kernel_size_t);
 extern void *memcpy(void *, const void *, __kernel_size_t);
 #undef memmove
 extern void *memmove(void *, const void *, __kernel_size_t);
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+#define __memcpy(t, f, l) ({ __same_pointer_depths_chk(t, f); __memcpy(t, f, l); })
+#define __memmove(t, f, l) ({ __same_pointer_depths_chk(t, f); __memmove(t, f, l); })
+#define memcpy(t, f, l) ({ __same_pointer_depths_chk(t, f); memcpy(t, f, l); })
+#define memmove(t, f, l) ({ __same_pointer_depths_chk(t, f); memmove(t, f, l); })
+#endif
diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index eca8ad75e28b..fe327bd60bdd 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -78,6 +78,27 @@ extern void __chk_io_ptr(const volatile void __iomem *);
 #include <linux/compiler-clang.h>
 #endif
 
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+/* Make pointer deref checker able to check the consistency of optimized functions
+ *
+ * This is VERY ugly and a better way would be to insert the plugin before gcc
+ * inlines calls to memcpy, but I have not yet found how to do this.
+ */
+static noinline __used void __same_pointer_depths_chk(const void *p1, const void *p2)
+{
+}
+static noinline __used void __same_pointer_depths_with_volatile1_chk(const volatile void *p1, const void *p2)
+{
+}
+static noinline __used void __same_pointer_depths_with_volatile2_chk(const void *p1, const volatile void *p2)
+{
+}
+#else
+#define __same_pointer_depths_chk(p1, p2) do { } while (0)
+#define __same_pointer_depths_with_volatile1_chk(p1, p2) do { } while (0)
+#define __same_pointer_depths_with_volatile2_chk(p1, p2) do { } while (0)
+#endif
+
 /*
  * Generic compiler-dependent macros required for kernel
  * build go below this comment. Actual compiler/compiler version
@@ -232,6 +253,7 @@ void ftrace_likely_update(struct ftrace_likely_data *f, int val,
 
 #define __READ_ONCE_SIZE						\
 ({									\
+	__same_pointer_depths_with_volatile1_chk(p, res);			\
 	switch (size) {							\
 	case 1: *(__u8 *)res = *(volatile __u8 *)p; break;		\
 	case 2: *(__u16 *)res = *(volatile __u16 *)p; break;		\
@@ -272,6 +294,7 @@ void __read_once_size_nocheck(const volatile void *p, void *res, int size)
 
 static __always_inline void __write_once_size(volatile void *p, void *res, int size)
 {
+	__same_pointer_depths_with_volatile1_chk(p, res);
 	switch (size) {
 	case 1: *(volatile __u8 *)p = *(__u8 *)res; break;
 	case 2: *(volatile __u16 *)p = *(__u16 *)res; break;
diff --git a/include/linux/string.h b/include/linux/string.h
index cea068b40d29..9e29aa1684f5 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -109,7 +109,13 @@ extern void * memmove(void *,const void *,__kernel_size_t);
 extern void * memscan(void *,int,__kernel_size_t);
 #endif
 #ifndef __HAVE_ARCH_MEMCMP
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+#undef memcmp
+#endif
 extern int memcmp(const void *,const void *,__kernel_size_t);
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+#define memcmp(s, t, l) ({ __same_pointer_depths_chk(s, t); memcmp(s, t, l); })
+#endif
 #endif
 #ifndef __HAVE_ARCH_MEMCHR
 extern void * memchr(const void *,int,__kernel_size_t);
@@ -294,6 +300,11 @@ __FORTIFY_INLINE void *memset(void *p, int c, __kernel_size_t size)
 	return __builtin_memset(p, c, size);
 }
 
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+#undef memcmp
+#undef memcpy
+#undef memmove
+#endif
 __FORTIFY_INLINE void *memcpy(void *p, const void *q, __kernel_size_t size)
 {
 	size_t p_size = __builtin_object_size(p, 0);
@@ -392,6 +403,11 @@ __FORTIFY_INLINE char *strcpy(char *p, const char *q)
 	memcpy(p, q, strlen(q) + 1);
 	return p;
 }
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+#define memcmp(s, t, l) ({ __same_pointer_depths_chk(s, t); memcmp(s, t, l); })
+#define memcpy(t, f, l) ({ __same_pointer_depths_chk(t, f); memcpy(t, f, l); })
+#define memmove(t, f, l) ({ __same_pointer_depths_chk(t, f); memmove(t, f, l); })
+#endif
 
 #endif
 
diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 24febf9e177c..bf89c3ce2362 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -1095,14 +1095,18 @@ static inline snd_pcm_sframes_t
 snd_pcm_lib_writev(struct snd_pcm_substream *substream,
 		   void __user **bufs, snd_pcm_uframes_t frames)
 {
-	return __snd_pcm_lib_xfer(substream, (void *)bufs, false, frames, false);
+	/* make the pointer checker plugin happy about using a void** in a function taking void * */
+	void *pbufs = (void __force *)bufs;
+	return __snd_pcm_lib_xfer(substream, pbufs, false, frames, false);
 }
 
 static inline snd_pcm_sframes_t
 snd_pcm_lib_readv(struct snd_pcm_substream *substream,
 		  void __user **bufs, snd_pcm_uframes_t frames)
 {
-	return __snd_pcm_lib_xfer(substream, (void *)bufs, false, frames, false);
+	/* make the pointer checker plugin happy about using a void** in a function taking void * */
+	void *pbufs = (void __force *)bufs;
+	return __snd_pcm_lib_xfer(substream, pbufs, false, frames, false);
 }
 
 static inline snd_pcm_sframes_t
@@ -1123,14 +1127,18 @@ static inline snd_pcm_sframes_t
 snd_pcm_kernel_writev(struct snd_pcm_substream *substream,
 		      void **bufs, snd_pcm_uframes_t frames)
 {
-	return __snd_pcm_lib_xfer(substream, bufs, false, frames, true);
+	/* make the pointer checker plugin happy about using a void** in a function taking void * */
+	void *pbufs = bufs;
+	return __snd_pcm_lib_xfer(substream, pbufs, false, frames, true);
 }
 
 static inline snd_pcm_sframes_t
 snd_pcm_kernel_readv(struct snd_pcm_substream *substream,
 		     void **bufs, snd_pcm_uframes_t frames)
 {
-	return __snd_pcm_lib_xfer(substream, bufs, false, frames, true);
+	/* make the pointer checker plugin happy about using a void** in a function taking void * */
+	void *pbufs = bufs;
+	return __snd_pcm_lib_xfer(substream, pbufs, false, frames, true);
 }
 
 int snd_pcm_limit_hw_rates(struct snd_pcm_runtime *runtime);
diff --git a/kernel/bpf/hashtab.c b/kernel/bpf/hashtab.c
index 4fb463172aa8..74ba07562582 100644
--- a/kernel/bpf/hashtab.c
+++ b/kernel/bpf/hashtab.c
@@ -1275,7 +1275,13 @@ int bpf_fd_htab_map_update_elem(struct bpf_map *map, struct file *map_file,
 	if (IS_ERR(ptr))
 		return PTR_ERR(ptr);
 
-	ret = htab_map_update_elem(map, key, &ptr, map_flags);
+	{
+		/* make the pointer checker plugin happy about using a void** value
+		 * (this is expected: the value is memcpy'ed into the hashtable)
+		 */
+		void *value_ptr = (void *)&ptr;
+		ret = htab_map_update_elem(map, key, value_ptr, map_flags);
+	}
 	if (ret)
 		map->ops->map_fd_put_ptr(ptr);
 
diff --git a/kernel/debug/kdb/kdb_support.c b/kernel/debug/kdb/kdb_support.c
index d35cc2d3a4cc..0b45978c2f2b 100644
--- a/kernel/debug/kdb/kdb_support.c
+++ b/kernel/debug/kdb/kdb_support.c
@@ -129,9 +129,13 @@ int kdbnearsym(unsigned long addr, kdb_symtab_t *symtab)
 		}
 		if (i >= ARRAY_SIZE(kdb_name_table)) {
 			debug_kfree(kdb_name_table[0]);
-			memcpy(kdb_name_table, kdb_name_table+1,
-			       sizeof(kdb_name_table[0]) *
-			       (ARRAY_SIZE(kdb_name_table)-1));
+			{
+				/* For pointer checker */
+				void *target = kdb_name_table;
+				memcpy(target, kdb_name_table+1,
+					   sizeof(kdb_name_table[0]) *
+					   (ARRAY_SIZE(kdb_name_table)-1));
+			}
 		} else {
 			debug_kfree(knt1);
 			knt1 = kdb_name_table[i];
diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c
index fba635bd956a..f449eb4d44a1 100644
--- a/kernel/trace/trace.c
+++ b/kernel/trace/trace.c
@@ -7085,7 +7085,12 @@ ftrace_trace_snapshot_callback(struct trace_array *tr, struct ftrace_hash *hash,
 	 * We use the callback data field (which is a pointer)
 	 * as our counter.
 	 */
-	ret = kstrtoul(number, 0, (unsigned long *)&count);
+	/* Play nice with the pointer deref checker */
+	{
+		unsigned long count_ul = -1UL;
+		ret = kstrtoul(number, 0, &count_ul);
+		count = (void *)count_ul;
+	}
 	if (ret)
 		return ret;
 
diff --git a/kernel/trace/trace_functions.c b/kernel/trace/trace_functions.c
index a0910c0cdf2e..6c06e5995aa2 100644
--- a/kernel/trace/trace_functions.c
+++ b/kernel/trace/trace_functions.c
@@ -615,7 +615,7 @@ ftrace_trace_probe_callback(struct trace_array *tr,
 			    struct ftrace_hash *hash, char *glob,
 			    char *cmd, char *param, int enable)
 {
-	void *count = (void *)-1;
+	unsigned long count = -1UL;
 	char *number;
 	int ret;
 
@@ -638,12 +638,12 @@ ftrace_trace_probe_callback(struct trace_array *tr,
 	 * We use the callback data field (which is a pointer)
 	 * as our counter.
 	 */
-	ret = kstrtoul(number, 0, (unsigned long *)&count);
+	ret = kstrtoul(number, 0, &count);
 	if (ret)
 		return ret;
 
  out_reg:
-	ret = register_ftrace_function_probe(glob, tr, ops, count);
+	ret = register_ftrace_function_probe(glob, tr, ops, (void *)count);
 
 	return ret < 0 ? ret : 0;
 }
diff --git a/kernel/trace/trace_kprobe.c b/kernel/trace/trace_kprobe.c
index c9b5aa10fbf9..1fb1fa1071ab 100644
--- a/kernel/trace/trace_kprobe.c
+++ b/kernel/trace/trace_kprobe.c
@@ -718,19 +718,25 @@ static int create_trace_kprobe(int argc, char **argv)
 
 	/* try to parse an address. if that fails, try to read the
 	 * input as a symbol. */
-	if (kstrtoul(argv[1], 0, (unsigned long *)&addr)) {
-		/* a symbol specified */
-		symbol = argv[1];
-		/* TODO: support .init module functions */
-		ret = traceprobe_split_symbol_offset(symbol, &offset);
-		if (ret) {
-			pr_info("Failed to parse either an address or a symbol.\n");
-			return ret;
-		}
-		if (offset && is_return &&
-		    !kprobe_on_func_entry(NULL, symbol, offset)) {
-			pr_info("Given offset is not valid for return probe.\n");
-			return -EINVAL;
+	{
+		/* Play nice with the pointer deref checker */
+		unsigned long addr_ul = 0;
+		if (kstrtoul(argv[1], 0, &addr_ul)) {
+			/* a symbol specified */
+			symbol = argv[1];
+			/* TODO: support .init module functions */
+			ret = traceprobe_split_symbol_offset(symbol, &offset);
+			if (ret) {
+				pr_info("Failed to parse either an address or a symbol.\n");
+				return ret;
+			}
+			if (offset && is_return &&
+				!kprobe_on_func_entry(NULL, symbol, offset)) {
+				pr_info("Given offset is not valid for return probe.\n");
+				return -EINVAL;
+			}
+		} else {
+			addr = (void *)addr_ul;
 		}
 	}
 	argc -= 2; argv += 2;
diff --git a/kernel/workqueue.c b/kernel/workqueue.c
index d24b9fba8e7f..13672fd9aa8a 100644
--- a/kernel/workqueue.c
+++ b/kernel/workqueue.c
@@ -4265,7 +4265,7 @@ void set_worker_desc(const char *fmt, ...)
  */
 void print_worker_info(const char *log_lvl, struct task_struct *task)
 {
-	work_func_t *fn = NULL;
+	work_func_t fn = NULL;
 	char name[WQ_NAME_LEN] = { };
 	char desc[WORKER_DESC_LEN] = { };
 	struct pool_workqueue *pwq = NULL;
diff --git a/mm/percpu-vm.c b/mm/percpu-vm.c
index 15dab691ea70..4f5aaab273f6 100644
--- a/mm/percpu-vm.c
+++ b/mm/percpu-vm.c
@@ -358,8 +358,11 @@ static void pcpu_destroy_chunk(struct pcpu_chunk *chunk)
 	pcpu_stats_chunk_dealloc();
 	trace_percpu_destroy_chunk(chunk->base_addr);
 
-	if (chunk->data)
-		pcpu_free_vm_areas(chunk->data, pcpu_nr_groups);
+	if (chunk->data) {
+		/* Play nice with the pointer deref checker */
+		struct vm_struct **vms = (struct vm_struct **)(chunk->data);
+		pcpu_free_vm_areas(vms, pcpu_nr_groups);
+	}
 	pcpu_free_chunk(chunk);
 }
 
diff --git a/mm/slub.c b/mm/slub.c
index 2094271fa8c4..c3a71e02798f 100644
--- a/mm/slub.c
+++ b/mm/slub.c
@@ -250,12 +250,14 @@ static void prefetch_freepointer(const struct kmem_cache *s, void *object)
 
 static inline void *get_freepointer_safe(struct kmem_cache *s, void *object)
 {
-	void *p;
+	void *p, **addr;
 
 	if (!debug_pagealloc_enabled())
 		return get_freepointer(s, object);
 
-	probe_kernel_read(&p, (void **)(object + s->offset), sizeof(p));
+	/* Play nice with the pointer deref checker */
+	addr = (void **)(object + s->offset);
+	probe_kernel_read(&p, addr, sizeof(p));
 	return p;
 }
 
diff --git a/net/core/drop_monitor.c b/net/core/drop_monitor.c
index 70ccda233bd1..998f7ce700f8 100644
--- a/net/core/drop_monitor.c
+++ b/net/core/drop_monitor.c
@@ -173,7 +173,9 @@ static void trace_drop_common(struct sk_buff *skb, void *location)
 	nla = genlmsg_data(nlmsg_data(nlh));
 	msg = nla_data(nla);
 	for (i = 0; i < msg->entries; i++) {
-		if (!memcmp(&location, msg->points[i].pc, sizeof(void *))) {
+		/* Play nice with the pointer deref checker */
+		void **msg_points_pc = (void **)(msg->points[i].pc);
+		if (!memcmp(&location, msg_points_pc, sizeof(void *))) {
 			msg->points[i].count++;
 			goto out;
 		}
@@ -185,7 +187,11 @@ static void trace_drop_common(struct sk_buff *skb, void *location)
 	 */
 	__nla_reserve_nohdr(dskb, sizeof(struct net_dm_drop_point));
 	nla->nla_len += NLA_ALIGN(sizeof(struct net_dm_drop_point));
-	memcpy(msg->points[msg->entries].pc, &location, sizeof(void *));
+	{
+		/* Play nice with the pointer deref checker */
+		void **msg_points_pc = (void **)(msg->points[msg->entries].pc);
+		memcpy(msg_points_pc, &location, sizeof(void *));
+	}
 	msg->points[msg->entries].count = 1;
 	msg->entries++;
 
diff --git a/net/ipv4/netfilter/nf_nat_snmp_basic.c b/net/ipv4/netfilter/nf_nat_snmp_basic.c
index d5b1e0b3f687..904f8736e2f5 100644
--- a/net/ipv4/netfilter/nf_nat_snmp_basic.c
+++ b/net/ipv4/netfilter/nf_nat_snmp_basic.c
@@ -944,8 +944,12 @@ snmp_trap_decode(struct asn1_ctx *ctx, struct snmp_v1_trap *trap,
 	      (cls == ASN1_UNI && con == ASN1_PRI && tag == ASN1_OTS)))
 		goto err_id_free;
 
-	if (!asn1_octets_decode(ctx, end, (unsigned char **)&trap->ip_address, &len))
-		goto err_id_free;
+	{
+		/* Play nice with the pointer deref checker */
+		unsigned char **ipaddr_buf = (unsigned char **)&trap->ip_address;
+		if (!asn1_octets_decode(ctx, end, ipaddr_buf, &len))
+			goto err_id_free;
+	}
 
 	/* IPv4 only */
 	if (len != 4)
diff --git a/net/phonet/socket.c b/net/phonet/socket.c
index 1b050dd17393..d2435d0e2e1d 100644
--- a/net/phonet/socket.c
+++ b/net/phonet/socket.c
@@ -774,8 +774,11 @@ static void *pn_res_seq_next(struct seq_file *seq, void *v, loff_t *pos)
 
 	if (v == SEQ_START_TOKEN)
 		sk = pn_res_get_idx(seq, 0);
-	else
-		sk = pn_res_get_next(seq, v);
+	else {
+		/* Play nice with the pointer deref checker */
+		struct sock **sk_v = (struct sock **)v;
+		sk = pn_res_get_next(seq, sk_v);
+	}
 	(*pos)++;
 	return sk;
 }
diff --git a/net/rxrpc/key.c b/net/rxrpc/key.c
index 54369225766e..e3eaf267ea12 100644
--- a/net/rxrpc/key.c
+++ b/net/rxrpc/key.c
@@ -837,7 +837,7 @@ static int rxrpc_preparse_s(struct key_preparsed_payload *prep)
 	if (prep->datalen != 8)
 		return -EINVAL;
 
-	memcpy(&prep->payload.data[2], prep->data, 8);
+	memcpy_with_cast(&prep->payload.data[2], prep->data, 8); /* I did not understand this */
 
 	ci = crypto_alloc_skcipher("pcbc(des)", 0, CRYPTO_ALG_ASYNC);
 	if (IS_ERR(ci)) {
diff --git a/net/rxrpc/rxkad.c b/net/rxrpc/rxkad.c
index 974eaed45508..d7ba26e299a4 100644
--- a/net/rxrpc/rxkad.c
+++ b/net/rxrpc/rxkad.c
@@ -889,7 +889,7 @@ static int rxkad_decrypt_ticket(struct rxrpc_connection *conn,
 	ASSERT(conn->server_key->payload.data[0] != NULL);
 	ASSERTCMP((unsigned long) ticket & 7UL, ==, 0);
 
-	memcpy(&iv, &conn->server_key->payload.data[2], sizeof(iv));
+	memcpy_with_cast(&iv, &conn->server_key->payload.data[2], sizeof(iv)); /* I did not understand this */
 
 	ret = -ENOMEM;
 	req = skcipher_request_alloc(conn->server_key->payload.data[0],
diff --git a/scripts/Makefile.gcc-plugins b/scripts/Makefile.gcc-plugins
index 1f7ade35c129..85c238b34231 100644
--- a/scripts/Makefile.gcc-plugins
+++ b/scripts/Makefile.gcc-plugins
@@ -17,6 +17,8 @@ ifdef CONFIG_GCC_PLUGINS
     DISABLE_PRINTK_FORMAT_PLUGIN			+= -fplugin-arg-printk_format_plugin-disable
   endif
 
+  gcc-plugin-$(CONFIG_GCC_PLUGIN_DEREF_CHECKER) += deref_checker_plugin.so
+
   ifdef CONFIG_GCC_PLUGIN_SANCOV
     ifeq ($(CFLAGS_KCOV),)
       # It is needed because of the gcc-plugin.sh and gcc version checks.
diff --git a/scripts/gcc-plugins/deref_checker_plugin.c b/scripts/gcc-plugins/deref_checker_plugin.c
new file mode 100644
index 000000000000..e3484b60ce77
--- /dev/null
+++ b/scripts/gcc-plugins/deref_checker_plugin.c
@@ -0,0 +1,408 @@
+/*
+ * Copyright 2016-2017 by Nicolas Iooss
+ * Licensed under the GPL v2, or (at your option) v3
+ *
+ * Check that pointer dereferencing is used consistently across function calls
+ */
+
+#include "gcc-common.h"
+
+int plugin_is_GPL_compatible;
+
+static struct plugin_info deref_checker_plugin_info = {
+	.version	= "20170708",
+	.help		= "Pointer dereferencing checker\n",
+};
+
+/**
+ * Identifier match helpers
+ */
+static bool identifier_is(const_tree identifier, const char *str)
+{
+	size_t len = strlen(str);
+
+	if (!identifier)
+		return false;
+
+	return IDENTIFIER_LENGTH(identifier) == len && !strncmp(str, IDENTIFIER_POINTER(identifier), len);
+}
+
+/**
+ * Get the number of pointers to a relevant data an expression holds
+ */
+static unsigned int get_pointer_depth(const_tree tree)
+{
+	unsigned int recursive_depth;
+
+	switch (TREE_CODE(tree)) {
+	case POINTER_TYPE:
+		recursive_depth = 1 + get_pointer_depth(TREE_TYPE(tree));
+		/* Remove 1 if the sub-type is an array because it is the way
+		 * vector dereferencing is stored.
+		 */
+		if (TREE_CODE(TREE_TYPE(tree)) == ARRAY_TYPE)
+			recursive_depth -= 1;
+		return recursive_depth;
+
+	case ARRAY_TYPE:
+		/* Unfold arrays so that char[6][7] counts as char[42] */
+		tree = TREE_TYPE(tree);
+		while (TREE_CODE(tree) == ARRAY_TYPE)
+			tree = TREE_TYPE(tree);
+		return 1 + get_pointer_depth(tree);
+
+	case VECTOR_TYPE:
+		return 1 + get_pointer_depth(TREE_TYPE(tree));
+
+	case BOOLEAN_TYPE:
+	case ENUMERAL_TYPE:
+	case FUNCTION_TYPE:
+	case INTEGER_TYPE:
+	case QUAL_UNION_TYPE:
+	case RECORD_TYPE:
+	case REAL_TYPE:
+	case UNION_TYPE:
+	case VOID_TYPE:
+		return 0;
+
+	case REFERENCE_TYPE:
+		/* for __va_list on ARM */
+		if (TREE_CODE(TREE_TYPE(tree)) == RECORD_TYPE && identifier_is(TYPE_IDENTIFIER(TREE_TYPE(tree)), "__va_list"))
+			return 1;
+		/* for __va_list on i686 */
+		if (TREE_CODE(TREE_TYPE(tree)) == POINTER_TYPE && identifier_is(TYPE_IDENTIFIER(TREE_TYPE(tree)), "__builtin_va_list"))
+			return 1;
+	}
+
+	debug_tree(tree); /* TODO: better error reporting */
+	error(G_("unknown type for deref checker plugin!"));
+	return 0;
+}
+
+/**
+ * Whitelist some functions for the pointer checker
+ * TODO: function attribute?
+ */
+static bool is_whitelisted(const_tree fndecl, unsigned int argidx,
+			   unsigned int ptrdepth_type,  unsigned int ptrdepth_value)
+{
+	const_tree fnident = DECL_NAME(fndecl);
+
+	/* TODO: add a check for not void* in type, so that there are real bugs which appear (or just cast errors?) */
+
+	/* Many functions have their first argument a void* pointer */
+	if (identifier_is(fnident, "__builtin_memset") ||
+	    identifier_is(fnident, "__builtin_prefetch") ||
+	    identifier_is(fnident, "__raw_readl") ||
+	    identifier_is(fnident, "__read_once_size") ||
+	    identifier_is(fnident, "__sync_cache_range_w") ||
+	    identifier_is(fnident, "__write_once_size") ||
+	    identifier_is(fnident, "ERR_CAST") ||
+	    identifier_is(fnident, "IS_ERR") ||
+	    identifier_is(fnident, "IS_ERR_OR_NULL") ||
+	    identifier_is(fnident, "PTR_ERR") ||
+	    identifier_is(fnident, "acpi_os_free") ||
+	    identifier_is(fnident, "bit_waitqueue") ||
+	    identifier_is(fnident, "bm_vk_free") ||
+	    identifier_is(fnident, "cfs_percpt_free") ||
+	    identifier_is(fnident, "cfs_percpt_number") ||
+	    identifier_is(fnident, "choke_free") ||
+	    identifier_is(fnident, "clocksource_mmio_init") ||
+	    identifier_is(fnident, "devres_free") ||
+	    identifier_is(fnident, "drm_free_large") ||
+	    identifier_is(fnident, "is_vmalloc_addr") ||
+	    identifier_is(fnident, "jhash") ||
+	    identifier_is(fnident, "free_percpu") ||
+	    identifier_is(fnident, "kfree") ||
+	    identifier_is(fnident, "kmemdup") ||
+	    identifier_is(fnident, "kmemleak_alloc") ||
+	    identifier_is(fnident, "kmemleak_free") ||
+	    identifier_is(fnident, "kmem_free") ||
+	    identifier_is(fnident, "krealloc") ||
+	    identifier_is(fnident, "kvfree") ||
+	    identifier_is(fnident, "kzfree") ||
+	    identifier_is(fnident, "memset") ||
+	    identifier_is(fnident, "memdup_user") ||
+	    identifier_is(fnident, "mempool_free") ||
+	    identifier_is(fnident, "prefetch") ||
+	    identifier_is(fnident, "scif_free") ||
+	    identifier_is(fnident, "sort") ||
+	    identifier_is(fnident, "t4_free_mem") ||
+	    identifier_is(fnident, "vfree") ||
+	    identifier_is(fnident, "wake_up_bit") ||
+	    false)
+		return argidx == 1 && ptrdepth_type < ptrdepth_value;
+
+	if (identifier_is(fnident, "__kfifo_in_r") || /* kfifo can be used to transmit pointers */
+	    identifier_is(fnident, "__kfifo_in") ||
+	    identifier_is(fnident, "__kfifo_init") ||
+	    identifier_is(fnident, "__kfifo_out") ||
+	    identifier_is(fnident, "__raw_writel") ||
+	    identifier_is(fnident, "constant_test_bit") || /* even though there is a cast to unsigned long*, using &private_data (which is void**) is being reported */
+	    identifier_is(fnident, "_clear_bit") ||
+	    identifier_is(fnident, "clear_bit") ||
+	    identifier_is(fnident, "_set_bit") ||
+	    identifier_is(fnident, "set_bit") ||
+	    identifier_is(fnident, "test_bit") ||
+	    identifier_is(fnident, "free_percpu_irq") ||
+
+	    identifier_is(fnident, "device_for_each_child") || /* data for the callback */
+	    identifier_is(fnident, "device_for_each_child_reverse") || /* data for the callback */
+	    identifier_is(fnident, "devm_kfree") ||
+	    identifier_is(fnident, "devm_kmemdup") ||
+	    identifier_is(fnident, "devres_add") || /* resource registered to the device */
+	    identifier_is(fnident, "device_find_child") || /* data for the callback */
+
+	    identifier_is(fnident, "dup_param") ||
+	    identifier_is(fnident, "free_param") ||
+	    false)
+		return argidx == 2 && ptrdepth_type < ptrdepth_value;
+
+	if (identifier_is(fnident, "get_disp_fb") ||
+	    identifier_is(fnident, "get_free_fb"))
+		return argidx == 2 && ptrdepth_value == 1;
+
+	if (identifier_is(fnident, "blkdev_get") || /* Third arg "holder" is a pointer to a stack variable */
+	    identifier_is(fnident, "driver_for_each_device") ||
+	    identifier_is(fnident, "drm_for_each_detailed_block") ||
+	    identifier_is(fnident, "flex_array_put") ||
+	    identifier_is(fnident, "hashtab_map") || /* args */
+	    identifier_is(fnident, "idr_for_each") ||
+	    identifier_is(fnident, "of_clk_add_provider") ||
+	    identifier_is(fnident, "pci_for_each_dma_alias") || /* private data */
+	    identifier_is(fnident, "single_open") ||
+	    identifier_is(fnident, "snd_seq_dump_var_event") || /* private_data */
+	    identifier_is(fnident, "twsk_unique") ||
+	    identifier_is(fnident, "devm_free_irq") ||
+	    identifier_is(fnident, "vdec_if_get_param") ||
+	    false)
+		return argidx == 3 && ptrdepth_type < ptrdepth_value;
+
+	if (identifier_is(fnident, "debugfs_create_file") || /* Private data */
+	    identifier_is(fnident, "devres_release") || /* match_data */
+	    identifier_is(fnident, "request_percpu_irq") ||
+	    identifier_is(fnident, "err_print_param") ||
+	    identifier_is(fnident, "seq_print_param") ||
+	    false)
+		return argidx == 4 && ptrdepth_type < ptrdepth_value;
+
+	if (identifier_is(fnident, "vdec_h264_get_fb"))
+		return argidx == 4 && ptrdepth_value == 1;
+
+	if (identifier_is(fnident, "_get_res") && argidx == 5 && ptrdepth_value == 2)
+		return true;
+
+	if (identifier_is(fnident, "param_free_charp") && argidx == 1 && ptrdepth_value == 2) /* This function waits for a char** but needs to have the prototype of free() */
+		return true;
+
+	if (identifier_is(fnident, "fetch_robust_entry") || /* compat_uptr_t __user * depth is 2 */
+	    identifier_is(fnident, "netdev_walk_all_lower_dev") ||
+	    identifier_is(fnident, "netdev_walk_all_lower_dev_rcu"))
+		return argidx == 3 && ptrdepth_value == 2;
+
+	/* lib/radix-tree.c does strange things */
+	if (identifier_is(fnident, "delete_sibling_entries") ||
+	    identifier_is(fnident, "node_to_entry") ||
+	    identifier_is(fnident, "radix_tree_is_internal_node"))
+		return argidx == 1 && ptrdepth_type < ptrdepth_value;
+
+/* automatic processing, TODO: review! */
+	if ((identifier_is(fnident, "__be64_to_cpup") && argidx == 1 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "__cq_dequeue") && argidx == 2 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "__install_special_mapping") && argidx == 5 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "__ocfs2_find_path") && argidx == 5 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "__test_and_clear_bit") && argidx == 2 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "__test_and_set_bit") && argidx == 2 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "__uvcg_iter_frm_intrv") && argidx == 4 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "__uvcg_iter_strm_cls") && argidx == 2 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "acpi_bus_get_device") && argidx == 1 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "acpi_get_physical_device_location") && argidx == 1 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "acpi_node_prop_read") && argidx == 4 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "acpi_rs_out_string") && argidx == 2 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "acpi_ut_trace_ptr") && argidx == 5 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "acpi_walk_namespace") && argidx == 6 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "acpi_walk_resources") && argidx == 4 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "alloc_ring") && argidx == 6 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "alloc_usemap_and_memmap") && argidx == 2 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "ath10k_wmi_tlv_iter") && argidx == 5 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "cfs_array_free") && argidx == 1 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "csio_enqueue_evt") && argidx == 3 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "cxgbi_free_big_mem") && argidx == 1 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "deactivate_slab") && argidx == 3 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "devm_request_irq") && argidx == 6 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "free_irq") && argidx == 2 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "gigaset_add_event") && argidx == 4 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "hlist_add_head") && argidx == 2 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "i2400m_zrealloc_2x") && argidx == 1 && ptrdepth_value == 3) ||
+	    (identifier_is(fnident, "ieee80211_iter_chan_contexts_atomic") && argidx == 3 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "iommu_group_for_each_dev") && argidx == 2 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "lbs_deb_hex") && argidx == 3 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "lustre_cfg_bufs_set") && argidx == 3 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "mgmt_pending_foreach") && argidx == 4 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "platform_device_add_data") && argidx == 2 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "platform_set_drvdata") && argidx == 2 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "pool_proc_next") && argidx == 2 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "rbd_img_request_fill") && argidx == 3 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "request_irq") && argidx == 5 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "set_freepointer") && argidx == 3 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "snd_pcm_hw_rule_add") && argidx == 5 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "trace_ocfs2_read_virt_blocks") && argidx == 4 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "ulist_add_merge") && argidx == 4 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "usb_acpi_get_connect_type") && argidx == 1 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "usb_control_msg") && argidx == 7 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "xenbus_grant_ring") && argidx == 2 && ptrdepth_value == 2) ||
+
+	    (identifier_is(fnident, "acpi_walk_namespace") && argidx == 7 && ptrdepth_value == 1) ||
+	    (identifier_is(fnident, "is_sibling_entry") && argidx == 2 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "entry_to_node") && argidx == 1 && ptrdepth_value == 2) ||
+	    false)
+		return true;
+
+	if (identifier_is(fnident, "__uvcg_iter_strm_cls"))
+		return argidx == 2 || argidx == 3; /* priv2 and priv3 */
+
+	if (identifier_is(fnident, "memcpy_with_cast"))
+		return argidx == 1 || argidx == 2;
+	if (identifier_is(fnident, "__xchg") ||
+	    identifier_is(fnident, "__cmpxchg"))
+		return argidx == 1 || argidx == 2;
+
+	if (identifier_is(fnident, "__builtin___ubsan_handle_divrem_overflow") ||
+	    identifier_is(fnident, "__builtin___ubsan_handle_shift_out_of_bounds"))
+		return ptrdepth_value == 0 && (argidx == 2 || argidx == 3); /* UBSAN built-in functions */
+	if (identifier_is(fnident, "__builtin___ubsan_handle_vla_bound_not_positive"))
+		return ptrdepth_value == 0 && argidx == 2; /* UBSAN built-in functions */
+
+	return false;
+}
+
+static unsigned int deref_checker_execute(void)
+{
+	basic_block bb;
+
+	FOR_EACH_BB_FN(bb, cfun) {
+		gimple_stmt_iterator gsi;
+
+		for (gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi)) {
+			gimple stmt;
+			gcall *call_stmt;
+			const_tree fndecl, arg_type;
+			unsigned int argidx;
+			function_args_iterator arg_iter;
+			bool expect_next_depth = false;
+			unsigned int expected_ptrdepth_type, expected_ptrdepth_value;
+
+			/* Get the statement */
+			stmt = gsi_stmt(gsi);
+			if (!is_gimple_call(stmt))
+				continue;
+			call_stmt = as_a_gcall(stmt);
+			/*debug_gimple_stmt(stmt);*/
+			//debug_tree(gimple_call_fn(stmt));
+
+			/* Get the function declaration */
+			fndecl = gimple_call_fndecl(stmt);
+			if (fndecl == NULL_TREE)
+				continue;
+
+			argidx = 1;
+			FOREACH_FUNCTION_ARGS(TREE_TYPE(fndecl), arg_type, arg_iter) {
+				const_tree arg_tree;
+				unsigned int ptrdepth_type, ptrdepth_value;
+
+				if (TREE_CODE(arg_type) == VOID_TYPE) {
+					/* End of function arguments */
+					if (argidx != 1 + gimple_call_num_args(call_stmt)) {
+						error(G_("Call to %qF with too many parameters"), fndecl);
+						break;
+					}
+					argidx++;
+					continue; /* the loop should exit by itself. Otherwise the error is catched later */
+				}
+
+				/* This should not happen */
+				if (argidx > gimple_call_num_args(call_stmt)) {
+					error(G_("Call to %qF with not enough parameters"), fndecl);
+					break;
+				}
+
+				ptrdepth_type = get_pointer_depth(arg_type);
+
+				arg_tree = gimple_call_arg(call_stmt, argidx - 1);
+				ptrdepth_value = get_pointer_depth(TREE_TYPE(arg_tree));
+
+				/* memcpy and memcmp are special as two pointers of the same depth may be used */
+				if (expect_next_depth) {
+					expect_next_depth = false;
+					/* This should not happen: memcmp has a known prototype */
+					if (ptrdepth_type != expected_ptrdepth_type) {
+						warning_at(
+							gimple_location(stmt), 0,
+							G_("Internal error while analyzing a call to %qF\n"),
+							fndecl);
+					}
+					if (ptrdepth_value != expected_ptrdepth_value) {
+/* debug_tree(arg_tree); */
+						warning_at(
+							gimple_location(stmt), 0,
+							G_("Invalid pointer depth in function call %qF: value of arg %u is %u, not expected %u\n"),
+							fndecl, argidx, ptrdepth_value, expected_ptrdepth_value);
+					}
+				} else if (argidx == 1 && (
+				    identifier_is(DECL_NAME(fndecl), "__builtin_memcmp") ||
+				    identifier_is(DECL_NAME(fndecl), "__builtin_memcpy") ||
+				    identifier_is(DECL_NAME(fndecl), "__memcpy") ||
+				    identifier_is(DECL_NAME(fndecl), "__same_pointer_depths_chk") ||
+				    identifier_is(DECL_NAME(fndecl), "__same_pointers_depths_with_volatile1_chk") ||
+				    identifier_is(DECL_NAME(fndecl), "__same_pointers_depths_with_volatile2_chk") ||
+				    identifier_is(DECL_NAME(fndecl), "copy_from_user") ||
+				    identifier_is(DECL_NAME(fndecl), "copy_to_user") ||
+				    identifier_is(DECL_NAME(fndecl), "memcmp") ||
+				    identifier_is(DECL_NAME(fndecl), "memcpy") ||
+				    identifier_is(DECL_NAME(fndecl), "memcpy_fromio") ||
+				    identifier_is(DECL_NAME(fndecl), "memcpy_toio") ||
+				    identifier_is(DECL_NAME(fndecl), "memmove") ||
+				    identifier_is(DECL_NAME(fndecl), "probe_kernel_read"))) {
+					expect_next_depth = true;
+					expected_ptrdepth_type = ptrdepth_type;
+					expected_ptrdepth_value = ptrdepth_value;
+				} else if (ptrdepth_type != ptrdepth_value && !is_whitelisted(fndecl, argidx, ptrdepth_type, ptrdepth_value)) {
+					warning_at(
+						gimple_location(stmt), 0,
+						G_("Invalid pointer depth in function call %qF: type of argument %u says %u but value is %u\n"),
+						fndecl, argidx, ptrdepth_type, ptrdepth_value);
+				}
+
+				argidx++;
+			}
+		}
+	}
+
+	return 0;
+}
+
+#define PASS_NAME deref_checker
+
+#define NO_GATE
+#define TODO_FLAGS_FINISH TODO_dump_func
+
+#include "gcc-generate-gimple-pass.h"
+
+int plugin_init(struct plugin_name_args *plugin_info, struct plugin_gcc_version *version)
+{
+	const char * const plugin_name = plugin_info->base_name;
+
+	PASS_INFO(deref_checker, "ssa", 1, PASS_POS_INSERT_AFTER);
+
+	if (!plugin_default_version_check(version, &gcc_version)) {
+		error(G_("incompatible gcc/plugin versions"));
+		return 1;
+	}
+
+	register_callback(plugin_name, PLUGIN_INFO, NULL,
+				&deref_checker_plugin_info);
+	register_callback(plugin_name, PLUGIN_PASS_MANAGER_SETUP, NULL,
+				&deref_checker_pass_info);
+
+	return 0;
+}
diff --git a/security/apparmor/apparmorfs.c b/security/apparmor/apparmorfs.c
index 853c2ec8e0c9..1d190055237f 100644
--- a/security/apparmor/apparmorfs.c
+++ b/security/apparmor/apparmorfs.c
@@ -698,8 +698,15 @@ static ssize_t query_data(char *buf, size_t buf_len,
 		if (!profile->data)
 			continue;
 
-		data = rhashtable_lookup_fast(profile->data, &key,
-					      profile->data->p);
+		{
+			/* Play nice with the pointer deref checker:
+			 * The hashtable key is a char** because strhash() used it and param.keylen = sizeof(void*)
+			 * So this usage is valid.
+			 */
+			const void *vkey = &key;
+			data = rhashtable_lookup_fast(profile->data, vkey,
+							  profile->data->p);
+		}
 
 		if (data) {
 			if (out + sizeof(outle32) + data->size > buf +
diff --git a/sound/core/pcm_native.c b/sound/core/pcm_native.c
index 22995cb3bd44..94df2564eeef 100644
--- a/sound/core/pcm_native.c
+++ b/sound/core/pcm_native.c
@@ -2971,7 +2971,7 @@ static int snd_pcm_capture_ioctl1(struct file *file,
 		struct snd_xfern xfern;
 		struct snd_xfern __user *_xfern = arg;
 		struct snd_pcm_runtime *runtime = substream->runtime;
-		void *bufs;
+		void __user **bufs;
 		snd_pcm_sframes_t result;
 		if (runtime->status->state == SNDRV_PCM_STATE_OPEN)
 			return -EBADFD;
-- 
