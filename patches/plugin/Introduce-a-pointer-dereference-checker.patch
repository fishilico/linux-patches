From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Nicolas Iooss <nicolas.iooss_linux@m4x.org>
Date: Sat, 8 Oct 2016 14:45:13 +0200
Subject: [PATCH] {PLUGIN} Introduce a pointer dereference checker

This first version is a PoC draft which is not meant to go upstream.
This plugin addresses to problems which ought to be split in two
plugins: consistent calls to memcpy()-like functions (with two pointers
which would have the same "depth" but are void*), and bad use of & on a
pointer in a function taking void*. This second case leads to waaaay too
many false positives to be viable in the long run.

The main reason why with plugin is dirty is that it introduces a call to
__same_pointer_depths_chk() empty function at each memcpy/memove call,
so that even compiler-optimized code can be analyzed. A better approach
would be to attach the plugin to a pass where memcpy() calls have not
yet been optimized away. How is this done?

This plugins helped to detect the following bugs:
- 61ab0d403bbd ("ASoC: Intel: Atom: add a missing star in a memcpy
  call")
- ae6c33ba6e37 ("printk: fix parsing of "brl=" option")
- 238b323a681d ("libnvdimm, namespace: fix the type of name variable")

It has also detected some bugs reported and fixed by other people:
- 91c42b72f8e8 ("i40iw: Use correct src address in memcpy to rdma stats
  counters")
- eec11535ca3d ("hfs: fix hfs_readdir()")
- 7deea450eb91 ("bnxt_en: Fix population of flow_type in
  bnxt_hwrm_cfa_flow_alloc()")
---
 arch/arm/boot/compressed/decompress.c         |   2 +
 arch/arm/boot/compressed/string.c             |   7 +
 arch/arm/include/asm/string.h                 |  18 +
 arch/arm/mm/kasan_init.c                      |  10 +-
 arch/arm/mm/mmu.c                             |   2 +-
 arch/x86/boot/compressed/misc.c               |   4 +
 arch/x86/boot/compressed/string.c             |   5 +
 arch/x86/boot/string.h                        |   4 +
 arch/x86/include/asm/string_32.h              |  19 +-
 arch/x86/include/asm/string_64.h              |  17 +
 arch/x86/kvm/hyperv.c                         |  11 +-
 arch/x86/lib/memcpy_32.c                      |   3 +
 arch/x86/math-emu/fpu_entry.c                 |   7 +-
 arch/x86/xen/enlighten_pv.c                   |   8 +-
 drivers/acpi/acpica/dspkginit.c               |   5 +-
 drivers/acpi/property.c                       |  10 +-
 drivers/base/swnode.c                         |   7 +-
 drivers/dma/ti/cppi41.c                       |   4 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c        |   2 +-
 drivers/gpu/drm/drm_bufs.c                    |   4 +-
 drivers/gpu/drm/i915/i915_debugfs_params.c    |   7 +-
 drivers/gpu/drm/radeon/radeon_cs.c            |   2 +-
 drivers/media/pci/intel/ipu3/ipu3-cio2-main.c |   8 +-
 drivers/media/platform/omap3isp/ispstat.c     |   8 +-
 drivers/misc/ibmasm/lowlevel.c                |   4 +-
 drivers/net/ethernet/ti/davinci_cpdma.c       |   2 +-
 drivers/net/virtio_net.c                      |   2 +-
 drivers/net/wireless/ti/wlcore/main.c         |  15 +-
 drivers/scsi/csiostor/csio_hw.c               |   6 +-
 drivers/scsi/pm8001/pm8001_ctl.c              |   4 +-
 drivers/scsi/pm8001/pm8001_hwi.c              |   2 +-
 drivers/staging/gdm724x/hci_packet.h          |   2 +-
 .../staging/rtl8192e/rtl8192e/r8192E_cmdpkt.c |   2 +-
 drivers/staging/rtl8192e/rtl8192e/rtl_core.c  |   4 +-
 drivers/staging/rtl8192u/r8192U_core.c        |   2 +-
 drivers/staging/rtl8192u/r819xU_cmdpkt.c      |   2 +-
 drivers/staging/rtl8192u/r819xU_firmware.c    |   2 +-
 .../interface/vchiq_arm/vchiq_ioctl.h         |   2 +-
 .../intel/int340x_thermal/int3402_thermal.c   |   2 +-
 drivers/usb/core/devio.c                      |  12 +-
 drivers/usb/dwc2/hcd.c                        |  22 +-
 drivers/usb/host/xhci-debugfs.c               |   4 +-
 drivers/vhost/scsi.c                          |   6 +-
 drivers/xen/xenbus/xenbus_xs.c                |   4 +-
 fs/cifs/cifsacl.c                             |  12 +-
 fs/debugfs/file.c                             |   4 +-
 fs/ocfs2/aops.h                               |  14 +-
 fs/proc/proc_sysctl.c                         |   8 +-
 include/asm-generic/asm-prototypes.h          |   6 +
 include/linux/bitops.h                        |  12 +-
 include/linux/compiler.h                      |  21 +
 include/linux/string.h                        |  18 +
 include/sound/pcm.h                           |  16 +-
 include/trace/bpf_probe.h                     |   2 +-
 kernel/bpf/arraymap.c                         |   4 +-
 kernel/bpf/hashtab.c                          |   8 +-
 kernel/futex/core.c                           |   8 +-
 kernel/livepatch/core.c                       |   4 +-
 kernel/livepatch/transition.c                 |   9 +-
 kernel/trace/pid_list.c                       |   4 +-
 kernel/trace/trace.c                          |   7 +-
 kernel/trace/trace_functions.c                |   6 +-
 kernel/trace/trace_kprobe.c                   |  78 +--
 kernel/workqueue.c                            |   2 +-
 mm/hugetlb.c                                  |   8 +-
 mm/memcontrol.c                               |   2 +-
 mm/percpu-vm.c                                |   7 +-
 mm/slub.c                                     |   6 +-
 net/core/drop_monitor.c                       |  10 +-
 net/core/sock_map.c                           |   4 +-
 net/phonet/socket.c                           |   7 +-
 net/rxrpc/rxkad.c                             |  16 +-
 scripts/Makefile.gcc-plugins                  |   2 +
 scripts/gcc-plugins/Kconfig                   |   6 +
 scripts/gcc-plugins/deref_checker_plugin.c    | 487 ++++++++++++++++++
 security/apparmor/apparmorfs.c                |  11 +-
 sound/core/pcm_native.c                       |   2 +-
 77 files changed, 939 insertions(+), 147 deletions(-)
 create mode 100644 scripts/gcc-plugins/deref_checker_plugin.c

diff --git a/arch/arm/boot/compressed/decompress.c b/arch/arm/boot/compressed/decompress.c
index 74255e819831..caf6316098a1 100644
--- a/arch/arm/boot/compressed/decompress.c
+++ b/arch/arm/boot/compressed/decompress.c
@@ -47,11 +47,13 @@ extern char * strchrnul(const char *, int);
 #endif
 
 #ifdef CONFIG_KERNEL_XZ
+#ifndef CONFIG_GCC_PLUGIN_DEREF_CHECKER
 /* Prevent KASAN override of string helpers in decompressor */
 #undef memmove
 #define memmove memmove
 #undef memcpy
 #define memcpy memcpy
+#endif
 #include "../../../../lib/decompress_unxz.c"
 #endif
 
diff --git a/arch/arm/boot/compressed/string.c b/arch/arm/boot/compressed/string.c
index fcc678fce045..686950d6daa7 100644
--- a/arch/arm/boot/compressed/string.c
+++ b/arch/arm/boot/compressed/string.c
@@ -8,6 +8,13 @@
 #define __NO_FORTIFY
 #include <linux/string.h>
 
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+/* Disable definitions with __same_pointer_depths_chk */
+#undef memcmp
+#undef memcpy
+#undef memmove
+#endif
+
 /*
  * The decompressor is built without KASan but uses the same redirects as the
  * rest of the kernel when CONFIG_KASAN is enabled, defining e.g. memcpy()
diff --git a/arch/arm/include/asm/string.h b/arch/arm/include/asm/string.h
index 6c607c68f3ad..9b5292888dba 100644
--- a/arch/arm/include/asm/string.h
+++ b/arch/arm/include/asm/string.h
@@ -55,14 +55,32 @@ static inline void *memset64(uint64_t *p, uint64_t v, __kernel_size_t n)
  * these defines kick in.
  */
 #if defined(CONFIG_KASAN) && !defined(__SANITIZE_ADDRESS__)
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+#define memcpy(t, f, l) ({ __same_pointer_depths_chk(t, f); __memcpy(t, f, l); })
+#define memmove(t, f, l) ({ __same_pointer_depths_chk(t, f); __memmove(t, f, l); })
+#else
 #define memcpy(dst, src, len) __memcpy(dst, src, len)
 #define memmove(dst, src, len) __memmove(dst, src, len)
+#endif
 #define memset(s, c, n) __memset(s, c, n)
 
 #ifndef __NO_FORTIFY
 #define __NO_FORTIFY /* FORTIFY_SOURCE uses __builtin_memcpy, etc. */
 #endif
+#endif
 
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+#if !(defined(CONFIG_KASAN) && !defined(__SANITIZE_ADDRESS__))
+#define memcpy(t, f, l) ({ __same_pointer_depths_chk(t, f); memcpy(t, f, l); })
+#define memmove(t, f, l) ({ __same_pointer_depths_chk(t, f); memmove(t, f, l); })
+#endif
+/* Tell the plugin that the difference is intentional */
+static noinline void *memcpy_with_cast(void *dest, const void *src, size_t count)
+{
+    return memcpy(dest, src, count);
+}
+#else
+#define memcpy_with_cast memcpy
 #endif
 
 #endif
diff --git a/arch/arm/mm/kasan_init.c b/arch/arm/mm/kasan_init.c
index 5ad0d6c56d56..2370bdf8140f 100644
--- a/arch/arm/mm/kasan_init.c
+++ b/arch/arm/mm/kasan_init.c
@@ -225,9 +225,13 @@ void __init kasan_init(void)
 	/* We need to be in the same PGD or this won't work */
 	BUILD_BUG_ON(pgd_index(KASAN_SHADOW_START) !=
 		     pgd_index(KASAN_SHADOW_END));
-	memcpy(tmp_pmd_table,
-	       (void*)pgd_page_vaddr(*pgd_offset_k(KASAN_SHADOW_START)),
-	       sizeof(tmp_pmd_table));
+	{
+		/* Play nice with the pointer deref checker */
+		void *pgd_kasan_shadow = (void *)pgd_page_vaddr(*pgd_offset_k(KASAN_SHADOW_START));
+		memcpy(tmp_pmd_table,
+		       pgd_kasan_shadow,
+		       sizeof(tmp_pmd_table));
+	}
 	set_pgd(&tmp_pgd_table[pgd_index(KASAN_SHADOW_START)],
 		__pgd(__pa(tmp_pmd_table) | PMD_TYPE_TABLE | L_PGD_SWAPPER));
 #endif
diff --git a/arch/arm/mm/mmu.c b/arch/arm/mm/mmu.c
index 274e4f73fd33..e62fa5cda1d7 100644
--- a/arch/arm/mm/mmu.c
+++ b/arch/arm/mm/mmu.c
@@ -1633,7 +1633,7 @@ static void __init early_paging_init(const struct machine_desc *mdesc)
 	__pv_phys_pfn_offset += PFN_DOWN(offset);
 
 	/* Run the patch stub to update the constants */
-	fixup_pv_table(&__pv_table_begin,
+	fixup_pv_table(__pv_table_begin, /* maybe BUG? Because global variable is void*... Found with deref checker */
 		(&__pv_table_end - &__pv_table_begin) << 2);
 
 	/*
diff --git a/arch/x86/boot/compressed/misc.c b/arch/x86/boot/compressed/misc.c
index a4339cb2d247..229861efe2bb 100644
--- a/arch/x86/boot/compressed/misc.c
+++ b/arch/x86/boot/compressed/misc.c
@@ -37,6 +37,10 @@
  * try to define their own functions if these are not defined as macros.
  */
 #define memzero(s, n)	memset((s), 0, (n))
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+/* The macro conflicts with the function definition below */
+#undef memmove
+#endif
 #define memmove		memmove
 
 /* Functions used by the included decompressor code below. */
diff --git a/arch/x86/boot/compressed/string.c b/arch/x86/boot/compressed/string.c
index 81fc1eaa3229..dc0247d6937d 100644
--- a/arch/x86/boot/compressed/string.c
+++ b/arch/x86/boot/compressed/string.c
@@ -10,6 +10,11 @@
 
 #include "../string.c"
 
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+#undef memcpy
+#undef memmove
+#endif
+
 #ifdef CONFIG_X86_32
 static void *____memcpy(void *dest, const void *src, size_t n)
 {
diff --git a/arch/x86/boot/string.h b/arch/x86/boot/string.h
index 1e62d9b4ec78..93a18b5cc180 100644
--- a/arch/x86/boot/string.h
+++ b/arch/x86/boot/string.h
@@ -13,7 +13,11 @@ int memcmp(const void *s1, const void *s2, size_t len);
 
 /* Access builtin version by default. */
 #ifndef __clang__ /* PR18415 */
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+#define memcpy(d,s,l) ({ __same_pointer_depths_chk(d, s);__builtin_memcpy(d,s,l);})
+#else
 #define memcpy(d,s,l) __builtin_memcpy(d,s,l)
+#endif
 #define memset(d,c,l) __builtin_memset(d,c,l)
 #define memcmp	__builtin_memcmp
 #endif
diff --git a/arch/x86/include/asm/string_32.h b/arch/x86/include/asm/string_32.h
index f74362b05619..f3d574d6fb52 100644
--- a/arch/x86/include/asm/string_32.h
+++ b/arch/x86/include/asm/string_32.h
@@ -33,6 +33,7 @@ extern size_t strlen(const char *s);
 static __always_inline void *__memcpy(void *to, const void *from, size_t n)
 {
 	int d0, d1, d2;
+	__same_pointer_depths_chk(to, from);
 	asm volatile("rep ; movsl\n\t"
 		     "movl %4,%%ecx\n\t"
 		     "andl $3,%%ecx\n\t"
@@ -53,6 +54,7 @@ static __always_inline void *__constant_memcpy(void *to, const void *from,
 					       size_t n)
 {
 	long esi, edi;
+	__same_pointer_depths_chk(to, from);
 	if (!n)
 		return to;
 
@@ -156,6 +158,7 @@ extern void *memcpy(void *, const void *, size_t);
 
 static inline void *__constant_memcpy3d(void *to, const void *from, size_t len)
 {
+	__same_pointer_depths_chk(to, from);
 	if (len < 512)
 		return __constant_memcpy(to, from, len);
 	return _mmx_memcpy(to, from, len);
@@ -163,15 +166,17 @@ static inline void *__constant_memcpy3d(void *to, const void *from, size_t len)
 
 static inline void *__memcpy3d(void *to, const void *from, size_t len)
 {
+	__same_pointer_depths_chk(to, from);
 	if (len < 512)
 		return __memcpy(to, from, len);
 	return _mmx_memcpy(to, from, len);
 }
 
 #define memcpy(t, f, n)				\
+	({ __same_pointer_depths_chk(t, f); \
 	(__builtin_constant_p((n))		\
 	 ? __constant_memcpy3d((t), (f), (n))	\
-	 : __memcpy3d((t), (f), (n)))
+	 : __memcpy3d((t), (f), (n)));})
 
 #else
 
@@ -179,11 +184,21 @@ static inline void *__memcpy3d(void *to, const void *from, size_t len)
  *	No 3D Now!
  */
 
-#define memcpy(t, f, n) __builtin_memcpy(t, f, n)
+#define memcpy(t, f, n) ({ __same_pointer_depths_chk(t, f); __builtin_memcpy(t, f, n);})
 
 #endif
 #endif /* !CONFIG_FORTIFY_SOURCE */
 
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+/* Tell the plugin that the difference is intentional */
+static noinline void *memcpy_with_cast(void *dest, const void *src, size_t count)
+{
+    return memcpy(dest, src, count);
+}
+#else
+#define memcpy_with_cast memcpy
+#endif
+
 #define __HAVE_ARCH_MEMMOVE
 void *memmove(void *dest, const void *src, size_t n);
 
diff --git a/arch/x86/include/asm/string_64.h b/arch/x86/include/asm/string_64.h
index 6e450827f677..fb81c967f83c 100644
--- a/arch/x86/include/asm/string_64.h
+++ b/arch/x86/include/asm/string_64.h
@@ -64,6 +64,19 @@ char *strcpy(char *dest, const char *src);
 char *strcat(char *dest, const char *src);
 int strcmp(const char *cs, const char *ct);
 
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+#define __memcmp(s, t, l) ({ __same_pointer_depths_chk(s, t); __memcmp(s, t, l); })
+#define __memcpy(t, f, l) ({ __same_pointer_depths_chk(t, f); __memcpy(t, f, l); })
+#define __memmove(t, f, l) ({ __same_pointer_depths_chk(t, f); __memmove(t, f, l); })
+/* Tell the plugin that the difference is intentional */
+static noinline void *memcpy_with_cast(void *dest, const void *src, size_t count)
+{
+    return memcpy(dest, src, count);
+}
+#else
+#define memcpy_with_cast memcpy
+#endif
+
 #if defined(CONFIG_KASAN) && !defined(__SANITIZE_ADDRESS__)
 
 /*
@@ -80,6 +93,10 @@ int strcmp(const char *cs, const char *ct);
 #define __NO_FORTIFY /* FORTIFY_SOURCE uses __builtin_memcpy, etc. */
 #endif
 
+#elif defined(CONFIG_GCC_PLUGIN_DEREF_CHECKER)
+#define memcmp(s, t, l) ({ __same_pointer_depths_chk(s, t); memcmp(s, t, l); })
+#define memcpy(t, f, l) ({ __same_pointer_depths_chk(t, f); memcpy(t, f, l); })
+#define memmove(t, f, l) ({ __same_pointer_depths_chk(t, f); memmove(t, f, l); })
 #endif
 
 #ifdef CONFIG_ARCH_HAS_UACCESS_FLUSHCACHE
diff --git a/arch/x86/kvm/hyperv.c b/arch/x86/kvm/hyperv.c
index 5e19e6e4c2ce..360ae27b88e0 100644
--- a/arch/x86/kvm/hyperv.c
+++ b/arch/x86/kvm/hyperv.c
@@ -1794,8 +1794,15 @@ static u64 kvm_hv_flush_tlb(struct kvm_vcpu *vcpu, struct kvm_hv_hcall *hc, bool
 		if (hc->fast) {
 			flush_ex.address_space = hc->ingpa;
 			flush_ex.flags = hc->outgpa;
-			memcpy(&flush_ex.hv_vp_set,
-			       &hc->xmm[0], sizeof(hc->xmm[0]));
+			{
+				/* Play nice with the pointer deref checker */
+				void *hc_xmm0 = &hc->xmm[0];
+				BUILD_BUG_ON(sizeof(flush_ex.hv_vp_set) != 16);
+				BUILD_BUG_ON(sizeof(flush_ex.hv_vp_set) != 16);
+				BUILD_BUG_ON(sizeof(*(&hc->xmm[0])) != 16);
+				memcpy(&flush_ex.hv_vp_set,
+				       hc_xmm0, sizeof(hc->xmm[0]));
+			}
 		} else {
 			if (unlikely(kvm_read_guest(kvm, hc->ingpa, &flush_ex,
 						    sizeof(flush_ex))))
diff --git a/arch/x86/lib/memcpy_32.c b/arch/x86/lib/memcpy_32.c
index e565d1c9019e..9f95ef31c49f 100644
--- a/arch/x86/lib/memcpy_32.c
+++ b/arch/x86/lib/memcpy_32.c
@@ -4,6 +4,9 @@
 
 #undef memcpy
 #undef memset
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+#undef memmove
+#endif
 
 __visible void *memcpy(void *to, const void *from, size_t n)
 {
diff --git a/arch/x86/math-emu/fpu_entry.c b/arch/x86/math-emu/fpu_entry.c
index 7fe56c594aa6..55593cb40a5c 100644
--- a/arch/x86/math-emu/fpu_entry.c
+++ b/arch/x86/math-emu/fpu_entry.c
@@ -113,6 +113,7 @@ void math_emulate(struct math_emu_info *info)
 	unsigned long code_base = 0;
 	unsigned long code_limit = 0;	/* Initialized to stop compiler warnings */
 	struct desc_struct code_descriptor;
+	u_char __user **peip;
 
 #ifdef RE_ENTRANT_CHECKING
 	if (emulating) {
@@ -163,7 +164,8 @@ void math_emulate(struct math_emu_info *info)
 
 	FPU_lookahead = !(FPU_EFLAGS & X86_EFLAGS_TF);
 
-	if (!valid_prefix(&byte1, (u_char __user **) & FPU_EIP,
+	peip = (u_char __user **) & FPU_EIP;
+	if (!valid_prefix(&byte1, peip,
 			  &addr_modes.override)) {
 		RE_ENTRANT_CHECK_OFF;
 		printk
@@ -527,7 +529,8 @@ void math_emulate(struct math_emu_info *info)
 
 	if (FPU_lookahead && !need_resched()) {
 		FPU_ORIG_EIP = FPU_EIP - code_base;
-		if (valid_prefix(&byte1, (u_char __user **) & FPU_EIP,
+		peip = (u_char __user **) & FPU_EIP;
+		if (valid_prefix(&byte1, peip,
 				 &addr_modes.override))
 			goto do_another_FPU_instruction;
 	}
diff --git a/arch/x86/xen/enlighten_pv.c b/arch/x86/xen/enlighten_pv.c
index 5004feb16783..52bf82a3eb7c 100644
--- a/arch/x86/xen/enlighten_pv.c
+++ b/arch/x86/xen/enlighten_pv.c
@@ -679,8 +679,12 @@ static int cvt_gate_to_trap(int vector, const gate_desc *val,
 	info->vector = vector;
 
 	addr = gate_offset(val);
-	if (!get_trap_addr((void **)&addr, val->bits.ist))
-		return 0;
+	/* Play nice with the pointer deref checker */
+	{
+		void **paddr = (void **)&addr;
+		if (!get_trap_addr(paddr, val->bits.ist))
+			return 0;
+	}
 	info->address = addr;
 
 	info->cs = gate_segment(val);
diff --git a/drivers/acpi/acpica/dspkginit.c b/drivers/acpi/acpica/dspkginit.c
index e642d65bcc66..f9eebc11b8dc 100644
--- a/drivers/acpi/acpica/dspkginit.c
+++ b/drivers/acpi/acpica/dspkginit.c
@@ -214,11 +214,12 @@ acpi_ds_build_internal_package_obj(struct acpi_walk_state *walk_state,
 				 * Forward references from module-level code are deferred
 				 * until all ACPI tables are loaded.
 				 */
+				/* Play nice with the pointer deref checker */
+				void *ctx = &obj_desc->package.elements[i];
 				acpi_ds_init_package_element(0,
 							     obj_desc->package.
 							     elements[i], NULL,
-							     &obj_desc->package.
-							     elements[i]);
+							     ctx);
 			}
 		}
 
diff --git a/drivers/acpi/property.c b/drivers/acpi/property.c
index 2366f54d8e9c..427ecf8f6433 100644
--- a/drivers/acpi/property.c
+++ b/drivers/acpi/property.c
@@ -970,9 +970,13 @@ static int acpi_data_prop_read(const struct acpi_device_data *data,
 		ret = acpi_copy_property_array_u64(items, (u64 *)val, nval);
 		break;
 	case DEV_PROP_STRING:
-		ret = acpi_copy_property_array_string(
-			items, (char **)val,
-			min_t(u32, nval, obj->package.count));
+		{
+			/* Play nice with the pointer deref checker */
+			char **valp = (char **)val;
+			ret = acpi_copy_property_array_string(
+				items, valp,
+				min_t(u32, nval, obj->package.count));
+		}
 		break;
 	default:
 		ret = -EINVAL;
diff --git a/drivers/base/swnode.c b/drivers/base/swnode.c
index 4debcea4fb12..727a40a13976 100644
--- a/drivers/base/swnode.c
+++ b/drivers/base/swnode.c
@@ -186,7 +186,7 @@ static int property_entry_read_string_array(const struct property_entry *props,
 					    const char *propname,
 					    const char **strings, size_t nval)
 {
-	const void *pointer;
+	const char *const *pointer; /* Play nice with the pointer deref checker */
 	size_t length;
 	int array_len;
 
@@ -280,8 +280,11 @@ static int property_entry_copy_data(struct property_entry *dst,
 	}
 
 	if (src->type == DEV_PROP_STRING) {
+		/* Play nice with the pointer deref checker */
+		const char **dst_ptr_as_pstr = (const char **)dst_ptr;
+		const char *const *pointer_as_pstr = (const char *const *)pointer;
 		nval = src->length / sizeof(const char *);
-		if (!property_copy_string_array(dst_ptr, pointer, nval)) {
+		if (!property_copy_string_array(dst_ptr_as_pstr, pointer_as_pstr, nval)) {
 			if (!dst->is_inline)
 				kfree(dst->pointer);
 			return -ENOMEM;
diff --git a/drivers/dma/ti/cppi41.c b/drivers/dma/ti/cppi41.c
index 8c2f7ebe998c..394868cf2780 100644
--- a/drivers/dma/ti/cppi41.c
+++ b/drivers/dma/ti/cppi41.c
@@ -275,12 +275,12 @@ static struct cppi41_channel *desc_to_chan(struct cppi41_dd *cdd, u32 desc)
 	return c;
 }
 
-static void cppi_writel(u32 val, void *__iomem *mem)
+static void cppi_writel(u32 val, void __iomem *mem)
 {
 	__raw_writel(val, mem);
 }
 
-static u32 cppi_readl(void *__iomem *mem)
+static u32 cppi_readl(void __iomem *mem)
 {
 	return __raw_readl(mem);
 }
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c
index 0311d799a010..7e41b7dc553f 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c
@@ -152,7 +152,7 @@ static int amdgpu_cs_parser_init(struct amdgpu_cs_parser *p, union drm_amdgpu_cs
 	}
 
 	for (i = 0; i < p->nchunks; i++) {
-		struct drm_amdgpu_cs_chunk __user **chunk_ptr = NULL;
+		struct drm_amdgpu_cs_chunk __user *chunk_ptr = NULL; /* harmless BUG */
 		struct drm_amdgpu_cs_chunk user_chunk;
 		uint32_t __user *cdata;
 
diff --git a/drivers/gpu/drm/drm_bufs.c b/drivers/gpu/drm/drm_bufs.c
index fcca21e8efac..8ac843532f91 100644
--- a/drivers/gpu/drm/drm_bufs.c
+++ b/drivers/gpu/drm/drm_bufs.c
@@ -1579,6 +1579,8 @@ static int map_one_buf(void *data, int idx, unsigned long virtual,
 {
 	struct drm_buf_map *request = data;
 	unsigned long address = virtual + buf->offset;	/* *** */
+	/* make the pointer checker plugin happy about copying an unsigned long to an void __user* */
+	unsigned long *preqaddr = (unsigned long *)&request->list[idx].address;
 
 	if (copy_to_user(&request->list[idx].idx, &buf->idx,
 			 sizeof(request->list[0].idx)))
@@ -1588,7 +1590,7 @@ static int map_one_buf(void *data, int idx, unsigned long virtual,
 		return -EFAULT;
 	if (clear_user(&request->list[idx].used, sizeof(int)))
 		return -EFAULT;
-	if (copy_to_user(&request->list[idx].address, &address,
+	if (copy_to_user(preqaddr, &address,
 			 sizeof(address)))
 		return -EFAULT;
 	return 0;
diff --git a/drivers/gpu/drm/i915/i915_debugfs_params.c b/drivers/gpu/drm/i915/i915_debugfs_params.c
index 20424275d41e..b01e3cafaafd 100644
--- a/drivers/gpu/drm/i915/i915_debugfs_params.c
+++ b/drivers/gpu/drm/i915/i915_debugfs_params.c
@@ -245,9 +245,10 @@ _i915_param_create_file(struct dentry *parent, const char *name,
 		i915_debugfs_create_uint(name, mode, parent, value);
 	else if (!__builtin_strcmp(type, "unsigned long"))
 		debugfs_create_ulong(name, mode, parent, value);
-	else if (!__builtin_strcmp(type, "char *"))
-		i915_debugfs_create_charp(name, mode, parent, value);
-	else
+	else if (!__builtin_strcmp(type, "char *")) {
+		char **pccvalue = value; /* Play nice with the pointer deref checker */
+		i915_debugfs_create_charp(name, mode, parent, pccvalue);
+	} else
 		WARN(1, "no debugfs fops defined for param type %s (i915.%s)\n",
 		     type, name);
 }
diff --git a/drivers/gpu/drm/radeon/radeon_cs.c b/drivers/gpu/drm/radeon/radeon_cs.c
index 9ed2b2700e0a..1b7ea3a2f4eb 100644
--- a/drivers/gpu/drm/radeon/radeon_cs.c
+++ b/drivers/gpu/drm/radeon/radeon_cs.c
@@ -304,7 +304,7 @@ int radeon_cs_parser_init(struct radeon_cs_parser *p, void *data)
 		return -ENOMEM;
 	}
 	for (i = 0; i < p->nchunks; i++) {
-		struct drm_radeon_cs_chunk __user **chunk_ptr = NULL;
+		struct drm_radeon_cs_chunk __user *chunk_ptr = NULL;
 		struct drm_radeon_cs_chunk user_chunk;
 		uint32_t __user *cdata;
 
diff --git a/drivers/media/pci/intel/ipu3/ipu3-cio2-main.c b/drivers/media/pci/intel/ipu3/ipu3-cio2-main.c
index 356ea966cf8d..3f6aa4131502 100644
--- a/drivers/media/pci/intel/ipu3/ipu3-cio2-main.c
+++ b/drivers/media/pci/intel/ipu3/ipu3-cio2-main.c
@@ -1946,8 +1946,12 @@ static void cio2_fbpt_rearrange(struct cio2_device *cio2, struct cio2_queue *q)
 	if (j) {
 		arrange(q->fbpt, sizeof(struct cio2_fbpt_entry) * CIO2_MAX_LOPS,
 			CIO2_MAX_BUFFERS, j);
-		arrange(q->bufs, sizeof(struct cio2_buffer *),
-			CIO2_MAX_BUFFERS, j);
+		{
+			/* Play nice with the pointer deref checker */
+			void *q_bufs = q->bufs;
+			arrange(q_bufs, sizeof(struct cio2_buffer *),
+				CIO2_MAX_BUFFERS, j);
+		}
 	}
 
 	/*
diff --git a/drivers/media/platform/omap3isp/ispstat.c b/drivers/media/platform/omap3isp/ispstat.c
index 5b9b57f4d9bf..9117a2c3b6dc 100644
--- a/drivers/media/platform/omap3isp/ispstat.c
+++ b/drivers/media/platform/omap3isp/ispstat.c
@@ -521,7 +521,13 @@ int omap3isp_stat_request_statistics_time32(struct ispstat *stat,
 
 	data->ts.tv_sec = data64.ts.tv_sec;
 	data->ts.tv_usec = data64.ts.tv_usec;
-	memcpy(&data->buf, &data64.buf, sizeof(*data) - sizeof(data->ts));
+	/* Replace a problematic memcpy with assignments, for the deref checker */
+	/*memcpy(&data->buf, &data64.buf, sizeof(*data) - sizeof(data->ts));*/
+	data->buf = (__u32)(uintptr_t)data64.buf;
+	data->buf_size = data64.buf_size;
+	data->frame_number = data64.frame_number;
+	data->cur_frame = data64.cur_frame;
+	data->config_counter = data64.config_counter;
 
 	return 0;
 }
diff --git a/drivers/misc/ibmasm/lowlevel.c b/drivers/misc/ibmasm/lowlevel.c
index 6922dc6c10db..bf7f5ec335df 100644
--- a/drivers/misc/ibmasm/lowlevel.c
+++ b/drivers/misc/ibmasm/lowlevel.c
@@ -33,7 +33,7 @@ int ibmasm_send_i2o_message(struct service_processor *sp)
 	message = get_i2o_message(sp->base_address, mfa);
 
 	memcpy_toio(&message->header, &header, sizeof(struct i2o_header));
-	memcpy_toio(&message->data, command->buffer, command_size);
+	memcpy_toio(message->data, command->buffer, command_size); /* BUG? */
 
 	set_mfa_inbound(sp->base_address, mfa);
 
@@ -60,7 +60,7 @@ irqreturn_t ibmasm_interrupt_handler(int irq, void * dev_id)
 	mfa = get_mfa_outbound(base_address);
 	if (valid_mfa(mfa)) {
 		struct i2o_message *msg = get_i2o_message(base_address, mfa);
-		ibmasm_receive_message(sp, &msg->data, incoming_data_size(msg));
+		ibmasm_receive_message(sp, msg->data, incoming_data_size(msg)); /* BUG? */
 	} else
 		dbg("didn't get a valid MFA\n");
 
diff --git a/drivers/net/ethernet/ti/davinci_cpdma.c b/drivers/net/ethernet/ti/davinci_cpdma.c
index d2eab5cd1e0c..0d149be7c66f 100644
--- a/drivers/net/ethernet/ti/davinci_cpdma.c
+++ b/drivers/net/ethernet/ti/davinci_cpdma.c
@@ -71,7 +71,7 @@ struct cpdma_desc {
 	u32			hw_len;
 	u32			hw_mode;
 	/* software fields */
-	void			*sw_token;
+	uintptr_t		sw_token;
 	u32			sw_buffer;
 	u32			sw_len;
 };
diff --git a/drivers/net/virtio_net.c b/drivers/net/virtio_net.c
index 55db6a336f7e..70a394003990 100644
--- a/drivers/net/virtio_net.c
+++ b/drivers/net/virtio_net.c
@@ -1127,7 +1127,7 @@ static struct sk_buff *receive_mergeable(struct net_device *dev,
 }
 
 static void receive_buf(struct virtnet_info *vi, struct receive_queue *rq,
-			void *buf, unsigned int len, void **ctx,
+			void *buf, unsigned int len, void *ctx, /* BUG? */
 			unsigned int *xdp_xmit,
 			struct virtnet_rq_stats *stats)
 {
diff --git a/drivers/net/wireless/ti/wlcore/main.c b/drivers/net/wireless/ti/wlcore/main.c
index 5669f17b395f..a0685ca2862a 100644
--- a/drivers/net/wireless/ti/wlcore/main.c
+++ b/drivers/net/wireless/ti/wlcore/main.c
@@ -1483,7 +1483,20 @@ void wl1271_rx_filter_flatten_fields(struct wl12xx_rx_filter *filter,
 		field->flags = filter->fields[i].flags;
 		field->len = filter->fields[i].len;
 
-		memcpy(&field->pattern, filter->fields[i].pattern, field->len);
+		/* FIXME: how is it supposed to work?
+			struct wl12xx_rx_filter_field {
+				__le16 offset;
+				u8 len;
+				u8 flags;
+				u8 *pattern;
+			} __packed;
+		 * => offset to end of header (u8 pattern[0]) or allocated mem?
+		 * Let's guess that it is offset to end of header (need to check the allocation one day...)
+		 */
+		{
+			void *dst = &field->pattern;
+			memcpy(dst, filter->fields[i].pattern, field->len);
+		}
 		buf += sizeof(struct wl12xx_rx_filter_field) -
 			sizeof(u8 *) + field->len;
 	}
diff --git a/drivers/scsi/csiostor/csio_hw.c b/drivers/scsi/csiostor/csio_hw.c
index e43c5413ce29..12a9f20ecf7e 100644
--- a/drivers/scsi/csiostor/csio_hw.c
+++ b/drivers/scsi/csiostor/csio_hw.c
@@ -4035,7 +4035,11 @@ csio_evtq_worker(struct work_struct *work)
 				break;
 
 			case CSIO_EVT_DEV_LOSS:
-				memcpy(&rn, evt_msg->data, sizeof(rn));
+				{
+					/* Play nice with the pointer deref checker */
+					const struct csio_rnode **src = (const struct csio_rnode **)(evt_msg->data);
+					memcpy(&rn, src, sizeof(rn));
+				}
 				csio_rnode_devloss_handler(rn);
 				break;
 
diff --git a/drivers/scsi/pm8001/pm8001_ctl.c b/drivers/scsi/pm8001/pm8001_ctl.c
index 397eb9f6a1dd..bdffa3dda792 100644
--- a/drivers/scsi/pm8001/pm8001_ctl.c
+++ b/drivers/scsi/pm8001/pm8001_ctl.c
@@ -698,7 +698,7 @@ static int pm8001_set_nvmd(struct pm8001_hba_info *pm8001_ha)
 		return -ENOMEM;
 	}
 	payload = (struct pm8001_ioctl_payload *)ioctlbuffer;
-	memcpy((u8 *)&payload->func_specific, (u8 *)pm8001_ha->fw_image->data,
+	memcpy((u8 *)payload->func_specific, (u8 *)pm8001_ha->fw_image->data, /* BUG? */
 				pm8001_ha->fw_image->size);
 	payload->wr_length = pm8001_ha->fw_image->size;
 	payload->id = 0;
@@ -749,7 +749,7 @@ static int pm8001_update_flash(struct pm8001_hba_info *pm8001_ha)
 			payload->wr_length = 1024*16;
 			payload->id = 0;
 			fwControl =
-			      (struct fw_control_info *)&payload->func_specific;
+			      (struct fw_control_info *)payload->func_specific; /* BUG? */
 			fwControl->len = IOCTL_BUF_SIZE;   /* IN */
 			fwControl->size = partitionSize + HEADER_LEN;/* IN */
 			fwControl->retcode = 0;/* OUT */
diff --git a/drivers/scsi/pm8001/pm8001_hwi.c b/drivers/scsi/pm8001/pm8001_hwi.c
index 124cb69740c6..d270bcd62895 100644
--- a/drivers/scsi/pm8001/pm8001_hwi.c
+++ b/drivers/scsi/pm8001/pm8001_hwi.c
@@ -4774,7 +4774,7 @@ int pm8001_chip_set_nvmd_req(struct pm8001_hba_info *pm8001_ha,
 		return -ENOMEM;
 	circularQ = &pm8001_ha->inbnd_q_tbl[0];
 	memcpy(pm8001_ha->memoryMap.region[NVMD].virt_ptr,
-		&ioctl_payload->func_specific,
+		ioctl_payload->func_specific, /* BUG? */
 		ioctl_payload->wr_length);
 	memset(&nvmd_req, 0, sizeof(nvmd_req));
 	rc = pm8001_tag_alloc(pm8001_ha, &tag);
diff --git a/drivers/staging/gdm724x/hci_packet.h b/drivers/staging/gdm724x/hci_packet.h
index faecdfbc664f..9d4aac1ed959 100644
--- a/drivers/staging/gdm724x/hci_packet.h
+++ b/drivers/staging/gdm724x/hci_packet.h
@@ -34,7 +34,7 @@ struct hci_packet {
 struct tlv {
 	u8 type;
 	u8 len;
-	u8 *data[1];
+	u8 data[0];
 } __packed;
 
 struct sdu_header {
diff --git a/drivers/staging/rtl8192e/rtl8192e/r8192E_cmdpkt.c b/drivers/staging/rtl8192e/rtl8192e/r8192E_cmdpkt.c
index c5e44bbe997c..075a10a68be1 100644
--- a/drivers/staging/rtl8192e/rtl8192e/r8192E_cmdpkt.c
+++ b/drivers/staging/rtl8192e/rtl8192e/r8192E_cmdpkt.c
@@ -44,7 +44,7 @@ bool rtl92e_send_cmd_pkt(struct net_device *dev, u32 type, const void *data,
 			goto Failed;
 		}
 
-		memcpy((unsigned char *)(skb->cb), &dev, sizeof(dev));
+		memcpy_with_cast((unsigned char *)(skb->cb), &dev, sizeof(dev));
 		tcb_desc = (struct cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);
 		tcb_desc->queue_index = TXCMD_QUEUE;
 		tcb_desc->bCmdOrInit = type;
diff --git a/drivers/staging/rtl8192e/rtl8192e/rtl_core.c b/drivers/staging/rtl8192e/rtl8192e/rtl_core.c
index b9ce71848023..e76bed783950 100644
--- a/drivers/staging/rtl8192e/rtl8192e/rtl_core.c
+++ b/drivers/staging/rtl8192e/rtl8192e/rtl_core.c
@@ -1609,7 +1609,7 @@ static void _rtl92e_hard_data_xmit(struct sk_buff *skb, struct net_device *dev,
 		netdev_warn(dev, "%s(): queue index == TXCMD_QUEUE\n",
 			    __func__);
 
-	memcpy((unsigned char *)(skb->cb), &dev, sizeof(dev));
+	memcpy_with_cast((unsigned char *)(skb->cb), &dev, sizeof(dev));
 	skb_push(skb, priv->rtllib->tx_headroom);
 	ret = _rtl92e_tx(dev, skb);
 
@@ -1639,7 +1639,7 @@ static int _rtl92e_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
 		}
 	}
 
-	memcpy((unsigned char *)(skb->cb), &dev, sizeof(dev));
+	memcpy_with_cast((unsigned char *)(skb->cb), &dev, sizeof(dev));
 	if (queue_index == TXCMD_QUEUE) {
 		_rtl92e_tx_cmd(dev, skb);
 		return 0;
diff --git a/drivers/staging/rtl8192u/r8192U_core.c b/drivers/staging/rtl8192u/r8192U_core.c
index 726d7ad9408b..4b9b5b20422e 100644
--- a/drivers/staging/rtl8192u/r8192U_core.c
+++ b/drivers/staging/rtl8192u/r8192U_core.c
@@ -931,7 +931,7 @@ static int rtl8192_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
 
 	spin_lock_irqsave(&priv->tx_lock, flags);
 
-	memcpy((unsigned char *)(skb->cb), &dev, sizeof(dev));
+	memcpy_with_cast((unsigned char *)(skb->cb), &dev, sizeof(dev));
 	if (queue_index == TXCMD_QUEUE) {
 		skb_push(skb, USB_HWDESC_HEADER_LEN);
 		rtl819xU_tx_cmd(dev, skb);
diff --git a/drivers/staging/rtl8192u/r819xU_cmdpkt.c b/drivers/staging/rtl8192u/r819xU_cmdpkt.c
index 30a320422358..e64ffeefaeab 100644
--- a/drivers/staging/rtl8192u/r819xU_cmdpkt.c
+++ b/drivers/staging/rtl8192u/r819xU_cmdpkt.c
@@ -39,7 +39,7 @@ rt_status SendTxCommandPacket(struct net_device *dev, void *pData, u32 DataLen)
 	skb  = dev_alloc_skb(USB_HWDESC_HEADER_LEN + DataLen + 4);
 	if (!skb)
 		return RT_STATUS_FAILURE;
-	memcpy((unsigned char *)(skb->cb), &dev, sizeof(dev));
+	memcpy_with_cast((unsigned char *)(skb->cb), &dev, sizeof(dev));
 	tcb_desc = (struct cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);
 	tcb_desc->queue_index = TXCMD_QUEUE;
 	tcb_desc->bCmdOrInit = DESC_PACKET_TYPE_NORMAL;
diff --git a/drivers/staging/rtl8192u/r819xU_firmware.c b/drivers/staging/rtl8192u/r819xU_firmware.c
index 4f8629e47e82..b5b8333df68e 100644
--- a/drivers/staging/rtl8192u/r819xU_firmware.c
+++ b/drivers/staging/rtl8192u/r819xU_firmware.c
@@ -65,7 +65,7 @@ static bool fw_download_code(struct net_device *dev, u8 *code_virtual_address,
 		skb  = dev_alloc_skb(USB_HWDESC_HEADER_LEN + frag_length + 4);
 		if (!skb)
 			return false;
-		memcpy((unsigned char *)(skb->cb), &dev, sizeof(dev));
+		memcpy_with_cast((unsigned char *)(skb->cb), &dev, sizeof(dev));
 		tcb_desc = (struct cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);
 		tcb_desc->queue_index = TXCMD_QUEUE;
 		tcb_desc->bCmdOrInit = DESC_PACKET_TYPE_INIT;
diff --git a/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_ioctl.h b/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_ioctl.h
index 86d77f2eeea5..bfff5543964a 100644
--- a/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_ioctl.h
+++ b/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_ioctl.h
@@ -54,7 +54,7 @@ struct vchiq_await_completion {
 	struct vchiq_completion_data __user *buf;
 	unsigned int msgbufsize;
 	unsigned int msgbufcount; /* IN/OUT */
-	void * __user *msgbufs;
+	void __user *msgbufs; /* Be nice with deref checker: it is an array of pointers of either 32-bit (compat) or 64-bit (native) size */
 };
 
 struct vchiq_dequeue_message {
diff --git a/drivers/thermal/intel/int340x_thermal/int3402_thermal.c b/drivers/thermal/intel/int340x_thermal/int3402_thermal.c
index 43fa351e2b9e..719538e52a42 100644
--- a/drivers/thermal/intel/int340x_thermal/int3402_thermal.c
+++ b/drivers/thermal/intel/int340x_thermal/int3402_thermal.c
@@ -16,7 +16,7 @@
 #define INT3402_THERMAL_EVENT		0x90
 
 struct int3402_thermal_data {
-	acpi_handle *handle;
+	acpi_handle handle; /* harmless bug: too many stars */
 	struct int34x_thermal_zone *int340x_zone;
 };
 
diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index fa66e6e58792..eb51c6d2baf1 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -2076,12 +2076,13 @@ static struct async *reap_as(struct usb_dev_state *ps)
 static int proc_reapurb(struct usb_dev_state *ps, void __user *arg)
 {
 	struct async *as = reap_as(ps);
+	void __user * __user *parg = (void __user * __user *)arg;
 
 	if (as) {
 		int retval;
 
 		snoop(&ps->dev->dev, "reap %px\n", as->userurb);
-		retval = processcompl(as, (void __user * __user *)arg);
+		retval = processcompl(as, parg);
 		free_async(as);
 		return retval;
 	}
@@ -2094,11 +2095,12 @@ static int proc_reapurbnonblock(struct usb_dev_state *ps, void __user *arg)
 {
 	int retval;
 	struct async *as;
+	void __user * __user *parg = (void __user * __user *)arg;
 
 	as = async_getcompleted(ps);
 	if (as) {
 		snoop(&ps->dev->dev, "reap %px\n", as->userurb);
-		retval = processcompl(as, (void __user * __user *)arg);
+		retval = processcompl(as, parg);
 		free_async(as);
 	} else {
 		retval = (connected(ps) ? -EAGAIN : -ENODEV);
@@ -2221,12 +2223,13 @@ static int processcompl_compat(struct async *as, void __user * __user *arg)
 static int proc_reapurb_compat(struct usb_dev_state *ps, void __user *arg)
 {
 	struct async *as = reap_as(ps);
+	void __user * __user *parg = (void __user * __user *)arg;
 
 	if (as) {
 		int retval;
 
 		snoop(&ps->dev->dev, "reap %px\n", as->userurb);
-		retval = processcompl_compat(as, (void __user * __user *)arg);
+		retval = processcompl_compat(as, parg);
 		free_async(as);
 		return retval;
 	}
@@ -2239,11 +2242,12 @@ static int proc_reapurbnonblock_compat(struct usb_dev_state *ps, void __user *ar
 {
 	int retval;
 	struct async *as;
+	void __user * __user *parg = (void __user * __user *)arg;
 
 	as = async_getcompleted(ps);
 	if (as) {
 		snoop(&ps->dev->dev, "reap %px\n", as->userurb);
-		retval = processcompl_compat(as, (void __user * __user *)arg);
+		retval = processcompl_compat(as, parg);
 		free_async(as);
 	} else {
 		retval = (connected(ps) ? -EAGAIN : -ENODEV);
diff --git a/drivers/usb/dwc2/hcd.c b/drivers/usb/dwc2/hcd.c
index 13c779a28e94..a82d04d386f3 100644
--- a/drivers/usb/dwc2/hcd.c
+++ b/drivers/usb/dwc2/hcd.c
@@ -2475,10 +2475,14 @@ static void dwc2_free_dma_aligned_buffer(struct urb *urb)
 		return;
 
 	/* Restore urb->transfer_buffer from the end of the allocated area */
-	memcpy(&stored_xfer_buffer,
-	       PTR_ALIGN(urb->transfer_buffer + urb->transfer_buffer_length,
-			 dma_get_cache_alignment()),
-	       sizeof(urb->transfer_buffer));
+	{
+		/* Play nice with the pointer deref checker, as the code really wants to copy a pointer with memcpy */
+		void *p_stored_xfer_buffer = &stored_xfer_buffer;
+		memcpy(p_stored_xfer_buffer,
+			   PTR_ALIGN(urb->transfer_buffer + urb->transfer_buffer_length,
+				 dma_get_cache_alignment()),
+			   sizeof(urb->transfer_buffer));
+	}
 
 	if (usb_urb_dir_in(urb)) {
 		if (usb_pipeisoc(urb->pipe))
@@ -2521,9 +2525,13 @@ static int dwc2_alloc_dma_aligned_buffer(struct urb *urb, gfp_t mem_flags)
 	 * Position value of original urb->transfer_buffer pointer to the end
 	 * of allocation for later referencing
 	 */
-	memcpy(PTR_ALIGN(kmalloc_ptr + urb->transfer_buffer_length,
-			 dma_get_cache_alignment()),
-	       &urb->transfer_buffer, sizeof(urb->transfer_buffer));
+	{
+		/* Play nice with the pointer deref checker, as the code really wants to copy a pointer with memcpy */
+		void *p_urb_transient_buffer = &urb->transfer_buffer;
+	    memcpy(PTR_ALIGN(kmalloc_ptr + urb->transfer_buffer_length,
+			     dma_get_cache_alignment()),
+		   p_urb_transient_buffer, sizeof(urb->transfer_buffer));
+	}
 
 	if (usb_urb_dir_out(urb))
 		memcpy(kmalloc_ptr, urb->transfer_buffer,
diff --git a/drivers/usb/host/xhci-debugfs.c b/drivers/usb/host/xhci-debugfs.c
index dc832ddf7033..604f98bc8dc7 100644
--- a/drivers/usb/host/xhci-debugfs.c
+++ b/drivers/usb/host/xhci-debugfs.c
@@ -420,10 +420,12 @@ static struct dentry *xhci_debugfs_create_ring_dir(struct xhci_hcd *xhci,
 						   struct dentry *parent)
 {
 	struct dentry		*dir;
+	/* Play nice with the pointer deref checker */
+	void *ring_ptr = ring;
 
 	dir = debugfs_create_dir(name, parent);
 	xhci_debugfs_create_files(xhci, ring_files, ARRAY_SIZE(ring_files),
-				  ring, dir, &xhci_ring_fops);
+				  ring_ptr, dir, &xhci_ring_fops);
 
 	return dir;
 }
diff --git a/drivers/vhost/scsi.c b/drivers/vhost/scsi.c
index 532e204f2b1b..cc9a41d992b4 100644
--- a/drivers/vhost/scsi.c
+++ b/drivers/vhost/scsi.c
@@ -1616,7 +1616,11 @@ vhost_scsi_set_endpoint(struct vhost_scsi *vs,
 		for (i = 0; i < VHOST_SCSI_MAX_VQ; i++) {
 			vq = &vs->vqs[i].vq;
 			mutex_lock(&vq->mutex);
-			vhost_vq_set_backend(vq, vs_tpg);
+			/* Play nice with the pointer deref checker */
+			{
+				void *vs_tpg_p = (void *)vs_tpg;
+				vhost_vq_set_backend(vq, vs_tpg_p);
+			}
 			vhost_vq_init_access(vq);
 			mutex_unlock(&vq->mutex);
 		}
diff --git a/drivers/xen/xenbus/xenbus_xs.c b/drivers/xen/xenbus/xenbus_xs.c
index 12e02eb01f59..c0c6301d5132 100644
--- a/drivers/xen/xenbus/xenbus_xs.c
+++ b/drivers/xen/xenbus/xenbus_xs.c
@@ -409,7 +409,9 @@ static char **split(char *strings, unsigned int len, unsigned int *num)
 		kfree(strings);
 		return ERR_PTR(-ENOMEM);
 	}
-	memcpy(&ret[*num], strings, len);
+	/* Be nice with pointer deref checker: the ned of ret is char* */
+	p = (char *)&ret[*num];
+	memcpy(p, strings, len);
 	kfree(strings);
 
 	strings = (char *)&ret[*num];
diff --git a/fs/cifs/cifsacl.c b/fs/cifs/cifsacl.c
index ee3aab3dd4ac..8e479326e641 100644
--- a/fs/cifs/cifsacl.c
+++ b/fs/cifs/cifsacl.c
@@ -415,16 +415,20 @@ sid_to_id(struct cifs_sb_info *cifs_sb, struct cifs_sid *psid,
 	}
 
 	if (sidtype == SIDOWNER) {
-		kuid_t uid;
+		kuid_t uid, *ppayload_uid;
 		uid_t id;
-		memcpy(&id, &sidkey->payload.data[0], sizeof(uid_t));
+		/* Play nice with the pointer deref checker */
+		ppayload_uid = (kuid_t *)&sidkey->payload.data[0];
+		memcpy(&id, ppayload_uid, sizeof(uid_t));
 		uid = make_kuid(&init_user_ns, id);
 		if (uid_valid(uid))
 			fuid = uid;
 	} else {
-		kgid_t gid;
+		kgid_t gid, *ppayload_gid;
 		gid_t id;
-		memcpy(&id, &sidkey->payload.data[0], sizeof(gid_t));
+		/* Play nice with the pointer deref checker */
+		ppayload_gid = (kgid_t *)&sidkey->payload.data[0];
+		memcpy(&id, ppayload_gid, sizeof(gid_t));
 		gid = make_kgid(&init_user_ns, id);
 		if (gid_valid(gid))
 			fgid = gid;
diff --git a/fs/debugfs/file.c b/fs/debugfs/file.c
index 7d162b0efbf0..2b49f2280d11 100644
--- a/fs/debugfs/file.c
+++ b/fs/debugfs/file.c
@@ -936,7 +936,9 @@ static const struct file_operations fops_str_wo = {
 void debugfs_create_str(const char *name, umode_t mode,
 			struct dentry *parent, char **value)
 {
-	debugfs_create_mode_unsafe(name, mode, parent, value, &fops_str,
+	/* Play nice with the pointer deref checker */
+	void *pvalue = (void *)value;
+	debugfs_create_mode_unsafe(name, mode, parent, pvalue, &fops_str,
 				   &fops_str_ro, &fops_str_wo);
 }
 
diff --git a/fs/ocfs2/aops.h b/fs/ocfs2/aops.h
index 3a520117fa59..eec863df211f 100644
--- a/fs/ocfs2/aops.h
+++ b/fs/ocfs2/aops.h
@@ -48,8 +48,11 @@ int ocfs2_size_fits_inline_data(struct buffer_head *di_bh, u64 new_size);
 int ocfs2_get_block(struct inode *inode, sector_t iblock,
 		    struct buffer_head *bh_result, int create);
 /* all ocfs2_dio_end_io()'s fault */
-#define ocfs2_iocb_is_rw_locked(iocb) \
-	test_bit(0, (unsigned long *)&iocb->private)
+#define ocfs2_iocb_is_rw_locked(iocb) ({ \
+	/* Play nice with the pointer deref checker */ \
+	unsigned long *iocb_private_ul = (unsigned long *)&(iocb)->private; \
+	test_bit(0, (unsigned long *)iocb_private_ul); \
+	})
 static inline void ocfs2_iocb_set_rw_locked(struct kiocb *iocb, int level)
 {
 	set_bit(0, (unsigned long *)&iocb->private);
@@ -72,7 +75,10 @@ enum ocfs2_iocb_lock_bits {
 
 #define ocfs2_iocb_clear_rw_locked(iocb) \
 	clear_bit(OCFS2_IOCB_RW_LOCK, (unsigned long *)&iocb->private)
-#define ocfs2_iocb_rw_locked_level(iocb) \
-	test_bit(OCFS2_IOCB_RW_LOCK_LEVEL, (unsigned long *)&iocb->private)
+#define ocfs2_iocb_rw_locked_level(iocb) ({ \
+	/* Play nice with the pointer deref checker */ \
+	unsigned long *iocb_private_ul = (unsigned long *)&(iocb)->private; \
+	test_bit(OCFS2_IOCB_RW_LOCK_LEVEL, (unsigned long *)iocb_private_ul); \
+	})
 
 #endif /* OCFS2_FILE_H */
diff --git a/fs/proc/proc_sysctl.c b/fs/proc/proc_sysctl.c
index 5d66faecd4ef..3e0cd2118b59 100644
--- a/fs/proc/proc_sysctl.c
+++ b/fs/proc/proc_sysctl.c
@@ -1853,8 +1853,12 @@ void do_sysctl_args(void)
 	if (!command_line)
 		panic("%s: Failed to allocate copy of command line\n", __func__);
 
-	parse_args("Setting sysctl args", command_line,
-		   NULL, 0, -1, -1, &proc_mnt, process_sysctl_arg);
+	{
+		/* Play nice with the pointer deref checker */
+		void *p_proc_mnt = &proc_mnt;
+		parse_args("Setting sysctl args", command_line,
+			   NULL, 0, -1, -1, p_proc_mnt, process_sysctl_arg);
+	}
 
 	if (proc_mnt)
 		kern_unmount(proc_mnt);
diff --git a/include/asm-generic/asm-prototypes.h b/include/asm-generic/asm-prototypes.h
index 2fa2bc208383..7c392857a3d3 100644
--- a/include/asm-generic/asm-prototypes.h
+++ b/include/asm-generic/asm-prototypes.h
@@ -12,3 +12,9 @@ extern void *memset(void *, int, __kernel_size_t);
 extern void *memcpy(void *, const void *, __kernel_size_t);
 #undef memmove
 extern void *memmove(void *, const void *, __kernel_size_t);
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+#define __memcpy(t, f, l) ({ __same_pointer_depths_chk(t, f); __memcpy(t, f, l); })
+#define __memmove(t, f, l) ({ __same_pointer_depths_chk(t, f); __memmove(t, f, l); })
+#define memcpy(t, f, l) ({ __same_pointer_depths_chk(t, f); memcpy(t, f, l); })
+#define memmove(t, f, l) ({ __same_pointer_depths_chk(t, f); memmove(t, f, l); })
+#endif
diff --git a/include/linux/bitops.h b/include/linux/bitops.h
index 5e62e2383b7f..f0d95438ffc7 100644
--- a/include/linux/bitops.h
+++ b/include/linux/bitops.h
@@ -265,8 +265,10 @@ static __always_inline void __assign_bit(long nr, volatile unsigned long *addr,
  */
 #define __ptr_set_bit(nr, addr)                         \
 	({                                              \
+		/* Play nice with the pointer deref checker */ \
+		unsigned long *addr_ul = (unsigned long *)(addr); \
 		typecheck_pointer(*(addr));             \
-		__set_bit(nr, (unsigned long *)(addr)); \
+		__set_bit(nr, (unsigned long *)(addr_ul)); \
 	})
 
 /**
@@ -280,8 +282,10 @@ static __always_inline void __assign_bit(long nr, volatile unsigned long *addr,
  */
 #define __ptr_clear_bit(nr, addr)                         \
 	({                                                \
+		/* Play nice with the pointer deref checker */ \
+		unsigned long *addr_ul = (unsigned long *)(addr); \
 		typecheck_pointer(*(addr));               \
-		__clear_bit(nr, (unsigned long *)(addr)); \
+		__clear_bit(nr, (unsigned long *)(addr_ul)); \
 	})
 
 /**
@@ -299,8 +303,10 @@ static __always_inline void __assign_bit(long nr, volatile unsigned long *addr,
  */
 #define __ptr_test_bit(nr, addr)                       \
 	({                                             \
+		/* Play nice with the pointer deref checker */ \
+		unsigned long *addr_ul = (unsigned long *)(addr); \
 		typecheck_pointer(*(addr));            \
-		test_bit(nr, (unsigned long *)(addr)); \
+		test_bit(nr, (unsigned long *)(addr_ul)); \
 	})
 
 #ifdef __KERNEL__
diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index 3d5af56337bd..b78e0ccc8d42 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -8,6 +8,27 @@
 
 #ifdef __KERNEL__
 
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+/* Make pointer deref checker able to check the consistency of optimized functions
+ *
+ * This is VERY ugly and a better way would be to insert the plugin before gcc
+ * inlines calls to memcpy, but I have not yet found how to do this.
+ */
+static noinline notrace __used void __same_pointer_depths_chk(const void *p1, const void *p2)
+{
+}
+static noinline notrace __used void __same_pointer_depths_with_volatile1_chk(const volatile void *p1, const void *p2)
+{
+}
+static noinline notrace __used void __same_pointer_depths_with_volatile2_chk(const void *p1, const volatile void *p2)
+{
+}
+#else
+#define __same_pointer_depths_chk(p1, p2) do { } while (0)
+#define __same_pointer_depths_with_volatile1_chk(p1, p2) do { } while (0)
+#define __same_pointer_depths_with_volatile2_chk(p1, p2) do { } while (0)
+#endif
+
 /*
  * Note: DISABLE_BRANCH_PROFILING can be used by special lowlevel code
  * to disable branch tracing on a per file basis.
diff --git a/include/linux/string.h b/include/linux/string.h
index 6388a4b53bea..04eaa07c7c89 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -153,7 +153,13 @@ extern void * memmove(void *,const void *,__kernel_size_t);
 extern void * memscan(void *,int,__kernel_size_t);
 #endif
 #ifndef __HAVE_ARCH_MEMCMP
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+#undef memcmp
+#endif
 extern int memcmp(const void *,const void *,__kernel_size_t);
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+#define memcmp(s, t, l) ({ __same_pointer_depths_chk(s, t); memcmp(s, t, l); })
+#endif
 #endif
 #ifndef __HAVE_ARCH_BCMP
 extern int bcmp(const void *,const void *,__kernel_size_t);
@@ -249,6 +255,12 @@ static inline const char *kbasename(const char *path)
 	return tail ? tail + 1 : path;
 }
 
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+#undef memcmp
+#undef memcpy
+#undef memmove
+#endif
+
 #if !defined(__NO_FORTIFY) && defined(__OPTIMIZE__) && defined(CONFIG_FORTIFY_SOURCE)
 #include <linux/fortify-string.h>
 #endif
@@ -291,6 +303,12 @@ void memcpy_and_pad(void *dest, size_t dest_len, const void *src, size_t count,
 	       sizeof(*(obj)) - offsetof(typeof(*(obj)), member));	\
 })
 
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+#define memcmp(s, t, l) ({ __same_pointer_depths_chk(s, t); memcmp(s, t, l); })
+#define memcpy(t, f, l) ({ __same_pointer_depths_chk(t, f); memcpy(t, f, l); })
+#define memmove(t, f, l) ({ __same_pointer_depths_chk(t, f); memmove(t, f, l); })
+#endif
+
 /**
  * str_has_prefix - Test if a string has a given prefix
  * @str: The string to test
diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 33451f8ff755..08acbe1a83cf 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -1090,14 +1090,18 @@ static inline snd_pcm_sframes_t
 snd_pcm_lib_writev(struct snd_pcm_substream *substream,
 		   void __user **bufs, snd_pcm_uframes_t frames)
 {
-	return __snd_pcm_lib_xfer(substream, (void *)bufs, false, frames, false);
+	/* make the pointer checker plugin happy about using a void** in a function taking void * */
+	void *pbufs = (void __force *)bufs;
+	return __snd_pcm_lib_xfer(substream, pbufs, false, frames, false);
 }
 
 static inline snd_pcm_sframes_t
 snd_pcm_lib_readv(struct snd_pcm_substream *substream,
 		  void __user **bufs, snd_pcm_uframes_t frames)
 {
-	return __snd_pcm_lib_xfer(substream, (void *)bufs, false, frames, false);
+	/* make the pointer checker plugin happy about using a void** in a function taking void * */
+	void *pbufs = (void __force *)bufs;
+	return __snd_pcm_lib_xfer(substream, pbufs, false, frames, false);
 }
 
 static inline snd_pcm_sframes_t
@@ -1118,14 +1122,18 @@ static inline snd_pcm_sframes_t
 snd_pcm_kernel_writev(struct snd_pcm_substream *substream,
 		      void **bufs, snd_pcm_uframes_t frames)
 {
-	return __snd_pcm_lib_xfer(substream, bufs, false, frames, true);
+	/* make the pointer checker plugin happy about using a void** in a function taking void * */
+	void *pbufs = bufs;
+	return __snd_pcm_lib_xfer(substream, pbufs, false, frames, true);
 }
 
 static inline snd_pcm_sframes_t
 snd_pcm_kernel_readv(struct snd_pcm_substream *substream,
 		     void **bufs, snd_pcm_uframes_t frames)
 {
-	return __snd_pcm_lib_xfer(substream, bufs, false, frames, true);
+	/* make the pointer checker plugin happy about using a void** in a function taking void * */
+	void *pbufs = bufs;
+	return __snd_pcm_lib_xfer(substream, pbufs, false, frames, true);
 }
 
 int snd_pcm_hw_limit_rates(struct snd_pcm_hardware *hw);
diff --git a/include/trace/bpf_probe.h b/include/trace/bpf_probe.h
index a8e97f84b652..b711e66a5931 100644
--- a/include/trace/bpf_probe.h
+++ b/include/trace/bpf_probe.h
@@ -37,7 +37,7 @@
 #define __CAST_TO_U64(x) ({ \
 	typeof(x) __src = (x); \
 	UINTTYPE(sizeof(x)) __dst; \
-	memcpy(&__dst, &__src, sizeof(__dst)); \
+	memcpy_with_cast(&__dst, &__src, sizeof(__dst)); \
 	(u64)__dst; })
 
 #define __CAST1(a,...) __CAST_TO_U64(a)
diff --git a/kernel/bpf/arraymap.c b/kernel/bpf/arraymap.c
index c7a5be3bf8be..44e1516c95ea 100644
--- a/kernel/bpf/arraymap.c
+++ b/kernel/bpf/arraymap.c
@@ -580,8 +580,10 @@ static int __bpf_array_map_seq_show(struct seq_file *seq, void *v)
 			pptr = v;
 			size = round_up(map->value_size, 8);
 			for_each_possible_cpu(cpu) {
+				/* Play nice with the pointer deref checker */
+				void *pptr_cpu = (void *)per_cpu_ptr(pptr, cpu);
 				bpf_long_memcpy(info->percpu_value_buf + off,
-						per_cpu_ptr(pptr, cpu),
+						pptr_cpu,
 						size);
 				off += size;
 			}
diff --git a/kernel/bpf/hashtab.c b/kernel/bpf/hashtab.c
index d29af9988f37..6306855a8827 100644
--- a/kernel/bpf/hashtab.c
+++ b/kernel/bpf/hashtab.c
@@ -2352,7 +2352,13 @@ int bpf_fd_htab_map_update_elem(struct bpf_map *map, struct file *map_file,
 	if (IS_ERR(ptr))
 		return PTR_ERR(ptr);
 
-	ret = htab_map_update_elem(map, key, &ptr, map_flags);
+	{
+		/* make the pointer checker plugin happy about using a void** value
+		 * (this is expected: the value is memcpy'ed into the hashtable)
+		 */
+		void *value_ptr = (void *)&ptr;
+		ret = htab_map_update_elem(map, key, value_ptr, map_flags);
+	}
 	if (ret)
 		map->ops->map_fd_put_ptr(ptr);
 
diff --git a/kernel/futex/core.c b/kernel/futex/core.c
index 25d8a88b32e5..0e32bdf72083 100644
--- a/kernel/futex/core.c
+++ b/kernel/futex/core.c
@@ -902,8 +902,12 @@ static void compat_exit_robust_list(struct task_struct *curr)
 		 * Fetch the next entry in the list before calling
 		 * handle_futex_death:
 		 */
-		rc = compat_fetch_robust_entry(&next_uentry, &next_entry,
-			(compat_uptr_t __user *)&entry->next, &next_pi);
+		{
+			/* Play nice with the pointer deref checker */
+			compat_uptr_t __user *entry_next = (compat_uptr_t __user *)&entry->next;
+			rc = compat_fetch_robust_entry(&next_uentry, &next_entry,
+				entry_next, &next_pi);
+		}
 		/*
 		 * A pending lock might already be on the list, so
 		 * dont process it twice:
diff --git a/kernel/livepatch/core.c b/kernel/livepatch/core.c
index 335d988bd811..ab7ad78674d2 100644
--- a/kernel/livepatch/core.c
+++ b/kernel/livepatch/core.c
@@ -787,9 +787,11 @@ static int klp_init_object_loaded(struct klp_patch *patch,
 	}
 
 	klp_for_each_func(obj, func) {
+		/* Play nice with the pointer deref checker */
+		unsigned long *p_func_old_func = (unsigned long *)&func->old_func;
 		ret = klp_find_object_symbol(obj->name, func->old_name,
 					     func->old_sympos,
-					     (unsigned long *)&func->old_func);
+					     p_func_old_func);
 		if (ret)
 			return ret;
 
diff --git a/kernel/livepatch/transition.c b/kernel/livepatch/transition.c
index 5683ac0d2566..d30093931c8c 100644
--- a/kernel/livepatch/transition.c
+++ b/kernel/livepatch/transition.c
@@ -269,11 +269,12 @@ static int klp_check_stack(struct task_struct *task, const char **oldname)
 static int klp_check_and_switch_task(struct task_struct *task, void *arg)
 {
 	int ret;
+	const char **old_name = arg;
 
 	if (task_curr(task) && task != current)
 		return -EBUSY;
 
-	ret = klp_check_stack(task, arg);
+	ret = klp_check_stack(task, old_name);
 	if (ret)
 		return ret;
 
@@ -308,7 +309,11 @@ static bool klp_try_switch_task(struct task_struct *task)
 	 * functions.  If all goes well, switch the task to the target patch
 	 * state.
 	 */
-	ret = task_call_func(task, klp_check_and_switch_task, &old_name);
+	{
+		/* Play nice with the pointer deref checker */
+		void *arg = &old_name;
+		ret = task_call_func(task, klp_check_and_switch_task, arg);
+	}
 	switch (ret) {
 	case 0:		/* success */
 		break;
diff --git a/kernel/trace/pid_list.c b/kernel/trace/pid_list.c
index a2ef1d18126a..ea0899f4340c 100644
--- a/kernel/trace/pid_list.c
+++ b/kernel/trace/pid_list.c
@@ -85,7 +85,9 @@ static inline bool upper_empty(union upper_chunk *chunk)
 	 * and if it doesn't find any bits set, then the array
 	 * is empty.
 	 */
-	int bit = find_first_bit((unsigned long *)chunk->data,
+	/* Play nice with the pointer deref checker */
+	unsigned long *chunk_data = (unsigned long *)chunk->data;
+	int bit = find_first_bit(chunk_data,
 				 sizeof(chunk->data) * 8);
 	return bit >= sizeof(chunk->data) * 8;
 }
diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c
index 53c32324635e..6ee6615a0c2f 100644
--- a/kernel/trace/trace.c
+++ b/kernel/trace/trace.c
@@ -8512,7 +8512,12 @@ ftrace_trace_snapshot_callback(struct trace_array *tr, struct ftrace_hash *hash,
 	 * We use the callback data field (which is a pointer)
 	 * as our counter.
 	 */
-	ret = kstrtoul(number, 0, (unsigned long *)&count);
+	/* Play nice with the pointer deref checker */
+	{
+		unsigned long count_ul = -1UL;
+		ret = kstrtoul(number, 0, &count_ul);
+		count = (void *)count_ul;
+	}
 	if (ret)
 		return ret;
 
diff --git a/kernel/trace/trace_functions.c b/kernel/trace/trace_functions.c
index 9f1bfbe105e8..f070e1e668c2 100644
--- a/kernel/trace/trace_functions.c
+++ b/kernel/trace/trace_functions.c
@@ -799,7 +799,7 @@ ftrace_trace_probe_callback(struct trace_array *tr,
 			    struct ftrace_hash *hash, char *glob,
 			    char *cmd, char *param, int enable)
 {
-	void *count = (void *)-1;
+	unsigned long count = -1UL;
 	char *number;
 	int ret;
 
@@ -822,12 +822,12 @@ ftrace_trace_probe_callback(struct trace_array *tr,
 	 * We use the callback data field (which is a pointer)
 	 * as our counter.
 	 */
-	ret = kstrtoul(number, 0, (unsigned long *)&count);
+	ret = kstrtoul(number, 0, &count);
 	if (ret)
 		return ret;
 
  out_reg:
-	ret = register_ftrace_function_probe(glob, tr, ops, count);
+	ret = register_ftrace_function_probe(glob, tr, ops, (void *)count);
 
 	return ret < 0 ? ret : 0;
 }
diff --git a/kernel/trace/trace_kprobe.c b/kernel/trace/trace_kprobe.c
index 33272a7b6912..189c2afff1f4 100644
--- a/kernel/trace/trace_kprobe.c
+++ b/kernel/trace/trace_kprobe.c
@@ -794,44 +794,50 @@ static int __trace_kprobe_create(int argc, const char *argv[])
 
 	/* try to parse an address. if that fails, try to read the
 	 * input as a symbol. */
-	if (kstrtoul(argv[1], 0, (unsigned long *)&addr)) {
-		trace_probe_log_set_index(1);
-		/* Check whether uprobe event specified */
-		if (strchr(argv[1], '/') && strchr(argv[1], ':')) {
-			ret = -ECANCELED;
-			goto error;
-		}
-		/* a symbol specified */
-		symbol = kstrdup(argv[1], GFP_KERNEL);
-		if (!symbol)
-			return -ENOMEM;
-
-		tmp = strchr(symbol, '%');
-		if (tmp) {
-			if (!strcmp(tmp, "%return")) {
-				*tmp = '\0';
-				is_return = true;
-			} else {
-				trace_probe_log_err(tmp - symbol, BAD_ADDR_SUFFIX);
-				goto parse_error;
+	{
+		/* Play nice with the pointer deref checker */
+		unsigned long addr_ul = 0;
+		if (kstrtoul(argv[1], 0, &addr_ul)) {
+			trace_probe_log_set_index(1);
+			/* Check whether uprobe event specified */
+			if (strchr(argv[1], '/') && strchr(argv[1], ':')) {
+				ret = -ECANCELED;
+				goto error;
+			}
+			/* a symbol specified */
+			symbol = kstrdup(argv[1], GFP_KERNEL);
+			if (!symbol)
+				return -ENOMEM;
+
+			tmp = strchr(symbol, '%');
+			if (tmp) {
+				if (!strcmp(tmp, "%return")) {
+					*tmp = '\0';
+					is_return = true;
+				} else {
+					trace_probe_log_err(tmp - symbol, BAD_ADDR_SUFFIX);
+					goto parse_error;
+				}
 			}
-		}
 
-		/* TODO: support .init module functions */
-		ret = traceprobe_split_symbol_offset(symbol, &offset);
-		if (ret || offset < 0 || offset > UINT_MAX) {
-			trace_probe_log_err(0, BAD_PROBE_ADDR);
-			goto parse_error;
-		}
-		if (is_return)
-			flags |= TPARG_FL_RETURN;
-		ret = kprobe_on_func_entry(NULL, symbol, offset);
-		if (ret == 0)
-			flags |= TPARG_FL_FENTRY;
-		/* Defer the ENOENT case until register kprobe */
-		if (ret == -EINVAL && is_return) {
-			trace_probe_log_err(0, BAD_RETPROBE);
-			goto parse_error;
+			/* TODO: support .init module functions */
+			ret = traceprobe_split_symbol_offset(symbol, &offset);
+			if (ret || offset < 0 || offset > UINT_MAX) {
+				trace_probe_log_err(0, BAD_PROBE_ADDR);
+				goto parse_error;
+			}
+			if (is_return)
+				flags |= TPARG_FL_RETURN;
+			ret = kprobe_on_func_entry(NULL, symbol, offset);
+			if (ret == 0)
+				flags |= TPARG_FL_FENTRY;
+			/* Defer the ENOENT case until register kprobe */
+			if (ret == -EINVAL && is_return) {
+				trace_probe_log_err(0, BAD_RETPROBE);
+				goto parse_error;
+			}
+		} else {
+			addr = (void *)addr_ul;
 		}
 	}
 
diff --git a/kernel/workqueue.c b/kernel/workqueue.c
index 8d16023dc325..cdaecaef4e73 100644
--- a/kernel/workqueue.c
+++ b/kernel/workqueue.c
@@ -4672,7 +4672,7 @@ EXPORT_SYMBOL_GPL(set_worker_desc);
  */
 void print_worker_info(const char *log_lvl, struct task_struct *task)
 {
-	work_func_t *fn = NULL;
+	work_func_t fn = NULL;
 	char name[WQ_NAME_LEN] = { };
 	char desc[WORKER_DESC_LEN] = { };
 	struct pool_workqueue *pwq = NULL;
diff --git a/mm/hugetlb.c b/mm/hugetlb.c
index abcd1785c629..7fe7be4e8f11 100644
--- a/mm/hugetlb.c
+++ b/mm/hugetlb.c
@@ -1628,8 +1628,12 @@ static void update_and_free_page(struct hstate *h, struct page *page,
 	 * empty. Otherwise, schedule_work() had been called but the workfn
 	 * hasn't retrieved the list yet.
 	 */
-	if (llist_add((struct llist_node *)&page->mapping, &hpage_freelist))
-		schedule_work(&free_hpage_work);
+	{
+		/* Play nice with the pointer deref checker */
+		struct llist_node *page_mapping = (struct llist_node *)&page->mapping;
+		if (llist_add(page_mapping, &hpage_freelist))
+			schedule_work(&free_hpage_work);
+	}
 }
 
 static void update_and_free_pages_bulk(struct hstate *h, struct list_head *list)
diff --git a/mm/memcontrol.c b/mm/memcontrol.c
index 6863a834ed42..bb0cb4c6e591 100644
--- a/mm/memcontrol.c
+++ b/mm/memcontrol.c
@@ -2821,7 +2821,7 @@ int memcg_alloc_page_obj_cgroups(struct page *page, struct kmem_cache *s,
 {
 	unsigned int objects = objs_per_slab_page(s, page);
 	unsigned long memcg_data;
-	void *vec;
+	struct obj_cgroup **vec;
 
 	gfp &= ~OBJCGS_CLEAR_MASK;
 	vec = kcalloc_node(objects, sizeof(struct obj_cgroup *), gfp,
diff --git a/mm/percpu-vm.c b/mm/percpu-vm.c
index 2054c9213c43..d57d59c22278 100644
--- a/mm/percpu-vm.c
+++ b/mm/percpu-vm.c
@@ -363,8 +363,11 @@ static void pcpu_destroy_chunk(struct pcpu_chunk *chunk)
 	pcpu_stats_chunk_dealloc();
 	trace_percpu_destroy_chunk(chunk->base_addr);
 
-	if (chunk->data)
-		pcpu_free_vm_areas(chunk->data, pcpu_nr_groups);
+	if (chunk->data) {
+		/* Play nice with the pointer deref checker */
+		struct vm_struct **vms = (struct vm_struct **)(chunk->data);
+		pcpu_free_vm_areas(vms, pcpu_nr_groups);
+	}
 	pcpu_free_chunk(chunk);
 }
 
diff --git a/mm/slub.c b/mm/slub.c
index db39f1ef0d4c..d6fa783e10eb 100644
--- a/mm/slub.c
+++ b/mm/slub.c
@@ -360,14 +360,16 @@ static void prefetch_freepointer(const struct kmem_cache *s, void *object)
 static inline void *get_freepointer_safe(struct kmem_cache *s, void *object)
 {
 	unsigned long freepointer_addr;
-	void *p;
+	void *p, **addr;
 
 	if (!debug_pagealloc_enabled_static())
 		return get_freepointer(s, object);
 
 	object = kasan_reset_tag(object);
 	freepointer_addr = (unsigned long)object + s->offset;
-	copy_from_kernel_nofault(&p, (void **)freepointer_addr, sizeof(p));
+	/* Play nice with the pointer deref checker */
+	addr = (void **)freepointer_addr;
+	copy_from_kernel_nofault(&p, addr, sizeof(p));
 	return freelist_ptr(s, p, freepointer_addr);
 }
 
diff --git a/net/core/drop_monitor.c b/net/core/drop_monitor.c
index 49442cae6f69..d4e8e0f5c83f 100644
--- a/net/core/drop_monitor.c
+++ b/net/core/drop_monitor.c
@@ -236,7 +236,9 @@ static void trace_drop_common(struct sk_buff *skb, void *location)
 	msg = nla_data(nla);
 	point = msg->points;
 	for (i = 0; i < msg->entries; i++) {
-		if (!memcmp(&location, &point->pc, sizeof(void *))) {
+		/* Play nice with the pointer deref checker */
+		void **msg_points_pc = (void **)(&point->pc);
+		if (!memcmp(&location, msg_points_pc, sizeof(void *))) {
 			point->count++;
 			goto out;
 		}
@@ -249,7 +251,11 @@ static void trace_drop_common(struct sk_buff *skb, void *location)
 	 */
 	__nla_reserve_nohdr(dskb, sizeof(struct net_dm_drop_point));
 	nla->nla_len += NLA_ALIGN(sizeof(struct net_dm_drop_point));
-	memcpy(point->pc, &location, sizeof(void *));
+	{
+		/* Play nice with the pointer deref checker */
+		void **msg_points_pc = (void **)(point->pc);
+		memcpy(msg_points_pc, &location, sizeof(void *));
+	}
 	point->count = 1;
 	msg->entries++;
 
diff --git a/net/core/sock_map.c b/net/core/sock_map.c
index f39ef79ced67..76302a39dfbd 100644
--- a/net/core/sock_map.c
+++ b/net/core/sock_map.c
@@ -422,7 +422,9 @@ static void sock_map_delete_from_link(struct bpf_map *map, struct sock *sk,
 {
 	struct bpf_stab *stab = container_of(map, struct bpf_stab, map);
 
-	__sock_map_delete(stab, sk, link_raw);
+	/* Play nice with the pointer deref checker */
+	struct sock **psk = (struct sock **)link_raw;
+	__sock_map_delete(stab, sk, psk);
 }
 
 static int sock_map_delete_elem(struct bpf_map *map, void *key)
diff --git a/net/phonet/socket.c b/net/phonet/socket.c
index 71e2caf6ab85..5da3c44f5369 100644
--- a/net/phonet/socket.c
+++ b/net/phonet/socket.c
@@ -735,8 +735,11 @@ static void *pn_res_seq_next(struct seq_file *seq, void *v, loff_t *pos)
 
 	if (v == SEQ_START_TOKEN)
 		sk = pn_res_get_idx(seq, 0);
-	else
-		sk = pn_res_get_next(seq, v);
+	else {
+		/* Play nice with the pointer deref checker */
+		struct sock **sk_v = (struct sock **)v;
+		sk = pn_res_get_next(seq, sk_v);
+	}
 	(*pos)++;
 	return sk;
 }
diff --git a/net/rxrpc/rxkad.c b/net/rxrpc/rxkad.c
index 258917a714c8..dee4e4d86ab3 100644
--- a/net/rxrpc/rxkad.c
+++ b/net/rxrpc/rxkad.c
@@ -63,7 +63,13 @@ static int rxkad_preparse_server_key(struct key_preparsed_payload *prep)
 	if (prep->datalen != 8)
 		return -EINVAL;
 
-	memcpy(&prep->payload.data[2], prep->data, 8);
+	{
+		/* Play nice with the pointer deref checker: the key is directly copied into
+		 * a field "void *data[4];" of union key_payload
+		 */
+		void *prep_payload = &prep->payload.data[2];
+		memcpy(prep_payload, prep->data, 8);
+	}
 
 	ci = crypto_alloc_skcipher("pcbc(des)", 0, CRYPTO_ALG_ASYNC);
 	if (IS_ERR(ci)) {
@@ -1003,7 +1009,13 @@ static int rxkad_decrypt_ticket(struct rxrpc_connection *conn,
 	ASSERT(server_key->payload.data[0] != NULL);
 	ASSERTCMP((unsigned long) ticket & 7UL, ==, 0);
 
-	memcpy(&iv, &server_key->payload.data[2], sizeof(iv));
+	{
+		/* Play nice with the pointer deref checker: the key is directly copied into
+		 * a field "void *data[4];" of union key_payload
+		 */
+		void *server_key_payload = &server_key->payload.data[2];
+		memcpy(&iv, server_key_payload, sizeof(iv));
+	}
 
 	ret = -ENOMEM;
 	req = skcipher_request_alloc(server_key->payload.data[0], GFP_NOFS);
diff --git a/scripts/Makefile.gcc-plugins b/scripts/Makefile.gcc-plugins
index 693e530faeae..aa80c5f4c02b 100644
--- a/scripts/Makefile.gcc-plugins
+++ b/scripts/Makefile.gcc-plugins
@@ -13,6 +13,8 @@ ifdef CONFIG_GCC_PLUGIN_PRINTK_FORMAT
   DISABLE_PRINTK_FORMAT_PLUGIN			+= -fplugin-arg-printk_format_plugin-disable
 endif
 
+gcc-plugin-$(CONFIG_GCC_PLUGIN_DEREF_CHECKER) += deref_checker_plugin.so
+
 gcc-plugin-$(CONFIG_GCC_PLUGIN_SANCOV)		+= sancov_plugin.so
 
 gcc-plugin-$(CONFIG_GCC_PLUGIN_STRUCTLEAK)	+= structleak_plugin.so
diff --git a/scripts/gcc-plugins/Kconfig b/scripts/gcc-plugins/Kconfig
index 3ff67bf8cee7..75fd83019bee 100644
--- a/scripts/gcc-plugins/Kconfig
+++ b/scripts/gcc-plugins/Kconfig
@@ -95,4 +95,10 @@ config GCC_PLUGIN_PRINTK_FORMAT
 	  Check printk format strings with kernel specs.
 	  This is complementary to -Wformat-security and -Wformat=2 flags.
 
+config GCC_PLUGIN_DEREF_CHECKER
+	bool "Check pointer derefecencing in function calls"
+	depends on GCC_PLUGINS
+	help
+	  Check function calls involving pointers about some consistencies.
+
 endif
diff --git a/scripts/gcc-plugins/deref_checker_plugin.c b/scripts/gcc-plugins/deref_checker_plugin.c
new file mode 100644
index 000000000000..fb2df862148e
--- /dev/null
+++ b/scripts/gcc-plugins/deref_checker_plugin.c
@@ -0,0 +1,487 @@
+/*
+ * Copyright 2016-2021 by Nicolas Iooss
+ * Licensed under the GPL v2, or (at your option) v3
+ *
+ * Check that pointer dereferencing is used consistently across function calls
+ */
+
+#include "gcc-common.h"
+
+int plugin_is_GPL_compatible;
+
+static struct plugin_info deref_checker_plugin_info = {
+	.version	= "20211121",
+	.help		= "Pointer dereferencing checker\n",
+};
+
+/**
+ * Identifier match helpers
+ */
+static bool identifier_is(const_tree identifier, const char *str)
+{
+	size_t len = strlen(str);
+
+	if (!identifier)
+		return false;
+
+	return IDENTIFIER_LENGTH(identifier) == len && !strncmp(str, IDENTIFIER_POINTER(identifier), len);
+}
+
+/**
+ * Get the number of pointers to a relevant data an expression holds
+ */
+static unsigned int get_pointer_depth(const_tree tree)
+{
+	unsigned int recursive_depth;
+
+	switch (TREE_CODE(tree)) {
+	case POINTER_TYPE:
+		recursive_depth = 1 + get_pointer_depth(TREE_TYPE(tree));
+		/* Remove 1 if the sub-type is an array because it is the way
+		 * vector dereferencing is stored.
+		 */
+		if (TREE_CODE(TREE_TYPE(tree)) == ARRAY_TYPE)
+			recursive_depth -= 1;
+		return recursive_depth;
+
+	case ARRAY_TYPE:
+		/* Unfold arrays so that char[6][7] counts as char[42] */
+		tree = TREE_TYPE(tree);
+		while (TREE_CODE(tree) == ARRAY_TYPE)
+			tree = TREE_TYPE(tree);
+		return 1 + get_pointer_depth(tree);
+
+	case VECTOR_TYPE:
+		return 1 + get_pointer_depth(TREE_TYPE(tree));
+
+	case BOOLEAN_TYPE:
+	case ENUMERAL_TYPE:
+	case FUNCTION_TYPE:
+	case INTEGER_TYPE:
+	case QUAL_UNION_TYPE:
+	case RECORD_TYPE:
+	case REAL_TYPE:
+	case UNION_TYPE:
+	case VOID_TYPE:
+		return 0;
+
+	case REFERENCE_TYPE:
+		/* for __va_list on ARM */
+		if (TREE_CODE(TREE_TYPE(tree)) == RECORD_TYPE && identifier_is(TYPE_IDENTIFIER(TREE_TYPE(tree)), "__va_list"))
+			return 1;
+		/* for __va_list on i686 */
+		if (TREE_CODE(TREE_TYPE(tree)) == POINTER_TYPE && identifier_is(TYPE_IDENTIFIER(TREE_TYPE(tree)), "__builtin_va_list"))
+			return 2;
+		break;
+	default:
+		break;
+	}
+
+	debug_tree(tree); /* TODO: better error reporting */
+	error(G_("unknown type for deref checker plugin!"));
+	return 0;
+}
+
+/**
+ * Whitelist some functions for the pointer checker
+ * TODO: function attribute?
+ */
+static bool is_whitelisted(const_tree fndecl, unsigned int argidx,
+			   unsigned int ptrdepth_type,  unsigned int ptrdepth_value)
+{
+	const_tree fnident = DECL_NAME(fndecl);
+
+	/* TODO: add a check for not void* in type, so that there are real bugs which appear (or just cast errors?) */
+
+	/* Many functions have their first argument a void* pointer */
+	if (identifier_is(fnident, "__builtin_memset") ||
+	    identifier_is(fnident, "__builtin_prefetch") ||
+	    identifier_is(fnident, "__kasan_check_write") ||
+	    identifier_is(fnident, "__kcsan_check_access") ||
+	    identifier_is(fnident, "__raw_readl") ||
+	    identifier_is(fnident, "__read_once_size") ||
+	    identifier_is(fnident, "__sync_cache_range_w") ||
+	    identifier_is(fnident, "__write_once_size") ||
+	    identifier_is(fnident, "ERR_CAST") ||
+	    identifier_is(fnident, "IS_ERR") ||
+	    identifier_is(fnident, "IS_ERR_OR_NULL") ||
+	    identifier_is(fnident, "PTR_ERR") ||
+	    identifier_is(fnident, "acpi_os_free") ||
+	    identifier_is(fnident, "bit_waitqueue") ||
+	    identifier_is(fnident, "bm_vk_free") ||
+	    identifier_is(fnident, "bpf_map_area_free") ||
+	    identifier_is(fnident, "cfs_percpt_free") ||
+	    identifier_is(fnident, "cfs_percpt_number") ||
+	    identifier_is(fnident, "choke_free") ||
+	    identifier_is(fnident, "clocksource_mmio_init") ||
+	    identifier_is(fnident, "cmpxchg_size") ||
+	    identifier_is(fnident, "devres_free") ||
+	    identifier_is(fnident, "drm_free_large") ||
+	    identifier_is(fnident, "ext4_kvfree_array_rcu") ||
+	    identifier_is(fnident, "i915_prandom_shuffle") ||
+	    identifier_is(fnident, "ice_get_free_slot") || /* it is on purpose */
+	    identifier_is(fnident, "instrument_atomic_write") ||
+	    identifier_is(fnident, "is_vmalloc_addr") ||
+	    identifier_is(fnident, "jhash") ||
+	    identifier_is(fnident, "free_percpu") ||
+	    identifier_is(fnident, "kasan_check_write") ||
+	    identifier_is(fnident, "kfree") ||
+	    identifier_is(fnident, "kfree_sensitive") ||
+	    identifier_is(fnident, "kmemdup") ||
+	    identifier_is(fnident, "kmemleak_alloc") ||
+	    identifier_is(fnident, "kmemleak_free") ||
+	    identifier_is(fnident, "kmemleak_not_leak") ||
+	    identifier_is(fnident, "kmem_free") ||
+	    identifier_is(fnident, "krealloc") ||
+	    identifier_is(fnident, "krealloc_array") ||
+	    identifier_is(fnident, "kvfree") ||
+	    identifier_is(fnident, "kzfree") ||
+	    identifier_is(fnident, "mem_dump_obj") ||
+	    identifier_is(fnident, "memblock_free") ||
+	    identifier_is(fnident, "memset") ||
+	    identifier_is(fnident, "memset32") ||
+	    identifier_is(fnident, "memset64") ||
+	    identifier_is(fnident, "memdup_user") ||
+	    identifier_is(fnident, "mempool_free") ||
+	    identifier_is(fnident, "pcpu_mem_free") ||
+	    identifier_is(fnident, "prefetch") ||
+	    identifier_is(fnident, "ptr_id") ||
+	    identifier_is(fnident, "scif_free") ||
+	    identifier_is(fnident, "sh_css_free") ||
+	    identifier_is(fnident, "skb_free_frag") ||
+	    identifier_is(fnident, "sort") ||
+	    identifier_is(fnident, "t4_free_mem") ||
+	    identifier_is(fnident, "vfree") ||
+	    identifier_is(fnident, "wake_up_bit") ||
+	    identifier_is(fnident, "ZSTD_customFree") ||
+	    false)
+		return argidx == 1 && ptrdepth_type < ptrdepth_value;
+
+	if (identifier_is(fnident, "__kfifo_in_r") || /* kfifo can be used to transmit pointers */
+	    identifier_is(fnident, "__kfifo_in") ||
+	    identifier_is(fnident, "__kfifo_init") ||
+	    identifier_is(fnident, "__kfifo_out") ||
+	    identifier_is(fnident, "__raw_writel") ||
+	    identifier_is(fnident, "bit_spin_is_locked") ||
+	    identifier_is(fnident, "bit_spin_lock") ||
+	    identifier_is(fnident, "bit_spin_unlock") ||
+	    identifier_is(fnident, "constant_test_bit") || /* even though there is a cast to unsigned long*, using &private_data (which is void**) is being reported */
+	    identifier_is(fnident, "arch___test_and_clear_bit") ||
+	    identifier_is(fnident, "arch___test_and_set_bit") ||
+	    identifier_is(fnident, "arch_test_bit") ||
+	    identifier_is(fnident, "_clear_bit") ||
+	    identifier_is(fnident, "clear_bit") ||
+	    identifier_is(fnident, "d_walk") ||
+	    identifier_is(fnident, "kmem_cache_free") ||
+	    identifier_is(fnident, "_set_bit") ||
+	    identifier_is(fnident, "set_bit") ||
+	    identifier_is(fnident, "test_bit") ||
+	    identifier_is(fnident, "free_percpu_irq") ||
+	    identifier_is(fnident, "set_page_objcgs") ||
+
+	    identifier_is(fnident, "device_for_each_child") || /* data for the callback */
+	    identifier_is(fnident, "device_for_each_child_reverse") || /* data for the callback */
+	    identifier_is(fnident, "devm_kfree") ||
+	    identifier_is(fnident, "devm_kmemdup") ||
+	    identifier_is(fnident, "devm_krealloc") ||
+	    identifier_is(fnident, "devres_add") || /* resource registered to the device */
+	    identifier_is(fnident, "device_find_child") || /* data for the callback */
+
+	    identifier_is(fnident, "irq_set_vcpu_affinity") ||
+
+	    identifier_is(fnident, "dup_param") ||
+	    identifier_is(fnident, "free_param") ||
+
+	    identifier_is(fnident, "iwl_fw_prph_handler") || /* private_data */
+
+	    identifier_is(fnident, "sock_map_unref") ||
+
+	    identifier_is(fnident, "bsearch") || /* data may contain pointers to pointers */
+	    identifier_is(fnident, "rhashtable_lookup_fast") ||
+	    identifier_is(fnident, "page_array_free") ||
+	    false)
+		return argidx == 2 && ptrdepth_type < ptrdepth_value;
+
+	if (identifier_is(fnident, "get_disp_fb") ||
+	    identifier_is(fnident, "get_free_fb"))
+		return argidx == 2 && ptrdepth_value == 1;
+
+	if (identifier_is(fnident, "acpi_walk_dep_device_list") ||
+	    identifier_is(fnident, "blkdev_get") || /* Third arg "holder" is a pointer to a stack variable */
+	    identifier_is(fnident, "blkdev_get_by_dev") ||
+	    identifier_is(fnident, "bus_for_each_dev") ||
+	    identifier_is(fnident, "driver_for_each_device") ||
+	    identifier_is(fnident, "drm_for_each_detailed_block") ||
+	    identifier_is(fnident, "flex_array_put") ||
+	    identifier_is(fnident, "hashtab_map") || /* args */
+	    identifier_is(fnident, "idr_for_each") ||
+	    identifier_is(fnident, "of_clk_add_provider") ||
+	    identifier_is(fnident, "pci_for_each_dma_alias") || /* private data */
+	    identifier_is(fnident, "single_open") ||
+	    identifier_is(fnident, "snd_seq_dump_var_event") || /* private_data */
+	    identifier_is(fnident, "twsk_unique") ||
+	    identifier_is(fnident, "devm_free_irq") ||
+	    identifier_is(fnident, "vdec_if_get_param") ||
+	    identifier_is(fnident, "vfio_pci_for_each_slot_or_bus") ||
+	    identifier_is(fnident, "walk_memory_blocks") ||
+	    false)
+		return argidx == 3 && ptrdepth_type < ptrdepth_value;
+
+	if (identifier_is(fnident, "debugfs_create_file") || /* Private data */
+	    identifier_is(fnident, "devres_destroy") ||
+	    identifier_is(fnident, "devres_find") ||
+	    identifier_is(fnident, "devres_release") || /* match_data */
+	    identifier_is(fnident, "dss_debugfs_create_file") ||
+	    identifier_is(fnident, "request_percpu_irq") ||
+	    identifier_is(fnident, "err_print_param") ||
+	    identifier_is(fnident, "seq_print_param") ||
+	    identifier_is(fnident, "sock_map_add_link") ||
+	    identifier_is(fnident, "_print_param") || /* third param is int* or char** */
+	    false)
+		return argidx == 4 && ptrdepth_type < ptrdepth_value;
+
+	if (identifier_is(fnident, "vdec_h264_get_fb"))
+		return argidx == 4 && ptrdepth_value == 1;
+
+	if (identifier_is(fnident, "_get_res") && argidx == 5 && ptrdepth_value == 2)
+		return true;
+
+	if (identifier_is(fnident, "param_free_charp") && argidx == 1 && ptrdepth_value == 2) /* This function waits for a char** but needs to have the prototype of free() */
+		return true;
+
+	if (identifier_is(fnident, "fetch_robust_entry") || /* compat_uptr_t __user * depth is 2 */
+	    identifier_is(fnident, "netdev_walk_all_lower_dev") ||
+	    identifier_is(fnident, "netdev_walk_all_lower_dev_rcu"))
+		return argidx == 3 && ptrdepth_value == 2;
+
+	/* lib/radix-tree.c does strange things */
+	if (identifier_is(fnident, "delete_sibling_entries") ||
+	    identifier_is(fnident, "node_to_entry") ||
+	    identifier_is(fnident, "radix_tree_is_internal_node"))
+		return argidx == 1 && ptrdepth_type < ptrdepth_value;
+
+	if (identifier_is(fnident, "i2c_for_each_dev")) /* data callback parameter */
+		return argidx == 1 && ptrdepth_type < ptrdepth_value;
+
+	if (identifier_is(fnident, "_i915_param_create_file"))
+		return argidx == 5 && ptrdepth_type < ptrdepth_value;
+
+/* automatic processing, TODO: review! */
+	if ((identifier_is(fnident, "__be64_to_cpup") && argidx == 1 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "__cq_dequeue") && argidx == 2 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "__install_special_mapping") && argidx == 5 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "__ocfs2_find_path") && argidx == 5 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "__test_and_clear_bit") && argidx == 2 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "__test_and_set_bit") && argidx == 2 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "__uvcg_iter_frm_intrv") && argidx == 4 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "__uvcg_iter_strm_cls") && argidx == 2 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "acpi_bus_get_device") && argidx == 1 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "acpi_get_physical_device_location") && argidx == 1 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "acpi_node_prop_read") && argidx == 4 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "acpi_rs_out_string") && argidx == 2 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "acpi_ut_trace_ptr") && argidx == 5 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "acpi_walk_namespace") && argidx == 6 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "acpi_walk_resources") && argidx == 4 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "alloc_ring") && argidx == 6 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "alloc_usemap_and_memmap") && argidx == 2 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "ath10k_wmi_tlv_iter") && argidx == 5 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "cfs_array_free") && argidx == 1 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "csio_enqueue_evt") && argidx == 3 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "cxgbi_free_big_mem") && argidx == 1 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "deactivate_slab") && argidx == 3 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "devm_request_irq") && argidx == 6 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "free_irq") && argidx == 2 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "gigaset_add_event") && argidx == 4 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "hlist_add_head") && argidx == 2 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "i2400m_zrealloc_2x") && argidx == 1 && ptrdepth_value == 3) ||
+	    (identifier_is(fnident, "ieee80211_iter_chan_contexts_atomic") && argidx == 3 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "iommu_group_for_each_dev") && argidx == 2 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "lbs_deb_hex") && argidx == 3 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "lustre_cfg_bufs_set") && argidx == 3 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "mgmt_pending_foreach") && argidx == 4 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "platform_device_add_data") && argidx == 2 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "platform_set_drvdata") && argidx == 2 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "pool_proc_next") && argidx == 2 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "rbd_img_request_fill") && argidx == 3 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "request_irq") && argidx == 5 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "set_freepointer") && argidx == 3 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "snd_pcm_hw_rule_add") && argidx == 5 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "trace_ocfs2_read_virt_blocks") && argidx == 4 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "ulist_add_merge") && argidx == 4 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "usb_acpi_get_connect_type") && argidx == 1 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "usb_control_msg") && argidx == 7 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "xenbus_grant_ring") && argidx == 2 && ptrdepth_value == 2) ||
+
+	    (identifier_is(fnident, "acpi_walk_namespace") && argidx == 7 && ptrdepth_value == 1) ||
+	    (identifier_is(fnident, "is_sibling_entry") && argidx == 2 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "entry_to_node") && argidx == 1 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "init_async_submit") && argidx == 6 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "ice_flow_add_entry") && argidx == 7 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "request_nmi") && argidx == 5 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "request_percpu_nmi") && argidx == 4 && ptrdepth_value == 2) ||
+	    false)
+		return true;
+
+	if (identifier_is(fnident, "__uvcg_iter_strm_cls"))
+		return argidx == 2 || argidx == 3; /* priv2 and priv3 */
+
+	if (identifier_is(fnident, "memcpy_with_cast"))
+		return argidx == 1 || argidx == 2;
+	if (identifier_is(fnident, "__xchg") ||
+	    identifier_is(fnident, "__cmpxchg"))
+		return argidx == 1 || argidx == 2;
+
+	if (identifier_is(fnident, "__builtin___ubsan_handle_divrem_overflow") ||
+	    identifier_is(fnident, "__builtin___ubsan_handle_shift_out_of_bounds"))
+		return ptrdepth_value == 0 && (argidx == 2 || argidx == 3); /* UBSAN built-in functions */
+	if (identifier_is(fnident, "__builtin___ubsan_handle_vla_bound_not_positive"))
+		return ptrdepth_value == 0 && argidx == 2; /* UBSAN built-in functions */
+
+	if (identifier_is(fnident, "do_execve_file"))
+		return (argidx == 2 || argidx == 3) && ptrdepth_value == 2; /* do_execve_file uses void* instead of char** */
+
+	if (identifier_is(fnident, "klp_shadow_alloc") ||
+	    identifier_is(fnident, "klp_shadow_get_or_alloc") ||
+	    identifier_is(fnident, "shadow_alloc") ||
+	    identifier_is(fnident, "shadow_get_or_alloc"))
+		return argidx == 6 && ptrdepth_value == 2;
+
+	if (identifier_is(fnident, "ath11k_wmi_tlv_iter"))
+		return argidx == 5 && ptrdepth_value == 2;
+
+	return false;
+}
+
+static unsigned int deref_checker_execute(void)
+{
+	basic_block bb;
+
+	FOR_EACH_BB_FN(bb, cfun) {
+		gimple_stmt_iterator gsi;
+
+		for (gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi)) {
+			gimple stmt;
+			gcall *call_stmt;
+			const_tree fndecl, arg_type;
+			unsigned int argidx;
+			function_args_iterator arg_iter;
+			bool expect_next_depth = false;
+			unsigned int expected_ptrdepth_type, expected_ptrdepth_value;
+
+			/* Get the statement */
+			stmt = gsi_stmt(gsi);
+			if (!is_gimple_call(stmt))
+				continue;
+			call_stmt = as_a_gcall(stmt);
+			/*debug_gimple_stmt(stmt);*/
+			//debug_tree(gimple_call_fn(stmt));
+
+			/* Get the function declaration */
+			fndecl = gimple_call_fndecl(stmt);
+			if (fndecl == NULL_TREE)
+				continue;
+
+			argidx = 1;
+			FOREACH_FUNCTION_ARGS(TREE_TYPE(fndecl), arg_type, arg_iter) {
+				const_tree arg_tree;
+				unsigned int ptrdepth_type, ptrdepth_value;
+
+				if (TREE_CODE(arg_type) == VOID_TYPE) {
+					/* End of function arguments */
+					if (argidx != 1 + gimple_call_num_args(call_stmt)) {
+						error(G_("Call to %qF with too many parameters"), fndecl);
+						break;
+					}
+					argidx++;
+					continue; /* the loop should exit by itself. Otherwise the error is caught later */
+				}
+
+				/* This should not happen */
+				if (argidx > gimple_call_num_args(call_stmt)) {
+					error(G_("Call to %qF with not enough parameters"), fndecl);
+					break;
+				}
+
+				ptrdepth_type = get_pointer_depth(arg_type);
+
+				arg_tree = gimple_call_arg(call_stmt, argidx - 1);
+				ptrdepth_value = get_pointer_depth(TREE_TYPE(arg_tree));
+
+				/* memcpy and memcmp are special as two pointers of the same depth may be used */
+				if (expect_next_depth) {
+					expect_next_depth = false;
+					/* This should not happen: memcmp has a known prototype */
+					if (ptrdepth_type != expected_ptrdepth_type) {
+						warning_at(
+							gimple_location(stmt), 0,
+							G_("Internal error while analyzing a call to %qF\n"),
+							fndecl);
+					}
+					if (ptrdepth_value != expected_ptrdepth_value) {
+/* debug_tree(arg_tree); */
+						warning_at(
+							gimple_location(stmt), 0,
+							G_("Invalid pointer depth in function call %qF: value of arg %u is %u, not expected %u\n"),
+							fndecl, argidx, ptrdepth_value, expected_ptrdepth_value);
+					}
+				} else if (argidx == 1 && (
+				    identifier_is(DECL_NAME(fndecl), "__builtin_memcmp") ||
+				    identifier_is(DECL_NAME(fndecl), "__builtin_memcpy") ||
+				    identifier_is(DECL_NAME(fndecl), "__memcpy") ||
+				    identifier_is(DECL_NAME(fndecl), "__same_pointer_depths_chk") ||
+				    identifier_is(DECL_NAME(fndecl), "__same_pointers_depths_with_volatile1_chk") ||
+				    identifier_is(DECL_NAME(fndecl), "__same_pointers_depths_with_volatile2_chk") ||
+				    identifier_is(DECL_NAME(fndecl), "bpf_long_memcpy") ||
+				    identifier_is(DECL_NAME(fndecl), "copy_from_kernel_nofault") ||
+				    identifier_is(DECL_NAME(fndecl), "copy_from_user") ||
+				    identifier_is(DECL_NAME(fndecl), "copy_to_user") ||
+				    identifier_is(DECL_NAME(fndecl), "memcmp") ||
+				    identifier_is(DECL_NAME(fndecl), "memcpy") ||
+				    identifier_is(DECL_NAME(fndecl), "memcpy_fromio") ||
+				    identifier_is(DECL_NAME(fndecl), "memcpy_toio") ||
+				    identifier_is(DECL_NAME(fndecl), "memmove") ||
+				    identifier_is(DECL_NAME(fndecl), "probe_kernel_read") ||
+				    identifier_is(DECL_NAME(fndecl), "probe_kernel_read_strict"))) {
+					expect_next_depth = true;
+					expected_ptrdepth_type = ptrdepth_type;
+					expected_ptrdepth_value = ptrdepth_value;
+				} else if (ptrdepth_type != ptrdepth_value && !is_whitelisted(fndecl, argidx, ptrdepth_type, ptrdepth_value)) {
+					warning_at(
+						gimple_location(stmt), 0,
+						G_("Invalid pointer depth in function call %qF: type of argument %u says %u but value is %u\n"),
+						fndecl, argidx, ptrdepth_type, ptrdepth_value);
+				}
+
+				argidx++;
+			}
+		}
+	}
+
+	return 0;
+}
+
+#define PASS_NAME deref_checker
+
+#define NO_GATE
+#define TODO_FLAGS_FINISH TODO_dump_func
+
+#include "gcc-generate-gimple-pass.h"
+
+int plugin_init(struct plugin_name_args *plugin_info, struct plugin_gcc_version *version)
+{
+	const char * const plugin_name = plugin_info->base_name;
+
+	PASS_INFO(deref_checker, "ssa", 1, PASS_POS_INSERT_AFTER);
+
+	if (!plugin_default_version_check(version, &gcc_version)) {
+		error(G_("incompatible gcc/plugin versions"));
+		return 1;
+	}
+
+	register_callback(plugin_name, PLUGIN_INFO, NULL,
+				&deref_checker_plugin_info);
+	register_callback(plugin_name, PLUGIN_PASS_MANAGER_SETUP, NULL,
+				&deref_checker_pass_info);
+
+	return 0;
+}
diff --git a/security/apparmor/apparmorfs.c b/security/apparmor/apparmorfs.c
index 0797edb2fb3d..2994b94826f6 100644
--- a/security/apparmor/apparmorfs.c
+++ b/security/apparmor/apparmorfs.c
@@ -701,8 +701,15 @@ static ssize_t query_data(char *buf, size_t buf_len,
 		if (!profile->data)
 			continue;
 
-		data = rhashtable_lookup_fast(profile->data, &key,
-					      profile->data->p);
+		{
+			/* Play nice with the pointer deref checker:
+			 * The hashtable key is a char** because strhash() used it and param.keylen = sizeof(void*)
+			 * So this usage is valid.
+			 */
+			const void *vkey = &key;
+			data = rhashtable_lookup_fast(profile->data, vkey,
+							  profile->data->p);
+		}
 
 		if (data) {
 			if (out + sizeof(outle32) + data->size > buf +
diff --git a/sound/core/pcm_native.c b/sound/core/pcm_native.c
index 621883e71194..9f51a18a5a0e 100644
--- a/sound/core/pcm_native.c
+++ b/sound/core/pcm_native.c
@@ -3160,7 +3160,7 @@ static int snd_pcm_xfern_frames_ioctl(struct snd_pcm_substream *substream,
 {
 	struct snd_xfern xfern;
 	struct snd_pcm_runtime *runtime = substream->runtime;
-	void *bufs;
+	void **bufs;
 	snd_pcm_sframes_t result;
 
 	if (runtime->status->state == SNDRV_PCM_STATE_OPEN)
-- 
