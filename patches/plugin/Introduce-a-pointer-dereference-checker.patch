From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Nicolas Iooss <nicolas.iooss_linux@m4x.org>
Date: Sat, 8 Oct 2016 14:45:13 +0200
Subject: [PATCH] {PLUGIN} Introduce a pointer dereference checker

This first version is a PoC draft which is not meant to go upstream.
This plugin addresses to problems which ought to be splitted in two
plugins: consistent calls to memcpy()-like functions (with two pointers
which would have the same "depth" but are void*), and bad use of & on a
pointer in a function taking void*. This second case leads to waaaay too
many false positives to be viable in the long run.

The main reason why with plugin is dirty is that it introduces a call to
__same_pointer_depths_chk() empty function at each memcpy/memove call,
so that even compiler-optimized code can be analyzed. A better approach
would be to attach the plugin to a pass where memcpy() calls have not
yet been optimized away. How is this done?

This plugins helped to detect the following bugs:
- 61ab0d403bbd ("ASoC: Intel: Atom: add a missing star in a memcpy
  call")
- ae6c33ba6e37 ("printk: fix parsing of "brl=" option")
- 238b323a681d ("libnvdimm, namespace: fix the type of name variable")

It has also detected some bugs reported and fixed by other people:
- 91c42b72f8e8 ("i40iw: Use correct src address in memcpy to rdma stats
  counters")
- eec11535ca3d ("hfs: fix hfs_readdir()")
- 7deea450eb91 ("bnxt_en: Fix population of flow_type in
  bnxt_hwrm_cfa_flow_alloc()")
---
 arch/Kconfig                                  |   6 +
 arch/arm/boot/compressed/decompress.c         |   2 +
 arch/arm/boot/compressed/string.c             |   7 +
 arch/arm/include/asm/string.h                 |  12 +
 arch/x86/boot/compressed/misc.c               |   4 +
 arch/x86/boot/compressed/string.c             |   5 +
 arch/x86/boot/string.h                        |   4 +
 arch/x86/events/core.c                        |   9 +-
 arch/x86/include/asm/string_32.h              |  22 +-
 arch/x86/include/asm/string_64.h              |  18 +
 arch/x86/lib/memcpy_32.c                      |   3 +
 arch/x86/math-emu/fpu_entry.c                 |   7 +-
 arch/x86/xen/enlighten_pv.c                   |   8 +-
 drivers/acpi/acpica/dspkginit.c               |   5 +-
 drivers/acpi/property.c                       |  10 +-
 drivers/base/property.c                       |   2 +-
 drivers/block/DAC960.c                        |   2 +-
 drivers/dma/ti/cppi41.c                       |   4 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c        |   2 +-
 drivers/gpu/drm/drm_bufs.c                    |   4 +-
 drivers/gpu/drm/i915/i915_gem_gtt.c           |   2 +-
 drivers/gpu/drm/radeon/radeon_cs.c            |   2 +-
 drivers/iio/industrialio-buffer.c             |   2 +-
 drivers/isdn/i4l/isdn_common.c                |   4 +-
 drivers/media/pci/intel/ipu3/ipu3-cio2.c      |   8 +-
 drivers/media/platform/omap/omap_vout.c       |   7 +-
 drivers/media/platform/omap3isp/ispstat.c     |   8 +-
 drivers/misc/ibmasm/lowlevel.c                |   4 +-
 drivers/misc/mic/scif/scif_fd.c               |   6 +-
 drivers/net/ethernet/ti/davinci_cpdma.c       |   2 +-
 drivers/net/virtio_net.c                      |   2 +-
 drivers/net/wireless/ti/wlcore/main.c         |  15 +-
 drivers/scsi/csiostor/csio_hw.c               |   6 +-
 drivers/scsi/pm8001/pm8001_ctl.c              |   4 +-
 drivers/scsi/pm8001/pm8001_hwi.c              |   2 +-
 .../staging/fsl-dpaa2/ethernet/dpaa2-eth.c    |   4 +-
 drivers/staging/gdm724x/hci_packet.h          |   2 +-
 .../staging/rtl8192e/rtl8192e/r8192E_cmdpkt.c |   2 +-
 drivers/staging/rtl8192e/rtl8192e/rtl_core.c  |   4 +-
 drivers/staging/rtl8192u/r8192U_core.c        |   2 +-
 drivers/staging/rtl8192u/r819xU_cmdpkt.c      |   2 +-
 drivers/staging/rtl8192u/r819xU_firmware.c    |   2 +-
 .../thermal/int340x_thermal/int3402_thermal.c |   2 +-
 drivers/usb/core/devio.c                      |  12 +-
 drivers/usb/dwc2/hcd.c                        |  16 +-
 drivers/usb/host/xhci-debugfs.c               |   4 +-
 drivers/xen/privcmd.c                         |  16 +-
 drivers/xen/xenbus/xenbus_xs.c                |   4 +-
 fs/cifs/cifsacl.c                             |  12 +-
 fs/exofs/ore_raid.c                           |   8 +-
 include/asm-generic/asm-prototypes.h          |   6 +
 include/linux/compiler.h                      |  23 +
 include/linux/string.h                        |  18 +
 include/sound/pcm.h                           |  16 +-
 include/trace/bpf_probe.h                     |   2 +-
 kernel/bpf/hashtab.c                          |   8 +-
 kernel/debug/kdb/kdb_support.c                |  10 +-
 kernel/trace/trace.c                          |   7 +-
 kernel/trace/trace_functions.c                |   6 +-
 kernel/trace/trace_kprobe.c                   |  32 +-
 kernel/workqueue.c                            |   2 +-
 mm/percpu-vm.c                                |   7 +-
 mm/slub.c                                     |   6 +-
 net/core/drop_monitor.c                       |  10 +-
 net/phonet/socket.c                           |   7 +-
 net/rxrpc/key.c                               |   2 +-
 net/rxrpc/rxkad.c                             |   2 +-
 net/sched/act_api.c                           |   4 +-
 scripts/Makefile.gcc-plugins                  |   2 +
 scripts/gcc-plugins/deref_checker_plugin.c    | 427 ++++++++++++++++++
 security/apparmor/apparmorfs.c                |  11 +-
 sound/core/pcm_native.c                       |   2 +-
 72 files changed, 802 insertions(+), 110 deletions(-)
 create mode 100644 scripts/gcc-plugins/deref_checker_plugin.c

diff --git a/arch/Kconfig b/arch/Kconfig
index c0f8d75e7b3c..0ba70cb471fb 100644
--- a/arch/Kconfig
+++ b/arch/Kconfig
@@ -556,6 +556,12 @@ config GCC_PLUGIN_PRINTK_FORMAT
 	  Check printk format strings with kernel specs.
 	  This is complementary to -Wformat-security and -Wformat=2 flags.
 
+config GCC_PLUGIN_DEREF_CHECKER
+	bool "Check pointer derefecencing in function calls"
+	depends on GCC_PLUGINS
+	help
+	  Check function calls involving pointers about some consistencies.
+
 config HAVE_STACKPROTECTOR
 	bool
 	help
diff --git a/arch/arm/boot/compressed/decompress.c b/arch/arm/boot/compressed/decompress.c
index c16c1829a5e4..bfe0e032070d 100644
--- a/arch/arm/boot/compressed/decompress.c
+++ b/arch/arm/boot/compressed/decompress.c
@@ -46,8 +46,10 @@ extern int memcmp(const void *cs, const void *ct, size_t count);
 #endif
 
 #ifdef CONFIG_KERNEL_XZ
+#ifndef CONFIG_GCC_PLUGIN_DEREF_CHECKER
 #define memmove memmove
 #define memcpy memcpy
+#endif
 #include "../../../../lib/decompress_unxz.c"
 #endif
 
diff --git a/arch/arm/boot/compressed/string.c b/arch/arm/boot/compressed/string.c
index ade5079bebbf..f6c58931d316 100644
--- a/arch/arm/boot/compressed/string.c
+++ b/arch/arm/boot/compressed/string.c
@@ -7,6 +7,13 @@
 
 #include <linux/string.h>
 
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+/* Disable definitions with __same_pointer_depths_chk */
+#undef memcmp
+#undef memcpy
+#undef memmove
+#endif
+
 void *memcpy(void *__dest, __const void *__src, size_t __n)
 {
 	int i = 0;
diff --git a/arch/arm/include/asm/string.h b/arch/arm/include/asm/string.h
index 111a1d8a41dd..d962f4dd8ff3 100644
--- a/arch/arm/include/asm/string.h
+++ b/arch/arm/include/asm/string.h
@@ -39,4 +39,16 @@ static inline void *memset64(uint64_t *p, uint64_t v, __kernel_size_t n)
 	return __memset64(p, v, n * 8, v >> 32);
 }
 
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+#define memcpy(t, f, l) ({ __same_pointer_depths_chk(t, f); memcpy(t, f, l); })
+#define memmove(t, f, l) ({ __same_pointer_depths_chk(t, f); memmove(t, f, l); })
+/* Tell the plugin that the difference is intentional */
+static noinline void *memcpy_with_cast(void *dest, const void *src, size_t count)
+{
+    return memcpy(dest, src, count);
+}
+#else
+#define memcpy_with_cast memcpy
+#endif
+
 #endif
diff --git a/arch/x86/boot/compressed/misc.c b/arch/x86/boot/compressed/misc.c
index 8dd1d5ccae58..08d9c84cedb1 100644
--- a/arch/x86/boot/compressed/misc.c
+++ b/arch/x86/boot/compressed/misc.c
@@ -36,6 +36,10 @@
 #undef memcpy
 #undef memset
 #define memzero(s, n)	memset((s), 0, (n))
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+/* The macro conflicts with the function definition below */
+#undef memmove
+#endif
 #define memmove		memmove
 
 /* Functions used by the included decompressor code below. */
diff --git a/arch/x86/boot/compressed/string.c b/arch/x86/boot/compressed/string.c
index 19dbbcdd1a53..e33d8e015362 100644
--- a/arch/x86/boot/compressed/string.c
+++ b/arch/x86/boot/compressed/string.c
@@ -10,6 +10,11 @@
 
 #include "../string.c"
 
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+#undef memcpy
+#undef memmove
+#endif
+
 #ifdef CONFIG_X86_32
 static void *__memcpy(void *dest, const void *src, size_t n)
 {
diff --git a/arch/x86/boot/string.h b/arch/x86/boot/string.h
index 8371f2e58fc1..808d0264e8cf 100644
--- a/arch/x86/boot/string.h
+++ b/arch/x86/boot/string.h
@@ -16,7 +16,11 @@ int memcmp(const void *s1, const void *s2, size_t len);
  * do "undef memcpy" in .c file and link against right string.c
  */
 #ifndef __clang__ /* PR18415 */
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+#define memcpy(d,s,l) ({ __same_pointer_depths_chk(d, s);__builtin_memcpy(d,s,l);})
+#else
 #define memcpy(d,s,l) __builtin_memcpy(d,s,l)
+#endif
 #define memset(d,c,l) __builtin_memset(d,c,l)
 #define memcmp	__builtin_memcmp
 #endif
diff --git a/arch/x86/events/core.c b/arch/x86/events/core.c
index 5f4829f10129..a4521ee7e335 100644
--- a/arch/x86/events/core.c
+++ b/arch/x86/events/core.c
@@ -2481,7 +2481,14 @@ perf_callchain_user(struct perf_callchain_entry_ctx *entry, struct pt_regs *regs
 		if (!valid_user_frame(fp, sizeof(frame)))
 			break;
 
-		bytes = __copy_from_user_nmi(&frame.next_frame, fp, sizeof(*fp));
+		/* make the pointer checker plugin happy about
+		 * copying userspace data into a pointer
+		 */
+		{
+			unsigned long next_frame;
+			bytes = __copy_from_user_nmi(&next_frame, fp, sizeof(*fp));
+			frame.next_frame = (struct stack_frame *)next_frame;
+		}
 		if (bytes != 0)
 			break;
 		bytes = __copy_from_user_nmi(&frame.return_address, fp + 1, sizeof(*fp));
diff --git a/arch/x86/include/asm/string_32.h b/arch/x86/include/asm/string_32.h
index 55d392c6bd29..05961ad4cdcb 100644
--- a/arch/x86/include/asm/string_32.h
+++ b/arch/x86/include/asm/string_32.h
@@ -33,6 +33,7 @@ extern size_t strlen(const char *s);
 static __always_inline void *__memcpy(void *to, const void *from, size_t n)
 {
 	int d0, d1, d2;
+	__same_pointer_depths_chk(to, from);
 	asm volatile("rep ; movsl\n\t"
 		     "movl %4,%%ecx\n\t"
 		     "andl $3,%%ecx\n\t"
@@ -53,6 +54,7 @@ static __always_inline void *__constant_memcpy(void *to, const void *from,
 					       size_t n)
 {
 	long esi, edi;
+	__same_pointer_depths_chk(to, from);
 	if (!n)
 		return to;
 
@@ -156,6 +158,7 @@ extern void *memcpy(void *, const void *, size_t);
 
 static inline void *__constant_memcpy3d(void *to, const void *from, size_t len)
 {
+	__same_pointer_depths_chk(to, from);
 	if (len < 512)
 		return __constant_memcpy(to, from, len);
 	return _mmx_memcpy(to, from, len);
@@ -163,15 +166,17 @@ static inline void *__constant_memcpy3d(void *to, const void *from, size_t len)
 
 static inline void *__memcpy3d(void *to, const void *from, size_t len)
 {
+	__same_pointer_depths_chk(to, from);
 	if (len < 512)
 		return __memcpy(to, from, len);
 	return _mmx_memcpy(to, from, len);
 }
 
 #define memcpy(t, f, n)				\
+	({ __same_pointer_depths_chk(t, f); \
 	(__builtin_constant_p((n))		\
 	 ? __constant_memcpy3d((t), (f), (n))	\
-	 : __memcpy3d((t), (f), (n)))
+	 : __memcpy3d((t), (f), (n)));})
 
 #else
 
@@ -180,17 +185,28 @@ static inline void *__memcpy3d(void *to, const void *from, size_t len)
  */
 
 #if (__GNUC__ >= 4)
-#define memcpy(t, f, n) __builtin_memcpy(t, f, n)
+#define memcpy(t, f, n) ({ __same_pointer_depths_chk(t, f); __builtin_memcpy(t, f, n);})
 #else
 #define memcpy(t, f, n)				\
+	({ __same_pointer_depths_chk(t, f); \
 	(__builtin_constant_p((n))		\
 	 ? __constant_memcpy((t), (f), (n))	\
-	 : __memcpy((t), (f), (n)))
+	 : __memcpy((t), (f), (n)));})
 #endif
 
 #endif
 #endif /* !CONFIG_FORTIFY_SOURCE */
 
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+/* Tell the plugin that the difference is intentional */
+static noinline void *memcpy_with_cast(void *dest, const void *src, size_t count)
+{
+    return memcpy(dest, src, count);
+}
+#else
+#define memcpy_with_cast memcpy
+#endif
+
 #define __HAVE_ARCH_MEMMOVE
 void *memmove(void *dest, const void *src, size_t n);
 
diff --git a/arch/x86/include/asm/string_64.h b/arch/x86/include/asm/string_64.h
index d33f92b9fa22..2122a2b00699 100644
--- a/arch/x86/include/asm/string_64.h
+++ b/arch/x86/include/asm/string_64.h
@@ -11,6 +11,7 @@
 static __always_inline void *__inline_memcpy(void *to, const void *from, size_t n)
 {
 	unsigned long d0, d1, d2;
+	__same_pointer_depths_chk(to, from);
 	asm volatile("rep ; movsl\n\t"
 		     "testb $2,%b4\n\t"
 		     "je 1f\n\t"
@@ -97,6 +98,19 @@ char *strcpy(char *dest, const char *src);
 char *strcat(char *dest, const char *src);
 int strcmp(const char *cs, const char *ct);
 
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+#define __memcmp(s, t, l) ({ __same_pointer_depths_chk(s, t); __memcmp(s, t, l); })
+#define __memcpy(t, f, l) ({ __same_pointer_depths_chk(t, f); __memcpy(t, f, l); })
+#define __memmove(t, f, l) ({ __same_pointer_depths_chk(t, f); __memmove(t, f, l); })
+/* Tell the plugin that the difference is intentional */
+static noinline void *memcpy_with_cast(void *dest, const void *src, size_t count)
+{
+    return memcpy(dest, src, count);
+}
+#else
+#define memcpy_with_cast memcpy
+#endif
+
 #if defined(CONFIG_KASAN) && !defined(__SANITIZE_ADDRESS__)
 
 /*
@@ -113,6 +127,10 @@ int strcmp(const char *cs, const char *ct);
 #define __NO_FORTIFY /* FORTIFY_SOURCE uses __builtin_memcpy, etc. */
 #endif
 
+#elif defined(CONFIG_GCC_PLUGIN_DEREF_CHECKER)
+#define memcmp(s, t, l) ({ __same_pointer_depths_chk(s, t); memcmp(s, t, l); })
+#define memcpy(t, f, l) ({ __same_pointer_depths_chk(t, f); memcpy(t, f, l); })
+#define memmove(t, f, l) ({ __same_pointer_depths_chk(t, f); memmove(t, f, l); })
 #endif
 
 #define __HAVE_ARCH_MEMCPY_MCSAFE 1
diff --git a/arch/x86/lib/memcpy_32.c b/arch/x86/lib/memcpy_32.c
index e565d1c9019e..9f95ef31c49f 100644
--- a/arch/x86/lib/memcpy_32.c
+++ b/arch/x86/lib/memcpy_32.c
@@ -4,6 +4,9 @@
 
 #undef memcpy
 #undef memset
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+#undef memmove
+#endif
 
 __visible void *memcpy(void *to, const void *from, size_t n)
 {
diff --git a/arch/x86/math-emu/fpu_entry.c b/arch/x86/math-emu/fpu_entry.c
index 9e2ba7e667f6..01f1120e68ab 100644
--- a/arch/x86/math-emu/fpu_entry.c
+++ b/arch/x86/math-emu/fpu_entry.c
@@ -114,6 +114,7 @@ void math_emulate(struct math_emu_info *info)
 	unsigned long code_limit = 0;	/* Initialized to stop compiler warnings */
 	struct desc_struct code_descriptor;
 	struct fpu *fpu = &current->thread.fpu;
+	u_char __user **peip;
 
 	fpu__initialize(fpu);
 
@@ -166,7 +167,8 @@ void math_emulate(struct math_emu_info *info)
 
 	FPU_lookahead = !(FPU_EFLAGS & X86_EFLAGS_TF);
 
-	if (!valid_prefix(&byte1, (u_char __user **) & FPU_EIP,
+	peip = (u_char __user **) & FPU_EIP;
+	if (!valid_prefix(&byte1, peip,
 			  &addr_modes.override)) {
 		RE_ENTRANT_CHECK_OFF;
 		printk
@@ -530,7 +532,8 @@ void math_emulate(struct math_emu_info *info)
 
 	if (FPU_lookahead && !need_resched()) {
 		FPU_ORIG_EIP = FPU_EIP - code_base;
-		if (valid_prefix(&byte1, (u_char __user **) & FPU_EIP,
+		peip = (u_char __user **) & FPU_EIP;
+		if (valid_prefix(&byte1, peip,
 				 &addr_modes.override))
 			goto do_another_FPU_instruction;
 	}
diff --git a/arch/x86/xen/enlighten_pv.c b/arch/x86/xen/enlighten_pv.c
index 439a94bf89ad..887582cfe1e5 100644
--- a/arch/x86/xen/enlighten_pv.c
+++ b/arch/x86/xen/enlighten_pv.c
@@ -649,8 +649,12 @@ static int cvt_gate_to_trap(int vector, const gate_desc *val,
 
 	addr = gate_offset(val);
 #ifdef CONFIG_X86_64
-	if (!get_trap_addr((void **)&addr, val->bits.ist))
-		return 0;
+	/* Play nice with the pointer deref checker */
+	{
+		void **paddr = (void **)&addr;
+		if (!get_trap_addr(paddr, val->bits.ist))
+			return 0;
+	}
 #endif	/* CONFIG_X86_64 */
 	info->address = addr;
 
diff --git a/drivers/acpi/acpica/dspkginit.c b/drivers/acpi/acpica/dspkginit.c
index d703a5594a02..e53c89f4dc9b 100644
--- a/drivers/acpi/acpica/dspkginit.c
+++ b/drivers/acpi/acpica/dspkginit.c
@@ -188,11 +188,12 @@ acpi_ds_build_internal_package_obj(struct acpi_walk_state *walk_state,
 				 * Forward references from module-level code are deferred
 				 * until all ACPI tables are loaded.
 				 */
+				/* Play nice with the pointer deref checker */
+				void *ctx = &obj_desc->package.elements[i];
 				acpi_ds_init_package_element(0,
 							     obj_desc->package.
 							     elements[i], NULL,
-							     &obj_desc->package.
-							     elements[i]);
+							     ctx);
 			}
 		}
 
diff --git a/drivers/acpi/property.c b/drivers/acpi/property.c
index 5815356ea6ad..345b6c5b74fe 100644
--- a/drivers/acpi/property.c
+++ b/drivers/acpi/property.c
@@ -863,9 +863,13 @@ static int acpi_data_prop_read(const struct acpi_device_data *data,
 		ret = acpi_copy_property_array_u64(items, (u64 *)val, nval);
 		break;
 	case DEV_PROP_STRING:
-		ret = acpi_copy_property_array_string(
-			items, (char **)val,
-			min_t(u32, nval, obj->package.count));
+		{
+			/* Play nice with the pointer deref checker */
+			char **valp = (char **)val;
+			ret = acpi_copy_property_array_string(
+				items, valp,
+				min_t(u32, nval, obj->package.count));
+		}
 		break;
 	default:
 		ret = -EINVAL;
diff --git a/drivers/base/property.c b/drivers/base/property.c
index 240ab5230ff6..f55a8466c06f 100644
--- a/drivers/base/property.c
+++ b/drivers/base/property.c
@@ -216,7 +216,7 @@ static int pset_prop_read_string_array(const struct property_set *pset,
 				       const char **strings, size_t nval)
 {
 	const struct property_entry *prop;
-	const void *pointer;
+	const char *const *pointer; /* Play nice with the pointer deref checker */
 	size_t array_len, length;
 
 	/* Find out the array length. */
diff --git a/drivers/block/DAC960.c b/drivers/block/DAC960.c
index 19d2a6be9666..0a071c42ebb3 100644
--- a/drivers/block/DAC960.c
+++ b/drivers/block/DAC960.c
@@ -3726,7 +3726,7 @@ static void DAC960_V1_ProcessCompletedCommand(DAC960_Command_T *Command)
 	      Controller->V1.PendingRebuildFlag = NewEnquiry->RebuildFlag;
 	      Controller->V1.RebuildFlagPending = true;
 	    }
-	  memcpy(&Controller->V1.Enquiry, &Controller->V1.NewEnquiry,
+	  memcpy(&Controller->V1.Enquiry, Controller->V1.NewEnquiry, /* BUG! */
 		 sizeof(DAC960_V1_Enquiry_T));
 	}
       else if (CommandOpcode == DAC960_V1_PerformEventLogOperation)
diff --git a/drivers/dma/ti/cppi41.c b/drivers/dma/ti/cppi41.c
index 1497da367710..a7c88fe00621 100644
--- a/drivers/dma/ti/cppi41.c
+++ b/drivers/dma/ti/cppi41.c
@@ -274,12 +274,12 @@ static struct cppi41_channel *desc_to_chan(struct cppi41_dd *cdd, u32 desc)
 	return c;
 }
 
-static void cppi_writel(u32 val, void *__iomem *mem)
+static void cppi_writel(u32 val, void __iomem *mem)
 {
 	__raw_writel(val, mem);
 }
 
-static u32 cppi_readl(void *__iomem *mem)
+static u32 cppi_readl(void __iomem *mem)
 {
 	return __raw_readl(mem);
 }
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c
index 9c85a90be293..8136ee830b9e 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c
@@ -115,7 +115,7 @@ static int amdgpu_cs_parser_init(struct amdgpu_cs_parser *p, void *data)
 	}
 
 	for (i = 0; i < p->nchunks; i++) {
-		struct drm_amdgpu_cs_chunk __user **chunk_ptr = NULL;
+		struct drm_amdgpu_cs_chunk __user *chunk_ptr = NULL; /* harmless BUG */
 		struct drm_amdgpu_cs_chunk user_chunk;
 		uint32_t __user *cdata;
 
diff --git a/drivers/gpu/drm/drm_bufs.c b/drivers/gpu/drm/drm_bufs.c
index ba8cfe65c65b..bfa3dbebeef3 100644
--- a/drivers/gpu/drm/drm_bufs.c
+++ b/drivers/gpu/drm/drm_bufs.c
@@ -1517,6 +1517,8 @@ static int map_one_buf(void *data, int idx, unsigned long virtual,
 {
 	struct drm_buf_map *request = data;
 	unsigned long address = virtual + buf->offset;	/* *** */
+	/* make the pointer checker plugin happy about copying an unsigned long to an void __user* */
+	unsigned long *preqaddr = (unsigned long *)&request->list[idx].address;
 
 	if (copy_to_user(&request->list[idx].idx, &buf->idx,
 			 sizeof(request->list[0].idx)))
@@ -1526,7 +1528,7 @@ static int map_one_buf(void *data, int idx, unsigned long virtual,
 		return -EFAULT;
 	if (clear_user(&request->list[idx].used, sizeof(int)))
 		return -EFAULT;
-	if (copy_to_user(&request->list[idx].address, &address,
+	if (copy_to_user(preqaddr, &address,
 			 sizeof(address)))
 		return -EFAULT;
 	return 0;
diff --git a/drivers/gpu/drm/i915/i915_gem_gtt.c b/drivers/gpu/drm/i915/i915_gem_gtt.c
index 996ab2ad6c45..734601238042 100644
--- a/drivers/gpu/drm/i915/i915_gem_gtt.c
+++ b/drivers/gpu/drm/i915/i915_gem_gtt.c
@@ -421,7 +421,7 @@ static struct page *vm_alloc_page(struct i915_address_space *vm, gfp_t gfp)
 		struct page **pages = stash.pages + stash.nr - nr;
 
 		if (nr && !set_pages_array_wc(pages, nr)) {
-			memcpy(pvec->pages + pvec->nr,
+			memcpy(&pvec->pages[pvec->nr], /* Like pvec->pages + pvec->nr but the pointer deref checker did not like? Maybe + transformed into a void* */
 			       pages, sizeof(pages[0]) * nr);
 			pvec->nr += nr;
 			stash.nr -= nr;
diff --git a/drivers/gpu/drm/radeon/radeon_cs.c b/drivers/gpu/drm/radeon/radeon_cs.c
index 1ae31dbc61c6..6713bcd46498 100644
--- a/drivers/gpu/drm/radeon/radeon_cs.c
+++ b/drivers/gpu/drm/radeon/radeon_cs.c
@@ -299,7 +299,7 @@ int radeon_cs_parser_init(struct radeon_cs_parser *p, void *data)
 		return -ENOMEM;
 	}
 	for (i = 0; i < p->nchunks; i++) {
-		struct drm_radeon_cs_chunk __user **chunk_ptr = NULL;
+		struct drm_radeon_cs_chunk __user *chunk_ptr = NULL;
 		struct drm_radeon_cs_chunk user_chunk;
 		uint32_t __user *cdata;
 
diff --git a/drivers/iio/industrialio-buffer.c b/drivers/iio/industrialio-buffer.c
index cd5bfe39591b..0877d039ab8b 100644
--- a/drivers/iio/industrialio-buffer.c
+++ b/drivers/iio/industrialio-buffer.c
@@ -1323,7 +1323,7 @@ int iio_buffer_alloc_sysfs_and_mask(struct iio_dev *indio_dev)
 		goto error_free_scan_mask;
 	}
 	if (buffer->scan_el_attrs)
-		memcpy(buffer->scan_el_group.attrs, buffer->scan_el_attrs,
+		memcpy(buffer->scan_el_group.attrs, buffer->scan_el_attrs->attrs, /* BUG? I did not understand this code */
 		       sizeof(buffer->scan_el_group.attrs[0])*attrcount_orig);
 	attrn = attrcount_orig;
 
diff --git a/drivers/isdn/i4l/isdn_common.c b/drivers/isdn/i4l/isdn_common.c
index 7a501dbe7123..f3c3bb1641a3 100644
--- a/drivers/isdn/i4l/isdn_common.c
+++ b/drivers/isdn/i4l/isdn_common.c
@@ -1641,7 +1641,9 @@ isdn_ioctl(struct file *file, uint cmd, ulong arg)
 				return -EINVAL;
 		case IIOCDBGVAR:
 			if (arg) {
-				if (copy_to_user(argp, &dev, sizeof(ulong)))
+				/* Make the pointer checker plugin happy about copying a pointer into a buffer */
+				ulong dev_value = (ulong)dev;
+				if (copy_to_user(argp, &dev_value, sizeof(ulong)))
 					return -EFAULT;
 				return 0;
 			} else
diff --git a/drivers/media/pci/intel/ipu3/ipu3-cio2.c b/drivers/media/pci/intel/ipu3/ipu3-cio2.c
index 29027159eced..777c2959bad9 100644
--- a/drivers/media/pci/intel/ipu3/ipu3-cio2.c
+++ b/drivers/media/pci/intel/ipu3/ipu3-cio2.c
@@ -1956,8 +1956,12 @@ static void cio2_fbpt_rearrange(struct cio2_device *cio2, struct cio2_queue *q)
 	if (j) {
 		arrange(q->fbpt, sizeof(struct cio2_fbpt_entry) * CIO2_MAX_LOPS,
 			CIO2_MAX_BUFFERS, j);
-		arrange(q->bufs, sizeof(struct cio2_buffer *),
-			CIO2_MAX_BUFFERS, j);
+		{
+			/* Play nice with the pointer deref checker */
+			void *q_bufs = q->bufs;
+			arrange(q_bufs, sizeof(struct cio2_buffer *),
+				CIO2_MAX_BUFFERS, j);
+		}
 	}
 
 	/*
diff --git a/drivers/media/platform/omap/omap_vout.c b/drivers/media/platform/omap/omap_vout.c
index 5700b7818621..6ad10f9c0b5e 100644
--- a/drivers/media/platform/omap/omap_vout.c
+++ b/drivers/media/platform/omap/omap_vout.c
@@ -776,8 +776,11 @@ static int omap_vout_buffer_prepare(struct videobuf_queue *q,
 		if (0 == vb->baddr)
 			return -EINVAL;
 		/* Physical address */
-		ret = omap_vout_get_userptr(vb, vb->baddr,
-				(u32 *)&vout->queued_buf_addr[vb->i]);
+		{
+			/* Play nice with the pointer deref checker */
+			u32 *addr = (u32 *)&vout->queued_buf_addr[vb->i];
+			ret = omap_vout_get_userptr(vb, vb->baddr, addr);
+		}
 		if (ret < 0)
 			return ret;
 	} else {
diff --git a/drivers/media/platform/omap3isp/ispstat.c b/drivers/media/platform/omap3isp/ispstat.c
index 47353fee26c3..8033f4bd455a 100644
--- a/drivers/media/platform/omap3isp/ispstat.c
+++ b/drivers/media/platform/omap3isp/ispstat.c
@@ -524,7 +524,13 @@ int omap3isp_stat_request_statistics_time32(struct ispstat *stat,
 
 	data->ts.tv_sec = data64.ts.tv_sec;
 	data->ts.tv_usec = data64.ts.tv_usec;
-	memcpy(&data->buf, &data64.buf, sizeof(*data) - sizeof(data->ts));
+	/* Replace a problematic memcpy with assignments, for the deref checker */
+	/*memcpy(&data->buf, &data64.buf, sizeof(*data) - sizeof(data->ts));*/
+	data->buf = (__u32)(uintptr_t)data64.buf;
+	data->buf_size = data64.buf_size;
+	data->frame_number = data64.frame_number;
+	data->cur_frame = data64.cur_frame;
+	data->config_counter = data64.config_counter;
 
 	return 0;
 }
diff --git a/drivers/misc/ibmasm/lowlevel.c b/drivers/misc/ibmasm/lowlevel.c
index 5319ea261c05..a1863712df83 100644
--- a/drivers/misc/ibmasm/lowlevel.c
+++ b/drivers/misc/ibmasm/lowlevel.c
@@ -47,7 +47,7 @@ int ibmasm_send_i2o_message(struct service_processor *sp)
 	message = get_i2o_message(sp->base_address, mfa);
 
 	memcpy_toio(&message->header, &header, sizeof(struct i2o_header));
-	memcpy_toio(&message->data, command->buffer, command_size);
+	memcpy_toio(message->data, command->buffer, command_size); /* BUG? */
 
 	set_mfa_inbound(sp->base_address, mfa);
 
@@ -74,7 +74,7 @@ irqreturn_t ibmasm_interrupt_handler(int irq, void * dev_id)
 	mfa = get_mfa_outbound(base_address);
 	if (valid_mfa(mfa)) {
 		struct i2o_message *msg = get_i2o_message(base_address, mfa);
-		ibmasm_receive_message(sp, &msg->data, incoming_data_size(msg));
+		ibmasm_receive_message(sp, msg->data, incoming_data_size(msg)); /* BUG? */
 	} else
 		dbg("didn't get a valid MFA\n");
 
diff --git a/drivers/misc/mic/scif/scif_fd.c b/drivers/misc/mic/scif/scif_fd.c
index 5c2a57ae4f85..9fc60e5cbf72 100644
--- a/drivers/misc/mic/scif/scif_fd.c
+++ b/drivers/misc/mic/scif/scif_fd.c
@@ -173,7 +173,11 @@ static long scif_fdioctl(struct file *f, unsigned int cmd, unsigned long arg)
 		struct list_head *pos, *tmpq;
 
 		/* Finally replace the pointer to the accepted endpoint */
-		if (copy_from_user(&newep, argp, sizeof(void *)))
+		/* Slient the pointer deref checker here even though the code looks strange:
+		 * how is the kernel pointer which is obtained by userspace sanitized?
+		 */
+		void *__user *argpp = (void *__user *)argp;
+		if (copy_from_user(&newep, argpp, sizeof(void *)))
 			return -EFAULT;
 
 		/* Remove form the user accept queue */
diff --git a/drivers/net/ethernet/ti/davinci_cpdma.c b/drivers/net/ethernet/ti/davinci_cpdma.c
index 4f1267477aa4..2192e38699cd 100644
--- a/drivers/net/ethernet/ti/davinci_cpdma.c
+++ b/drivers/net/ethernet/ti/davinci_cpdma.c
@@ -78,7 +78,7 @@ struct cpdma_desc {
 	u32			hw_len;
 	u32			hw_mode;
 	/* software fields */
-	void			*sw_token;
+	uintptr_t		sw_token;
 	u32			sw_buffer;
 	u32			sw_len;
 };
diff --git a/drivers/net/virtio_net.c b/drivers/net/virtio_net.c
index 53085c63277b..60056d636008 100644
--- a/drivers/net/virtio_net.c
+++ b/drivers/net/virtio_net.c
@@ -943,7 +943,7 @@ static struct sk_buff *receive_mergeable(struct net_device *dev,
 }
 
 static int receive_buf(struct virtnet_info *vi, struct receive_queue *rq,
-		       void *buf, unsigned int len, void **ctx,
+		       void *buf, unsigned int len, void *ctx, /* BUG? */
 		       unsigned int *xdp_xmit)
 {
 	struct net_device *dev = vi->dev;
diff --git a/drivers/net/wireless/ti/wlcore/main.c b/drivers/net/wireless/ti/wlcore/main.c
index 3a51ab116e79..93b67c074a8a 100644
--- a/drivers/net/wireless/ti/wlcore/main.c
+++ b/drivers/net/wireless/ti/wlcore/main.c
@@ -1477,7 +1477,20 @@ void wl1271_rx_filter_flatten_fields(struct wl12xx_rx_filter *filter,
 		field->flags = filter->fields[i].flags;
 		field->len = filter->fields[i].len;
 
-		memcpy(&field->pattern, filter->fields[i].pattern, field->len);
+		/* FIXME: how is it supposed to work?
+			struct wl12xx_rx_filter_field {
+				__le16 offset;
+				u8 len;
+				u8 flags;
+				u8 *pattern;
+			} __packed;
+		 * => offset to end of header (u8 pattern[0]) or allocated mem?
+		 * Let's guess that it is offset to end of header (need to check the allocation one day...)
+		 */
+		{
+			void *dst = &field->pattern;
+			memcpy(dst, filter->fields[i].pattern, field->len);
+		}
 		buf += sizeof(struct wl12xx_rx_filter_field) -
 			sizeof(u8 *) + field->len;
 	}
diff --git a/drivers/scsi/csiostor/csio_hw.c b/drivers/scsi/csiostor/csio_hw.c
index a10cf25ee7f9..8bb31527e77d 100644
--- a/drivers/scsi/csiostor/csio_hw.c
+++ b/drivers/scsi/csiostor/csio_hw.c
@@ -3911,7 +3911,11 @@ csio_evtq_worker(struct work_struct *work)
 				break;
 
 			case CSIO_EVT_DEV_LOSS:
-				memcpy(&rn, evt_msg->data, sizeof(rn));
+				{
+					/* Play nice with the pointer deref checker */
+					const struct csio_rnode **src = (const struct csio_rnode **)(evt_msg->data);
+					memcpy(&rn, src, sizeof(rn));
+				}
 				csio_rnode_devloss_handler(rn);
 				break;
 
diff --git a/drivers/scsi/pm8001/pm8001_ctl.c b/drivers/scsi/pm8001/pm8001_ctl.c
index d193961ea82f..c75929a87df4 100644
--- a/drivers/scsi/pm8001/pm8001_ctl.c
+++ b/drivers/scsi/pm8001/pm8001_ctl.c
@@ -591,7 +591,7 @@ static int pm8001_set_nvmd(struct pm8001_hba_info *pm8001_ha)
 		return -ENOMEM;
 	}
 	payload = (struct pm8001_ioctl_payload *)ioctlbuffer;
-	memcpy((u8 *)&payload->func_specific, (u8 *)pm8001_ha->fw_image->data,
+	memcpy((u8 *)payload->func_specific, (u8 *)pm8001_ha->fw_image->data, /* BUG? */
 				pm8001_ha->fw_image->size);
 	payload->length = pm8001_ha->fw_image->size;
 	payload->id = 0;
@@ -642,7 +642,7 @@ static int pm8001_update_flash(struct pm8001_hba_info *pm8001_ha)
 			payload->length = 1024*16;
 			payload->id = 0;
 			fwControl =
-			      (struct fw_control_info *)&payload->func_specific;
+			      (struct fw_control_info *)payload->func_specific; /* BUG? */
 			fwControl->len = IOCTL_BUF_SIZE;   /* IN */
 			fwControl->size = partitionSize + HEADER_LEN;/* IN */
 			fwControl->retcode = 0;/* OUT */
diff --git a/drivers/scsi/pm8001/pm8001_hwi.c b/drivers/scsi/pm8001/pm8001_hwi.c
index 4dd6cad330e8..94c46336737c 100644
--- a/drivers/scsi/pm8001/pm8001_hwi.c
+++ b/drivers/scsi/pm8001/pm8001_hwi.c
@@ -4840,7 +4840,7 @@ int pm8001_chip_set_nvmd_req(struct pm8001_hba_info *pm8001_ha,
 		return -ENOMEM;
 	circularQ = &pm8001_ha->inbnd_q_tbl[0];
 	memcpy(pm8001_ha->memoryMap.region[NVMD].virt_ptr,
-		&ioctl_payload->func_specific,
+		ioctl_payload->func_specific, /* BUG? */
 		ioctl_payload->length);
 	memset(&nvmd_req, 0, sizeof(nvmd_req));
 	rc = pm8001_tag_alloc(pm8001_ha, &tag);
diff --git a/drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.c b/drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.c
index 396371728aa1..fe0b36031f7d 100644
--- a/drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.c
+++ b/drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.c
@@ -566,7 +566,9 @@ static void free_tx_fd(const struct dpaa2_eth_priv *priv,
 	/* Get the timestamp value */
 	if (priv->tx_tstamp && skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP) {
 		struct skb_shared_hwtstamps shhwtstamps;
-		__le64 *ts = dpaa2_get_ts(skbh, true);
+		/* Play nice with the pointer deref checker */
+		void *skbh_voidp = skbh;
+		__le64 *ts = dpaa2_get_ts(skbh_voidp, true);
 		u64 ns;
 
 		memset(&shhwtstamps, 0, sizeof(shhwtstamps));
diff --git a/drivers/staging/gdm724x/hci_packet.h b/drivers/staging/gdm724x/hci_packet.h
index 83fbd2515467..ea706d340115 100644
--- a/drivers/staging/gdm724x/hci_packet.h
+++ b/drivers/staging/gdm724x/hci_packet.h
@@ -34,7 +34,7 @@ struct hci_packet {
 struct tlv {
 	u8 type;
 	u8 len;
-	u8 *data[1];
+	u8 data[0];
 } __packed;
 
 struct sdu_header {
diff --git a/drivers/staging/rtl8192e/rtl8192e/r8192E_cmdpkt.c b/drivers/staging/rtl8192e/rtl8192e/r8192E_cmdpkt.c
index 467287ae6c1c..f0a203d743dd 100644
--- a/drivers/staging/rtl8192e/rtl8192e/r8192E_cmdpkt.c
+++ b/drivers/staging/rtl8192e/rtl8192e/r8192E_cmdpkt.c
@@ -54,7 +54,7 @@ bool rtl92e_send_cmd_pkt(struct net_device *dev, u32 type, const void *data,
 			goto Failed;
 		}
 
-		memcpy((unsigned char *)(skb->cb), &dev, sizeof(dev));
+		memcpy_with_cast((unsigned char *)(skb->cb), &dev, sizeof(dev));
 		tcb_desc = (struct cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);
 		tcb_desc->queue_index = TXCMD_QUEUE;
 		tcb_desc->bCmdOrInit = type;
diff --git a/drivers/staging/rtl8192e/rtl8192e/rtl_core.c b/drivers/staging/rtl8192e/rtl8192e/rtl_core.c
index d2605158546b..ff4413434d77 100644
--- a/drivers/staging/rtl8192e/rtl8192e/rtl_core.c
+++ b/drivers/staging/rtl8192e/rtl8192e/rtl_core.c
@@ -1624,7 +1624,7 @@ static void _rtl92e_hard_data_xmit(struct sk_buff *skb, struct net_device *dev,
 		netdev_warn(dev, "%s(): queue index == TXCMD_QUEUE\n",
 			    __func__);
 
-	memcpy((unsigned char *)(skb->cb), &dev, sizeof(dev));
+	memcpy_with_cast((unsigned char *)(skb->cb), &dev, sizeof(dev));
 	skb_push(skb, priv->rtllib->tx_headroom);
 	ret = _rtl92e_tx(dev, skb);
 	if (ret != 0)
@@ -1653,7 +1653,7 @@ static int _rtl92e_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
 		}
 	}
 
-	memcpy((unsigned char *)(skb->cb), &dev, sizeof(dev));
+	memcpy_with_cast((unsigned char *)(skb->cb), &dev, sizeof(dev));
 	if (queue_index == TXCMD_QUEUE) {
 		_rtl92e_tx_cmd(dev, skb);
 		return 0;
diff --git a/drivers/staging/rtl8192u/r8192U_core.c b/drivers/staging/rtl8192u/r8192U_core.c
index 8b17400f6c13..0bf9c892bbf7 100644
--- a/drivers/staging/rtl8192u/r8192U_core.c
+++ b/drivers/staging/rtl8192u/r8192U_core.c
@@ -999,7 +999,7 @@ static int rtl8192_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
 
 	spin_lock_irqsave(&priv->tx_lock, flags);
 
-	memcpy((unsigned char *)(skb->cb), &dev, sizeof(dev));
+	memcpy_with_cast((unsigned char *)(skb->cb), &dev, sizeof(dev));
 	if (queue_index == TXCMD_QUEUE) {
 		skb_push(skb, USB_HWDESC_HEADER_LEN);
 		rtl819xU_tx_cmd(dev, skb);
diff --git a/drivers/staging/rtl8192u/r819xU_cmdpkt.c b/drivers/staging/rtl8192u/r819xU_cmdpkt.c
index 80672100ea26..fbc31048c7a3 100644
--- a/drivers/staging/rtl8192u/r819xU_cmdpkt.c
+++ b/drivers/staging/rtl8192u/r819xU_cmdpkt.c
@@ -39,7 +39,7 @@ rt_status SendTxCommandPacket(struct net_device *dev, void *pData, u32 DataLen)
 	skb  = dev_alloc_skb(USB_HWDESC_HEADER_LEN + DataLen + 4);
 	if (!skb)
 		return RT_STATUS_FAILURE;
-	memcpy((unsigned char *)(skb->cb), &dev, sizeof(dev));
+	memcpy_with_cast((unsigned char *)(skb->cb), &dev, sizeof(dev));
 	tcb_desc = (struct cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);
 	tcb_desc->queue_index = TXCMD_QUEUE;
 	tcb_desc->bCmdOrInit = DESC_PACKET_TYPE_NORMAL;
diff --git a/drivers/staging/rtl8192u/r819xU_firmware.c b/drivers/staging/rtl8192u/r819xU_firmware.c
index 9c7e19aedff1..9676f1a384f2 100644
--- a/drivers/staging/rtl8192u/r819xU_firmware.c
+++ b/drivers/staging/rtl8192u/r819xU_firmware.c
@@ -67,7 +67,7 @@ static bool fw_download_code(struct net_device *dev, u8 *code_virtual_address,
 		skb  = dev_alloc_skb(USB_HWDESC_HEADER_LEN + frag_length + 4);
 		if (!skb)
 			return false;
-		memcpy((unsigned char *)(skb->cb), &dev, sizeof(dev));
+		memcpy_with_cast((unsigned char *)(skb->cb), &dev, sizeof(dev));
 		tcb_desc = (struct cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);
 		tcb_desc->queue_index = TXCMD_QUEUE;
 		tcb_desc->bCmdOrInit = DESC_PACKET_TYPE_INIT;
diff --git a/drivers/thermal/int340x_thermal/int3402_thermal.c b/drivers/thermal/int340x_thermal/int3402_thermal.c
index 8e90b3151a42..93840a11f6ff 100644
--- a/drivers/thermal/int340x_thermal/int3402_thermal.c
+++ b/drivers/thermal/int340x_thermal/int3402_thermal.c
@@ -20,7 +20,7 @@
 #define INT3402_THERMAL_EVENT		0x90
 
 struct int3402_thermal_data {
-	acpi_handle *handle;
+	acpi_handle handle; /* harmless bug: too many stars */
 	struct int34x_thermal_zone *int340x_zone;
 };
 
diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 476dcc5f2da3..cae01e6cfe44 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -1893,12 +1893,13 @@ static struct async *reap_as(struct usb_dev_state *ps)
 static int proc_reapurb(struct usb_dev_state *ps, void __user *arg)
 {
 	struct async *as = reap_as(ps);
+	void __user * __user *parg = (void __user * __user *)arg;
 
 	if (as) {
 		int retval;
 
 		snoop(&ps->dev->dev, "reap %pK\n", as->userurb);
-		retval = processcompl(as, (void __user * __user *)arg);
+		retval = processcompl(as, parg);
 		free_async(as);
 		return retval;
 	}
@@ -1911,11 +1912,12 @@ static int proc_reapurbnonblock(struct usb_dev_state *ps, void __user *arg)
 {
 	int retval;
 	struct async *as;
+	void __user * __user *parg = (void __user * __user *)arg;
 
 	as = async_getcompleted(ps);
 	if (as) {
 		snoop(&ps->dev->dev, "reap %pK\n", as->userurb);
-		retval = processcompl(as, (void __user * __user *)arg);
+		retval = processcompl(as, parg);
 		free_async(as);
 	} else {
 		retval = (connected(ps) ? -EAGAIN : -ENODEV);
@@ -2036,12 +2038,13 @@ static int processcompl_compat(struct async *as, void __user * __user *arg)
 static int proc_reapurb_compat(struct usb_dev_state *ps, void __user *arg)
 {
 	struct async *as = reap_as(ps);
+	void __user * __user *parg = (void __user * __user *)arg;
 
 	if (as) {
 		int retval;
 
 		snoop(&ps->dev->dev, "reap %pK\n", as->userurb);
-		retval = processcompl_compat(as, (void __user * __user *)arg);
+		retval = processcompl_compat(as, parg);
 		free_async(as);
 		return retval;
 	}
@@ -2054,11 +2057,12 @@ static int proc_reapurbnonblock_compat(struct usb_dev_state *ps, void __user *ar
 {
 	int retval;
 	struct async *as;
+	void __user * __user *parg = (void __user * __user *)arg;
 
 	as = async_getcompleted(ps);
 	if (as) {
 		snoop(&ps->dev->dev, "reap %pK\n", as->userurb);
-		retval = processcompl_compat(as, (void __user * __user *)arg);
+		retval = processcompl_compat(as, parg);
 		free_async(as);
 	} else {
 		retval = (connected(ps) ? -EAGAIN : -ENODEV);
diff --git a/drivers/usb/dwc2/hcd.c b/drivers/usb/dwc2/hcd.c
index 6e2cdd7b93d4..48cd057eff67 100644
--- a/drivers/usb/dwc2/hcd.c
+++ b/drivers/usb/dwc2/hcd.c
@@ -2674,8 +2674,12 @@ static void dwc2_free_dma_aligned_buffer(struct urb *urb)
 		return;
 
 	/* Restore urb->transfer_buffer from the end of the allocated area */
-	memcpy(&stored_xfer_buffer, urb->transfer_buffer +
-	       urb->transfer_buffer_length, sizeof(urb->transfer_buffer));
+	{
+		/* Play nice with the pointer deref checker, as the code really wants to copy a pointer with memcpy */
+		void *p_stored_xfer_buffer = &stored_xfer_buffer;
+		memcpy(p_stored_xfer_buffer, urb->transfer_buffer +
+			   urb->transfer_buffer_length, sizeof(urb->transfer_buffer));
+	}
 
 	if (usb_urb_dir_in(urb)) {
 		if (usb_pipeisoc(urb->pipe))
@@ -2717,8 +2721,12 @@ static int dwc2_alloc_dma_aligned_buffer(struct urb *urb, gfp_t mem_flags)
 	 * Position value of original urb->transfer_buffer pointer to the end
 	 * of allocation for later referencing
 	 */
-	memcpy(kmalloc_ptr + urb->transfer_buffer_length,
-	       &urb->transfer_buffer, sizeof(urb->transfer_buffer));
+	{
+		/* Play nice with the pointer deref checker, as the code really wants to copy a pointer with memcpy */
+		void *p_urb_transient_buffer = &urb->transfer_buffer;
+		memcpy(kmalloc_ptr + urb->transfer_buffer_length,
+			   p_urb_transient_buffer, sizeof(urb->transfer_buffer));
+	}
 
 	if (usb_urb_dir_out(urb))
 		memcpy(kmalloc_ptr, urb->transfer_buffer,
diff --git a/drivers/usb/host/xhci-debugfs.c b/drivers/usb/host/xhci-debugfs.c
index cadc01336bf8..36ac2ecac626 100644
--- a/drivers/usb/host/xhci-debugfs.c
+++ b/drivers/usb/host/xhci-debugfs.c
@@ -413,10 +413,12 @@ static struct dentry *xhci_debugfs_create_ring_dir(struct xhci_hcd *xhci,
 						   struct dentry *parent)
 {
 	struct dentry		*dir;
+	/* Play nice with the pointer deref checker */
+	void *ring_ptr = ring;
 
 	dir = debugfs_create_dir(name, parent);
 	xhci_debugfs_create_files(xhci, ring_files, ARRAY_SIZE(ring_files),
-				  ring, dir, &xhci_ring_fops);
+				  ring_ptr, dir, &xhci_ring_fops);
 
 	return dir;
 }
diff --git a/drivers/xen/privcmd.c b/drivers/xen/privcmd.c
index 7e6e682104dc..56c1c5f8e66d 100644
--- a/drivers/xen/privcmd.c
+++ b/drivers/xen/privcmd.c
@@ -824,12 +824,16 @@ static long privcmd_ioctl_mmap_resource(struct file *file, void __user *udata)
 			DOMID_SELF : kdata.dom;
 		int num;
 
-		num = xen_remap_domain_mfn_array(vma,
-						 kdata.addr & PAGE_MASK,
-						 pfns, kdata.num, (int *)pfns,
-						 vma->vm_page_prot,
-						 domid,
-						 vma->vm_private_data);
+		{
+			/* Play nice with the pointer deref checker */
+			struct page **pages = vma->vm_private_data;
+			num = xen_remap_domain_mfn_array(vma,
+							 kdata.addr & PAGE_MASK,
+							 pfns, kdata.num, (int *)pfns,
+							 vma->vm_page_prot,
+							 domid,
+							 pages);
+		}
 		if (num < 0)
 			rc = num;
 		else if (num != kdata.num) {
diff --git a/drivers/xen/xenbus/xenbus_xs.c b/drivers/xen/xenbus/xenbus_xs.c
index 49a3874ae6bb..8eb0cbff0e34 100644
--- a/drivers/xen/xenbus/xenbus_xs.c
+++ b/drivers/xen/xenbus/xenbus_xs.c
@@ -403,7 +403,9 @@ static char **split(char *strings, unsigned int len, unsigned int *num)
 		kfree(strings);
 		return ERR_PTR(-ENOMEM);
 	}
-	memcpy(&ret[*num], strings, len);
+	/* Be nice with pointer deref checker: the ned of ret is char* */
+	p = (char *)&ret[*num];
+	memcpy(p, strings, len);
 	kfree(strings);
 
 	strings = (char *)&ret[*num];
diff --git a/fs/cifs/cifsacl.c b/fs/cifs/cifsacl.c
index 1d377b7f2860..267ced3d7d4a 100644
--- a/fs/cifs/cifsacl.c
+++ b/fs/cifs/cifsacl.c
@@ -426,16 +426,20 @@ sid_to_id(struct cifs_sb_info *cifs_sb, struct cifs_sid *psid,
 	}
 
 	if (sidtype == SIDOWNER) {
-		kuid_t uid;
+		kuid_t uid, *ppayload_uid;
 		uid_t id;
-		memcpy(&id, &sidkey->payload.data[0], sizeof(uid_t));
+		/* Play nice with the pointer deref checker */
+		ppayload_uid = (kuid_t *)&sidkey->payload.data[0];
+		memcpy(&id, ppayload_uid, sizeof(uid_t));
 		uid = make_kuid(&init_user_ns, id);
 		if (uid_valid(uid))
 			fuid = uid;
 	} else {
-		kgid_t gid;
+		kgid_t gid, *ppayload_gid;
 		gid_t id;
-		memcpy(&id, &sidkey->payload.data[0], sizeof(gid_t));
+		/* Play nice with the pointer deref checker */
+		ppayload_gid = (kgid_t *)&sidkey->payload.data[0];
+		memcpy(&id, ppayload_gid, sizeof(gid_t));
 		gid = make_kgid(&init_user_ns, id);
 		if (gid_valid(gid))
 			fgid = gid;
diff --git a/fs/exofs/ore_raid.c b/fs/exofs/ore_raid.c
index 199590f36203..c50a69170391 100644
--- a/fs/exofs/ore_raid.c
+++ b/fs/exofs/ore_raid.c
@@ -264,8 +264,12 @@ static void _gen_xor_unit(struct __stripe_pages_2d *sp2d)
 		if (!_1ps->write_count)
 			continue;
 
-		init_async_submit(&_1ps->submit, tx_flags,
-			NULL, NULL, NULL, (addr_conv_t *)_1ps->scribble);
+		/* Play nice with the pointer deref checker */
+		{
+			addr_conv_t *paddr = (addr_conv_t *)_1ps->scribble;
+			init_async_submit(&_1ps->submit, tx_flags,
+				NULL, NULL, NULL, paddr);
+		}
 
 		if (sp2d->parity == 1)
 			_1ps->tx = async_xor(_1ps->pages[sp2d->data_devs],
diff --git a/include/asm-generic/asm-prototypes.h b/include/asm-generic/asm-prototypes.h
index 2fa2bc208383..7c392857a3d3 100644
--- a/include/asm-generic/asm-prototypes.h
+++ b/include/asm-generic/asm-prototypes.h
@@ -12,3 +12,9 @@ extern void *memset(void *, int, __kernel_size_t);
 extern void *memcpy(void *, const void *, __kernel_size_t);
 #undef memmove
 extern void *memmove(void *, const void *, __kernel_size_t);
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+#define __memcpy(t, f, l) ({ __same_pointer_depths_chk(t, f); __memcpy(t, f, l); })
+#define __memmove(t, f, l) ({ __same_pointer_depths_chk(t, f); __memmove(t, f, l); })
+#define memcpy(t, f, l) ({ __same_pointer_depths_chk(t, f); memcpy(t, f, l); })
+#define memmove(t, f, l) ({ __same_pointer_depths_chk(t, f); memmove(t, f, l); })
+#endif
diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index 42506e4d1f53..5e4cd5c9251b 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -8,6 +8,27 @@
 
 #ifdef __KERNEL__
 
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+/* Make pointer deref checker able to check the consistency of optimized functions
+ *
+ * This is VERY ugly and a better way would be to insert the plugin before gcc
+ * inlines calls to memcpy, but I have not yet found how to do this.
+ */
+static noinline __used void __same_pointer_depths_chk(const void *p1, const void *p2)
+{
+}
+static noinline __used void __same_pointer_depths_with_volatile1_chk(const volatile void *p1, const void *p2)
+{
+}
+static noinline __used void __same_pointer_depths_with_volatile2_chk(const void *p1, const volatile void *p2)
+{
+}
+#else
+#define __same_pointer_depths_chk(p1, p2) do { } while (0)
+#define __same_pointer_depths_with_volatile1_chk(p1, p2) do { } while (0)
+#define __same_pointer_depths_with_volatile2_chk(p1, p2) do { } while (0)
+#endif
+
 /*
  * Note: DISABLE_BRANCH_PROFILING can be used by special lowlevel code
  * to disable branch tracing on a per file basis.
@@ -170,6 +191,7 @@ void ftrace_likely_update(struct ftrace_likely_data *f, int val,
 
 #define __READ_ONCE_SIZE						\
 ({									\
+	__same_pointer_depths_with_volatile1_chk(p, res);			\
 	switch (size) {							\
 	case 1: *(__u8 *)res = *(volatile __u8 *)p; break;		\
 	case 2: *(__u16 *)res = *(volatile __u16 *)p; break;		\
@@ -208,6 +230,7 @@ void __read_once_size_nocheck(const volatile void *p, void *res, int size)
 
 static __always_inline void __write_once_size(volatile void *p, void *res, int size)
 {
+	__same_pointer_depths_with_volatile1_chk(p, res);
 	switch (size) {
 	case 1: *(volatile __u8 *)p = *(__u8 *)res; break;
 	case 2: *(volatile __u16 *)p = *(__u16 *)res; break;
diff --git a/include/linux/string.h b/include/linux/string.h
index 2ac304b366f6..4a249e0f8ba2 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -141,7 +141,13 @@ extern void * memmove(void *,const void *,__kernel_size_t);
 extern void * memscan(void *,int,__kernel_size_t);
 #endif
 #ifndef __HAVE_ARCH_MEMCMP
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+#undef memcmp
+#endif
 extern int memcmp(const void *,const void *,__kernel_size_t);
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+#define memcmp(s, t, l) ({ __same_pointer_depths_chk(s, t); memcmp(s, t, l); })
+#endif
 #endif
 #ifndef __HAVE_ARCH_MEMCHR
 extern void * memchr(const void *,int,__kernel_size_t);
@@ -235,6 +241,12 @@ void __read_overflow2(void) __compiletime_error("detected read beyond size of ob
 void __read_overflow3(void) __compiletime_error("detected read beyond size of object passed as 3rd parameter");
 void __write_overflow(void) __compiletime_error("detected write beyond size of object passed as 1st parameter");
 
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+#undef memcmp
+#undef memcpy
+#undef memmove
+#endif
+
 #if !defined(__NO_FORTIFY) && defined(__OPTIMIZE__) && defined(CONFIG_FORTIFY_SOURCE)
 __FORTIFY_INLINE char *strncpy(char *p, const char *q, __kernel_size_t size)
 {
@@ -449,4 +461,10 @@ static inline void memcpy_and_pad(void *dest, size_t dest_len,
 		memcpy(dest, src, dest_len);
 }
 
+#ifdef CONFIG_GCC_PLUGIN_DEREF_CHECKER
+#define memcmp(s, t, l) ({ __same_pointer_depths_chk(s, t); memcmp(s, t, l); })
+#define memcpy(t, f, l) ({ __same_pointer_depths_chk(t, f); memcpy(t, f, l); })
+#define memmove(t, f, l) ({ __same_pointer_depths_chk(t, f); memmove(t, f, l); })
+#endif
+
 #endif /* _LINUX_STRING_H_ */
diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index e054c583d3b3..1ce98dca0efa 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -1103,14 +1103,18 @@ static inline snd_pcm_sframes_t
 snd_pcm_lib_writev(struct snd_pcm_substream *substream,
 		   void __user **bufs, snd_pcm_uframes_t frames)
 {
-	return __snd_pcm_lib_xfer(substream, (void *)bufs, false, frames, false);
+	/* make the pointer checker plugin happy about using a void** in a function taking void * */
+	void *pbufs = (void __force *)bufs;
+	return __snd_pcm_lib_xfer(substream, pbufs, false, frames, false);
 }
 
 static inline snd_pcm_sframes_t
 snd_pcm_lib_readv(struct snd_pcm_substream *substream,
 		  void __user **bufs, snd_pcm_uframes_t frames)
 {
-	return __snd_pcm_lib_xfer(substream, (void *)bufs, false, frames, false);
+	/* make the pointer checker plugin happy about using a void** in a function taking void * */
+	void *pbufs = (void __force *)bufs;
+	return __snd_pcm_lib_xfer(substream, pbufs, false, frames, false);
 }
 
 static inline snd_pcm_sframes_t
@@ -1131,14 +1135,18 @@ static inline snd_pcm_sframes_t
 snd_pcm_kernel_writev(struct snd_pcm_substream *substream,
 		      void **bufs, snd_pcm_uframes_t frames)
 {
-	return __snd_pcm_lib_xfer(substream, bufs, false, frames, true);
+	/* make the pointer checker plugin happy about using a void** in a function taking void * */
+	void *pbufs = bufs;
+	return __snd_pcm_lib_xfer(substream, pbufs, false, frames, true);
 }
 
 static inline snd_pcm_sframes_t
 snd_pcm_kernel_readv(struct snd_pcm_substream *substream,
 		     void **bufs, snd_pcm_uframes_t frames)
 {
-	return __snd_pcm_lib_xfer(substream, bufs, false, frames, true);
+	/* make the pointer checker plugin happy about using a void** in a function taking void * */
+	void *pbufs = bufs;
+	return __snd_pcm_lib_xfer(substream, pbufs, false, frames, true);
 }
 
 int snd_pcm_limit_hw_rates(struct snd_pcm_runtime *runtime);
diff --git a/include/trace/bpf_probe.h b/include/trace/bpf_probe.h
index 505dae0bed80..9c00fc275aeb 100644
--- a/include/trace/bpf_probe.h
+++ b/include/trace/bpf_probe.h
@@ -37,7 +37,7 @@
 #define __CAST_TO_U64(x) ({ \
 	typeof(x) __src = (x); \
 	UINTTYPE(sizeof(x)) __dst; \
-	memcpy(&__dst, &__src, sizeof(__dst)); \
+	memcpy_with_cast(&__dst, &__src, sizeof(__dst)); \
 	(u64)__dst; })
 
 #define __CAST1(a,...) __CAST_TO_U64(a)
diff --git a/kernel/bpf/hashtab.c b/kernel/bpf/hashtab.c
index 513d9dfcf4ee..55e997f69a12 100644
--- a/kernel/bpf/hashtab.c
+++ b/kernel/bpf/hashtab.c
@@ -1337,7 +1337,13 @@ int bpf_fd_htab_map_update_elem(struct bpf_map *map, struct file *map_file,
 	if (IS_ERR(ptr))
 		return PTR_ERR(ptr);
 
-	ret = htab_map_update_elem(map, key, &ptr, map_flags);
+	{
+		/* make the pointer checker plugin happy about using a void** value
+		 * (this is expected: the value is memcpy'ed into the hashtable)
+		 */
+		void *value_ptr = (void *)&ptr;
+		ret = htab_map_update_elem(map, key, value_ptr, map_flags);
+	}
 	if (ret)
 		map->ops->map_fd_put_ptr(ptr);
 
diff --git a/kernel/debug/kdb/kdb_support.c b/kernel/debug/kdb/kdb_support.c
index 990b3cc526c8..93157e126a3a 100644
--- a/kernel/debug/kdb/kdb_support.c
+++ b/kernel/debug/kdb/kdb_support.c
@@ -129,9 +129,13 @@ int kdbnearsym(unsigned long addr, kdb_symtab_t *symtab)
 		}
 		if (i >= ARRAY_SIZE(kdb_name_table)) {
 			debug_kfree(kdb_name_table[0]);
-			memmove(kdb_name_table, kdb_name_table+1,
-			       sizeof(kdb_name_table[0]) *
-			       (ARRAY_SIZE(kdb_name_table)-1));
+			{
+				/* For pointer checker */
+				void *target = kdb_name_table;
+				memmove(target, kdb_name_table+1,
+				        sizeof(kdb_name_table[0]) *
+				        (ARRAY_SIZE(kdb_name_table)-1));
+			}
 		} else {
 			debug_kfree(knt1);
 			knt1 = kdb_name_table[i];
diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c
index 823687997b01..8c57dfdfdb1f 100644
--- a/kernel/trace/trace.c
+++ b/kernel/trace/trace.c
@@ -7188,7 +7188,12 @@ ftrace_trace_snapshot_callback(struct trace_array *tr, struct ftrace_hash *hash,
 	 * We use the callback data field (which is a pointer)
 	 * as our counter.
 	 */
-	ret = kstrtoul(number, 0, (unsigned long *)&count);
+	/* Play nice with the pointer deref checker */
+	{
+		unsigned long count_ul = -1UL;
+		ret = kstrtoul(number, 0, &count_ul);
+		count = (void *)count_ul;
+	}
 	if (ret)
 		return ret;
 
diff --git a/kernel/trace/trace_functions.c b/kernel/trace/trace_functions.c
index b611cd36e22d..a38cbe9973e1 100644
--- a/kernel/trace/trace_functions.c
+++ b/kernel/trace/trace_functions.c
@@ -639,7 +639,7 @@ ftrace_trace_probe_callback(struct trace_array *tr,
 			    struct ftrace_hash *hash, char *glob,
 			    char *cmd, char *param, int enable)
 {
-	void *count = (void *)-1;
+	unsigned long count = -1UL;
 	char *number;
 	int ret;
 
@@ -662,12 +662,12 @@ ftrace_trace_probe_callback(struct trace_array *tr,
 	 * We use the callback data field (which is a pointer)
 	 * as our counter.
 	 */
-	ret = kstrtoul(number, 0, (unsigned long *)&count);
+	ret = kstrtoul(number, 0, &count);
 	if (ret)
 		return ret;
 
  out_reg:
-	ret = register_ftrace_function_probe(glob, tr, ops, count);
+	ret = register_ftrace_function_probe(glob, tr, ops, (void *)count);
 
 	return ret < 0 ? ret : 0;
 }
diff --git a/kernel/trace/trace_kprobe.c b/kernel/trace/trace_kprobe.c
index 6b71860f3998..2ec08d147eb7 100644
--- a/kernel/trace/trace_kprobe.c
+++ b/kernel/trace/trace_kprobe.c
@@ -759,19 +759,25 @@ static int create_trace_kprobe(int argc, char **argv)
 
 	/* try to parse an address. if that fails, try to read the
 	 * input as a symbol. */
-	if (kstrtoul(argv[1], 0, (unsigned long *)&addr)) {
-		/* a symbol specified */
-		symbol = argv[1];
-		/* TODO: support .init module functions */
-		ret = traceprobe_split_symbol_offset(symbol, &offset);
-		if (ret || offset < 0 || offset > UINT_MAX) {
-			pr_info("Failed to parse either an address or a symbol.\n");
-			return ret;
-		}
-		if (offset && is_return &&
-		    !kprobe_on_func_entry(NULL, symbol, offset)) {
-			pr_info("Given offset is not valid for return probe.\n");
-			return -EINVAL;
+	{
+		/* Play nice with the pointer deref checker */
+		unsigned long addr_ul = 0;
+		if (kstrtoul(argv[1], 0, &addr_ul)) {
+			/* a symbol specified */
+			symbol = argv[1];
+			/* TODO: support .init module functions */
+			ret = traceprobe_split_symbol_offset(symbol, &offset);
+			if (ret || offset < 0 || offset > UINT_MAX) {
+				pr_info("Failed to parse either an address or a symbol.\n");
+				return ret;
+			}
+			if (offset && is_return &&
+				!kprobe_on_func_entry(NULL, symbol, offset)) {
+				pr_info("Given offset is not valid for return probe.\n");
+				return -EINVAL;
+			}
+		} else {
+			addr = (void *)addr_ul;
 		}
 	}
 	argc -= 2; argv += 2;
diff --git a/kernel/workqueue.c b/kernel/workqueue.c
index 26ddb0c60e9c..74e40cdaa76b 100644
--- a/kernel/workqueue.c
+++ b/kernel/workqueue.c
@@ -4382,7 +4382,7 @@ EXPORT_SYMBOL_GPL(set_worker_desc);
  */
 void print_worker_info(const char *log_lvl, struct task_struct *task)
 {
-	work_func_t *fn = NULL;
+	work_func_t fn = NULL;
 	char name[WQ_NAME_LEN] = { };
 	char desc[WORKER_DESC_LEN] = { };
 	struct pool_workqueue *pwq = NULL;
diff --git a/mm/percpu-vm.c b/mm/percpu-vm.c
index d8078de912de..f298c4c884a3 100644
--- a/mm/percpu-vm.c
+++ b/mm/percpu-vm.c
@@ -362,8 +362,11 @@ static void pcpu_destroy_chunk(struct pcpu_chunk *chunk)
 	pcpu_stats_chunk_dealloc();
 	trace_percpu_destroy_chunk(chunk->base_addr);
 
-	if (chunk->data)
-		pcpu_free_vm_areas(chunk->data, pcpu_nr_groups);
+	if (chunk->data) {
+		/* Play nice with the pointer deref checker */
+		struct vm_struct **vms = (struct vm_struct **)(chunk->data);
+		pcpu_free_vm_areas(vms, pcpu_nr_groups);
+	}
 	pcpu_free_chunk(chunk);
 }
 
diff --git a/mm/slub.c b/mm/slub.c
index b2ee66a1f4e3..eb267e84df1a 100644
--- a/mm/slub.c
+++ b/mm/slub.c
@@ -278,13 +278,15 @@ static void prefetch_freepointer(const struct kmem_cache *s, void *object)
 static inline void *get_freepointer_safe(struct kmem_cache *s, void *object)
 {
 	unsigned long freepointer_addr;
-	void *p;
+	void *p, **addr;
 
 	if (!debug_pagealloc_enabled())
 		return get_freepointer(s, object);
 
 	freepointer_addr = (unsigned long)object + s->offset;
-	probe_kernel_read(&p, (void **)freepointer_addr, sizeof(p));
+	/* Play nice with the pointer deref checker */
+	addr = (void **)freepointer_addr;
+	probe_kernel_read(&p, addr, sizeof(p));
 	return freelist_ptr(s, p, freepointer_addr);
 }
 
diff --git a/net/core/drop_monitor.c b/net/core/drop_monitor.c
index c7785efeea57..95913c187d53 100644
--- a/net/core/drop_monitor.c
+++ b/net/core/drop_monitor.c
@@ -173,7 +173,9 @@ static void trace_drop_common(struct sk_buff *skb, void *location)
 	nla = genlmsg_data(nlmsg_data(nlh));
 	msg = nla_data(nla);
 	for (i = 0; i < msg->entries; i++) {
-		if (!memcmp(&location, msg->points[i].pc, sizeof(void *))) {
+		/* Play nice with the pointer deref checker */
+		void **msg_points_pc = (void **)(msg->points[i].pc);
+		if (!memcmp(&location, msg_points_pc, sizeof(void *))) {
 			msg->points[i].count++;
 			goto out;
 		}
@@ -185,7 +187,11 @@ static void trace_drop_common(struct sk_buff *skb, void *location)
 	 */
 	__nla_reserve_nohdr(dskb, sizeof(struct net_dm_drop_point));
 	nla->nla_len += NLA_ALIGN(sizeof(struct net_dm_drop_point));
-	memcpy(msg->points[msg->entries].pc, &location, sizeof(void *));
+	{
+		/* Play nice with the pointer deref checker */
+		void **msg_points_pc = (void **)(msg->points[msg->entries].pc);
+		memcpy(msg_points_pc, &location, sizeof(void *));
+	}
 	msg->points[msg->entries].count = 1;
 	msg->entries++;
 
diff --git a/net/phonet/socket.c b/net/phonet/socket.c
index 30187990257f..39b7450debf8 100644
--- a/net/phonet/socket.c
+++ b/net/phonet/socket.c
@@ -759,8 +759,11 @@ static void *pn_res_seq_next(struct seq_file *seq, void *v, loff_t *pos)
 
 	if (v == SEQ_START_TOKEN)
 		sk = pn_res_get_idx(seq, 0);
-	else
-		sk = pn_res_get_next(seq, v);
+	else {
+		/* Play nice with the pointer deref checker */
+		struct sock **sk_v = (struct sock **)v;
+		sk = pn_res_get_next(seq, sk_v);
+	}
 	(*pos)++;
 	return sk;
 }
diff --git a/net/rxrpc/key.c b/net/rxrpc/key.c
index e7f6b8823eb6..763e06d2409f 100644
--- a/net/rxrpc/key.c
+++ b/net/rxrpc/key.c
@@ -843,7 +843,7 @@ static int rxrpc_preparse_s(struct key_preparsed_payload *prep)
 	if (prep->datalen != 8)
 		return -EINVAL;
 
-	memcpy(&prep->payload.data[2], prep->data, 8);
+	memcpy_with_cast(&prep->payload.data[2], prep->data, 8); /* I did not understand this */
 
 	ci = crypto_alloc_skcipher("pcbc(des)", 0, CRYPTO_ALG_ASYNC);
 	if (IS_ERR(ci)) {
diff --git a/net/rxrpc/rxkad.c b/net/rxrpc/rxkad.c
index 06272af208df..71c87846baa4 100644
--- a/net/rxrpc/rxkad.c
+++ b/net/rxrpc/rxkad.c
@@ -895,7 +895,7 @@ static int rxkad_decrypt_ticket(struct rxrpc_connection *conn,
 	ASSERT(conn->server_key->payload.data[0] != NULL);
 	ASSERTCMP((unsigned long) ticket & 7UL, ==, 0);
 
-	memcpy(&iv, &conn->server_key->payload.data[2], sizeof(iv));
+	memcpy_with_cast(&iv, &conn->server_key->payload.data[2], sizeof(iv)); /* I did not understand this */
 
 	ret = -ENOMEM;
 	req = skcipher_request_alloc(conn->server_key->payload.data[0],
diff --git a/net/sched/act_api.c b/net/sched/act_api.c
index 3f4cf930f809..2872edaed678 100644
--- a/net/sched/act_api.c
+++ b/net/sched/act_api.c
@@ -1355,7 +1355,9 @@ tcf_action_egdev_lookup(const struct net_device *dev)
 	struct net *net = dev_net(dev);
 	struct tcf_action_net *tan = net_generic(net, tcf_action_net_id);
 
-	return rhashtable_lookup_fast(&tan->egdev_ht, &dev,
+	/* Play nice with the pointer deref checker */
+	void *key_dev = &dev;
+	return rhashtable_lookup_fast(&tan->egdev_ht, key_dev,
 				      tcf_action_egdev_ht_params);
 }
 
diff --git a/scripts/Makefile.gcc-plugins b/scripts/Makefile.gcc-plugins
index 5975a384f944..8d1a65d2e89d 100644
--- a/scripts/Makefile.gcc-plugins
+++ b/scripts/Makefile.gcc-plugins
@@ -12,6 +12,8 @@ ifdef CONFIG_GCC_PLUGIN_PRINTK_FORMAT
   DISABLE_PRINTK_FORMAT_PLUGIN			+= -fplugin-arg-printk_format_plugin-disable
 endif
 
+gcc-plugin-$(CONFIG_GCC_PLUGIN_DEREF_CHECKER) += deref_checker_plugin.so
+
 gcc-plugin-$(CONFIG_GCC_PLUGIN_SANCOV)		+= sancov_plugin.so
 gcc-plugin-$(CONFIG_GCC_PLUGIN_STRUCTLEAK)	+= structleak_plugin.so
 gcc-plugin-cflags-$(CONFIG_GCC_PLUGIN_STRUCTLEAK_VERBOSE)	+= -fplugin-arg-structleak_plugin-verbose
diff --git a/scripts/gcc-plugins/deref_checker_plugin.c b/scripts/gcc-plugins/deref_checker_plugin.c
new file mode 100644
index 000000000000..ab5d8d64d22e
--- /dev/null
+++ b/scripts/gcc-plugins/deref_checker_plugin.c
@@ -0,0 +1,427 @@
+/*
+ * Copyright 2016-2018 by Nicolas Iooss
+ * Licensed under the GPL v2, or (at your option) v3
+ *
+ * Check that pointer dereferencing is used consistently across function calls
+ */
+
+#include "gcc-common.h"
+
+int plugin_is_GPL_compatible;
+
+static struct plugin_info deref_checker_plugin_info = {
+	.version	= "20180609",
+	.help		= "Pointer dereferencing checker\n",
+};
+
+/**
+ * Identifier match helpers
+ */
+static bool identifier_is(const_tree identifier, const char *str)
+{
+	size_t len = strlen(str);
+
+	if (!identifier)
+		return false;
+
+	return IDENTIFIER_LENGTH(identifier) == len && !strncmp(str, IDENTIFIER_POINTER(identifier), len);
+}
+
+/**
+ * Get the number of pointers to a relevant data an expression holds
+ */
+static unsigned int get_pointer_depth(const_tree tree)
+{
+	unsigned int recursive_depth;
+
+	switch (TREE_CODE(tree)) {
+	case POINTER_TYPE:
+		recursive_depth = 1 + get_pointer_depth(TREE_TYPE(tree));
+		/* Remove 1 if the sub-type is an array because it is the way
+		 * vector dereferencing is stored.
+		 */
+		if (TREE_CODE(TREE_TYPE(tree)) == ARRAY_TYPE)
+			recursive_depth -= 1;
+		return recursive_depth;
+
+	case ARRAY_TYPE:
+		/* Unfold arrays so that char[6][7] counts as char[42] */
+		tree = TREE_TYPE(tree);
+		while (TREE_CODE(tree) == ARRAY_TYPE)
+			tree = TREE_TYPE(tree);
+		return 1 + get_pointer_depth(tree);
+
+	case VECTOR_TYPE:
+		return 1 + get_pointer_depth(TREE_TYPE(tree));
+
+	case BOOLEAN_TYPE:
+	case ENUMERAL_TYPE:
+	case FUNCTION_TYPE:
+	case INTEGER_TYPE:
+	case QUAL_UNION_TYPE:
+	case RECORD_TYPE:
+	case REAL_TYPE:
+	case UNION_TYPE:
+	case VOID_TYPE:
+		return 0;
+
+	case REFERENCE_TYPE:
+		/* for __va_list on ARM */
+		if (TREE_CODE(TREE_TYPE(tree)) == RECORD_TYPE && identifier_is(TYPE_IDENTIFIER(TREE_TYPE(tree)), "__va_list"))
+			return 1;
+		/* for __va_list on i686 */
+		if (TREE_CODE(TREE_TYPE(tree)) == POINTER_TYPE && identifier_is(TYPE_IDENTIFIER(TREE_TYPE(tree)), "__builtin_va_list"))
+			return 1;
+	}
+
+	debug_tree(tree); /* TODO: better error reporting */
+	error(G_("unknown type for deref checker plugin!"));
+	return 0;
+}
+
+/**
+ * Whitelist some functions for the pointer checker
+ * TODO: function attribute?
+ */
+static bool is_whitelisted(const_tree fndecl, unsigned int argidx,
+			   unsigned int ptrdepth_type,  unsigned int ptrdepth_value)
+{
+	const_tree fnident = DECL_NAME(fndecl);
+
+	/* TODO: add a check for not void* in type, so that there are real bugs which appear (or just cast errors?) */
+
+	/* Many functions have their first argument a void* pointer */
+	if (identifier_is(fnident, "__builtin_memset") ||
+	    identifier_is(fnident, "__builtin_prefetch") ||
+	    identifier_is(fnident, "__raw_readl") ||
+	    identifier_is(fnident, "__read_once_size") ||
+	    identifier_is(fnident, "__sync_cache_range_w") ||
+	    identifier_is(fnident, "__write_once_size") ||
+	    identifier_is(fnident, "ERR_CAST") ||
+	    identifier_is(fnident, "IS_ERR") ||
+	    identifier_is(fnident, "IS_ERR_OR_NULL") ||
+	    identifier_is(fnident, "PTR_ERR") ||
+	    identifier_is(fnident, "acpi_os_free") ||
+	    identifier_is(fnident, "bit_waitqueue") ||
+	    identifier_is(fnident, "bm_vk_free") ||
+	    identifier_is(fnident, "bpf_map_area_free") ||
+	    identifier_is(fnident, "cfs_percpt_free") ||
+	    identifier_is(fnident, "cfs_percpt_number") ||
+	    identifier_is(fnident, "choke_free") ||
+	    identifier_is(fnident, "clocksource_mmio_init") ||
+	    identifier_is(fnident, "cmpxchg_size") ||
+	    identifier_is(fnident, "devres_free") ||
+	    identifier_is(fnident, "drm_free_large") ||
+	    identifier_is(fnident, "ice_get_free_slot") || /* it is on purpose */
+	    identifier_is(fnident, "is_vmalloc_addr") ||
+	    identifier_is(fnident, "jhash") ||
+	    identifier_is(fnident, "free_percpu") ||
+	    identifier_is(fnident, "kfree") ||
+	    identifier_is(fnident, "kmemdup") ||
+	    identifier_is(fnident, "kmemleak_alloc") ||
+	    identifier_is(fnident, "kmemleak_free") ||
+	    identifier_is(fnident, "kmem_free") ||
+	    identifier_is(fnident, "krealloc") ||
+	    identifier_is(fnident, "kvfree") ||
+	    identifier_is(fnident, "kzfree") ||
+	    identifier_is(fnident, "memset") ||
+	    identifier_is(fnident, "memset32") ||
+	    identifier_is(fnident, "memset64") ||
+	    identifier_is(fnident, "memdup_user") ||
+	    identifier_is(fnident, "mempool_free") ||
+	    identifier_is(fnident, "prefetch") ||
+	    identifier_is(fnident, "scif_free") ||
+	    identifier_is(fnident, "skb_free_frag") ||
+	    identifier_is(fnident, "sort") ||
+	    identifier_is(fnident, "t4_free_mem") ||
+	    identifier_is(fnident, "vfree") ||
+	    identifier_is(fnident, "wake_up_bit") ||
+	    false)
+		return argidx == 1 && ptrdepth_type < ptrdepth_value;
+
+	if (identifier_is(fnident, "__kfifo_in_r") || /* kfifo can be used to transmit pointers */
+	    identifier_is(fnident, "__kfifo_in") ||
+	    identifier_is(fnident, "__kfifo_init") ||
+	    identifier_is(fnident, "__kfifo_out") ||
+	    identifier_is(fnident, "__raw_writel") ||
+	    identifier_is(fnident, "constant_test_bit") || /* even though there is a cast to unsigned long*, using &private_data (which is void**) is being reported */
+	    identifier_is(fnident, "_clear_bit") ||
+	    identifier_is(fnident, "clear_bit") ||
+	    identifier_is(fnident, "d_walk") ||
+	    identifier_is(fnident, "_set_bit") ||
+	    identifier_is(fnident, "set_bit") ||
+	    identifier_is(fnident, "test_bit") ||
+	    identifier_is(fnident, "free_percpu_irq") ||
+
+	    identifier_is(fnident, "device_for_each_child") || /* data for the callback */
+	    identifier_is(fnident, "device_for_each_child_reverse") || /* data for the callback */
+	    identifier_is(fnident, "devm_kfree") ||
+	    identifier_is(fnident, "devm_kmemdup") ||
+	    identifier_is(fnident, "devres_add") || /* resource registered to the device */
+	    identifier_is(fnident, "device_find_child") || /* data for the callback */
+
+	    identifier_is(fnident, "dup_param") ||
+	    identifier_is(fnident, "free_param") ||
+
+	    identifier_is(fnident, "bsearch") || /* data may contain pointers to pointers */
+	    identifier_is(fnident, "rhashtable_lookup_fast") ||
+	    false)
+		return argidx == 2 && ptrdepth_type < ptrdepth_value;
+
+	if (identifier_is(fnident, "get_disp_fb") ||
+	    identifier_is(fnident, "get_free_fb"))
+		return argidx == 2 && ptrdepth_value == 1;
+
+	if (identifier_is(fnident, "blkdev_get") || /* Third arg "holder" is a pointer to a stack variable */
+	    identifier_is(fnident, "bus_for_each_dev") ||
+	    identifier_is(fnident, "driver_for_each_device") ||
+	    identifier_is(fnident, "drm_for_each_detailed_block") ||
+	    identifier_is(fnident, "flex_array_put") ||
+	    identifier_is(fnident, "hashtab_map") || /* args */
+	    identifier_is(fnident, "idr_for_each") ||
+	    identifier_is(fnident, "of_clk_add_provider") ||
+	    identifier_is(fnident, "pci_for_each_dma_alias") || /* private data */
+	    identifier_is(fnident, "single_open") ||
+	    identifier_is(fnident, "snd_seq_dump_var_event") || /* private_data */
+	    identifier_is(fnident, "twsk_unique") ||
+	    identifier_is(fnident, "devm_free_irq") ||
+	    identifier_is(fnident, "vdec_if_get_param") ||
+	    false)
+		return argidx == 3 && ptrdepth_type < ptrdepth_value;
+
+	if (identifier_is(fnident, "debugfs_create_file") || /* Private data */
+	    identifier_is(fnident, "devres_release") || /* match_data */
+	    identifier_is(fnident, "dss_debugfs_create_file") ||
+	    identifier_is(fnident, "request_percpu_irq") ||
+	    identifier_is(fnident, "err_print_param") ||
+	    identifier_is(fnident, "seq_print_param") ||
+	    identifier_is(fnident, "_print_param") || /* third param is int* or char** */
+	    false)
+		return argidx == 4 && ptrdepth_type < ptrdepth_value;
+
+	if (identifier_is(fnident, "vdec_h264_get_fb"))
+		return argidx == 4 && ptrdepth_value == 1;
+
+	if (identifier_is(fnident, "_get_res") && argidx == 5 && ptrdepth_value == 2)
+		return true;
+
+	if (identifier_is(fnident, "param_free_charp") && argidx == 1 && ptrdepth_value == 2) /* This function waits for a char** but needs to have the prototype of free() */
+		return true;
+
+	if (identifier_is(fnident, "fetch_robust_entry") || /* compat_uptr_t __user * depth is 2 */
+	    identifier_is(fnident, "netdev_walk_all_lower_dev") ||
+	    identifier_is(fnident, "netdev_walk_all_lower_dev_rcu"))
+		return argidx == 3 && ptrdepth_value == 2;
+
+	/* lib/radix-tree.c does strange things */
+	if (identifier_is(fnident, "delete_sibling_entries") ||
+	    identifier_is(fnident, "node_to_entry") ||
+	    identifier_is(fnident, "radix_tree_is_internal_node"))
+		return argidx == 1 && ptrdepth_type < ptrdepth_value;
+
+	if (identifier_is(fnident, "i2c_for_each_dev")) /* data callback parameter */
+		return argidx == 1 && ptrdepth_type < ptrdepth_value;
+
+/* automatic processing, TODO: review! */
+	if ((identifier_is(fnident, "__be64_to_cpup") && argidx == 1 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "__cq_dequeue") && argidx == 2 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "__install_special_mapping") && argidx == 5 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "__ocfs2_find_path") && argidx == 5 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "__test_and_clear_bit") && argidx == 2 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "__test_and_set_bit") && argidx == 2 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "__uvcg_iter_frm_intrv") && argidx == 4 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "__uvcg_iter_strm_cls") && argidx == 2 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "acpi_bus_get_device") && argidx == 1 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "acpi_get_physical_device_location") && argidx == 1 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "acpi_node_prop_read") && argidx == 4 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "acpi_rs_out_string") && argidx == 2 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "acpi_ut_trace_ptr") && argidx == 5 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "acpi_walk_namespace") && argidx == 6 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "acpi_walk_resources") && argidx == 4 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "alloc_ring") && argidx == 6 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "alloc_usemap_and_memmap") && argidx == 2 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "ath10k_wmi_tlv_iter") && argidx == 5 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "cfs_array_free") && argidx == 1 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "csio_enqueue_evt") && argidx == 3 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "cxgbi_free_big_mem") && argidx == 1 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "deactivate_slab") && argidx == 3 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "devm_request_irq") && argidx == 6 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "free_irq") && argidx == 2 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "gigaset_add_event") && argidx == 4 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "hlist_add_head") && argidx == 2 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "i2400m_zrealloc_2x") && argidx == 1 && ptrdepth_value == 3) ||
+	    (identifier_is(fnident, "ieee80211_iter_chan_contexts_atomic") && argidx == 3 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "iommu_group_for_each_dev") && argidx == 2 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "lbs_deb_hex") && argidx == 3 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "lustre_cfg_bufs_set") && argidx == 3 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "mgmt_pending_foreach") && argidx == 4 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "platform_device_add_data") && argidx == 2 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "platform_set_drvdata") && argidx == 2 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "pool_proc_next") && argidx == 2 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "rbd_img_request_fill") && argidx == 3 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "request_irq") && argidx == 5 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "set_freepointer") && argidx == 3 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "snd_pcm_hw_rule_add") && argidx == 5 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "trace_ocfs2_read_virt_blocks") && argidx == 4 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "ulist_add_merge") && argidx == 4 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "usb_acpi_get_connect_type") && argidx == 1 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "usb_control_msg") && argidx == 7 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "xenbus_grant_ring") && argidx == 2 && ptrdepth_value == 2) ||
+
+	    (identifier_is(fnident, "acpi_walk_namespace") && argidx == 7 && ptrdepth_value == 1) ||
+	    (identifier_is(fnident, "is_sibling_entry") && argidx == 2 && ptrdepth_value == 2) ||
+	    (identifier_is(fnident, "entry_to_node") && argidx == 1 && ptrdepth_value == 2) ||
+	    false)
+		return true;
+
+	if (identifier_is(fnident, "__uvcg_iter_strm_cls"))
+		return argidx == 2 || argidx == 3; /* priv2 and priv3 */
+
+	if (identifier_is(fnident, "memcpy_with_cast"))
+		return argidx == 1 || argidx == 2;
+	if (identifier_is(fnident, "__xchg") ||
+	    identifier_is(fnident, "__cmpxchg"))
+		return argidx == 1 || argidx == 2;
+
+	if (identifier_is(fnident, "__builtin___ubsan_handle_divrem_overflow") ||
+	    identifier_is(fnident, "__builtin___ubsan_handle_shift_out_of_bounds"))
+		return ptrdepth_value == 0 && (argidx == 2 || argidx == 3); /* UBSAN built-in functions */
+	if (identifier_is(fnident, "__builtin___ubsan_handle_vla_bound_not_positive"))
+		return ptrdepth_value == 0 && argidx == 2; /* UBSAN built-in functions */
+
+	if (identifier_is(fnident, "do_execve_file"))
+		return (argidx == 2 || argidx == 3) && ptrdepth_value == 2; /* do_execve_file uses void* instead of char** */
+
+	return false;
+}
+
+static unsigned int deref_checker_execute(void)
+{
+	basic_block bb;
+
+	FOR_EACH_BB_FN(bb, cfun) {
+		gimple_stmt_iterator gsi;
+
+		for (gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi)) {
+			gimple stmt;
+			gcall *call_stmt;
+			const_tree fndecl, arg_type;
+			unsigned int argidx;
+			function_args_iterator arg_iter;
+			bool expect_next_depth = false;
+			unsigned int expected_ptrdepth_type, expected_ptrdepth_value;
+
+			/* Get the statement */
+			stmt = gsi_stmt(gsi);
+			if (!is_gimple_call(stmt))
+				continue;
+			call_stmt = as_a_gcall(stmt);
+			/*debug_gimple_stmt(stmt);*/
+			//debug_tree(gimple_call_fn(stmt));
+
+			/* Get the function declaration */
+			fndecl = gimple_call_fndecl(stmt);
+			if (fndecl == NULL_TREE)
+				continue;
+
+			argidx = 1;
+			FOREACH_FUNCTION_ARGS(TREE_TYPE(fndecl), arg_type, arg_iter) {
+				const_tree arg_tree;
+				unsigned int ptrdepth_type, ptrdepth_value;
+
+				if (TREE_CODE(arg_type) == VOID_TYPE) {
+					/* End of function arguments */
+					if (argidx != 1 + gimple_call_num_args(call_stmt)) {
+						error(G_("Call to %qF with too many parameters"), fndecl);
+						break;
+					}
+					argidx++;
+					continue; /* the loop should exit by itself. Otherwise the error is catched later */
+				}
+
+				/* This should not happen */
+				if (argidx > gimple_call_num_args(call_stmt)) {
+					error(G_("Call to %qF with not enough parameters"), fndecl);
+					break;
+				}
+
+				ptrdepth_type = get_pointer_depth(arg_type);
+
+				arg_tree = gimple_call_arg(call_stmt, argidx - 1);
+				ptrdepth_value = get_pointer_depth(TREE_TYPE(arg_tree));
+
+				/* memcpy and memcmp are special as two pointers of the same depth may be used */
+				if (expect_next_depth) {
+					expect_next_depth = false;
+					/* This should not happen: memcmp has a known prototype */
+					if (ptrdepth_type != expected_ptrdepth_type) {
+						warning_at(
+							gimple_location(stmt), 0,
+							G_("Internal error while analyzing a call to %qF\n"),
+							fndecl);
+					}
+					if (ptrdepth_value != expected_ptrdepth_value) {
+/* debug_tree(arg_tree); */
+						warning_at(
+							gimple_location(stmt), 0,
+							G_("Invalid pointer depth in function call %qF: value of arg %u is %u, not expected %u\n"),
+							fndecl, argidx, ptrdepth_value, expected_ptrdepth_value);
+					}
+				} else if (argidx == 1 && (
+				    identifier_is(DECL_NAME(fndecl), "__builtin_memcmp") ||
+				    identifier_is(DECL_NAME(fndecl), "__builtin_memcpy") ||
+				    identifier_is(DECL_NAME(fndecl), "__memcpy") ||
+				    identifier_is(DECL_NAME(fndecl), "__same_pointer_depths_chk") ||
+				    identifier_is(DECL_NAME(fndecl), "__same_pointers_depths_with_volatile1_chk") ||
+				    identifier_is(DECL_NAME(fndecl), "__same_pointers_depths_with_volatile2_chk") ||
+				    identifier_is(DECL_NAME(fndecl), "copy_from_user") ||
+				    identifier_is(DECL_NAME(fndecl), "copy_to_user") ||
+				    identifier_is(DECL_NAME(fndecl), "memcmp") ||
+				    identifier_is(DECL_NAME(fndecl), "memcpy") ||
+				    identifier_is(DECL_NAME(fndecl), "memcpy_fromio") ||
+				    identifier_is(DECL_NAME(fndecl), "memcpy_toio") ||
+				    identifier_is(DECL_NAME(fndecl), "memmove") ||
+				    identifier_is(DECL_NAME(fndecl), "probe_kernel_read"))) {
+					expect_next_depth = true;
+					expected_ptrdepth_type = ptrdepth_type;
+					expected_ptrdepth_value = ptrdepth_value;
+				} else if (ptrdepth_type != ptrdepth_value && !is_whitelisted(fndecl, argidx, ptrdepth_type, ptrdepth_value)) {
+					warning_at(
+						gimple_location(stmt), 0,
+						G_("Invalid pointer depth in function call %qF: type of argument %u says %u but value is %u\n"),
+						fndecl, argidx, ptrdepth_type, ptrdepth_value);
+				}
+
+				argidx++;
+			}
+		}
+	}
+
+	return 0;
+}
+
+#define PASS_NAME deref_checker
+
+#define NO_GATE
+#define TODO_FLAGS_FINISH TODO_dump_func
+
+#include "gcc-generate-gimple-pass.h"
+
+int plugin_init(struct plugin_name_args *plugin_info, struct plugin_gcc_version *version)
+{
+	const char * const plugin_name = plugin_info->base_name;
+
+	PASS_INFO(deref_checker, "ssa", 1, PASS_POS_INSERT_AFTER);
+
+	if (!plugin_default_version_check(version, &gcc_version)) {
+		error(G_("incompatible gcc/plugin versions"));
+		return 1;
+	}
+
+	register_callback(plugin_name, PLUGIN_INFO, NULL,
+				&deref_checker_plugin_info);
+	register_callback(plugin_name, PLUGIN_PASS_MANAGER_SETUP, NULL,
+				&deref_checker_pass_info);
+
+	return 0;
+}
diff --git a/security/apparmor/apparmorfs.c b/security/apparmor/apparmorfs.c
index 949dd8a48164..9a789f3be764 100644
--- a/security/apparmor/apparmorfs.c
+++ b/security/apparmor/apparmorfs.c
@@ -699,8 +699,15 @@ static ssize_t query_data(char *buf, size_t buf_len,
 		if (!profile->data)
 			continue;
 
-		data = rhashtable_lookup_fast(profile->data, &key,
-					      profile->data->p);
+		{
+			/* Play nice with the pointer deref checker:
+			 * The hashtable key is a char** because strhash() used it and param.keylen = sizeof(void*)
+			 * So this usage is valid.
+			 */
+			const void *vkey = &key;
+			data = rhashtable_lookup_fast(profile->data, vkey,
+							  profile->data->p);
+		}
 
 		if (data) {
 			if (out + sizeof(outle32) + data->size > buf +
diff --git a/sound/core/pcm_native.c b/sound/core/pcm_native.c
index cecc79772c94..46e02a048b2b 100644
--- a/sound/core/pcm_native.c
+++ b/sound/core/pcm_native.c
@@ -2785,7 +2785,7 @@ static int snd_pcm_xfern_frames_ioctl(struct snd_pcm_substream *substream,
 {
 	struct snd_xfern xfern;
 	struct snd_pcm_runtime *runtime = substream->runtime;
-	void *bufs;
+	void **bufs;
 	snd_pcm_sframes_t result;
 
 	if (runtime->status->state == SNDRV_PCM_STATE_OPEN)
-- 
