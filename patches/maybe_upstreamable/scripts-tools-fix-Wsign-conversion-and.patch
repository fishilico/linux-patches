From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Nicolas Iooss <nicolas.iooss_linux@m4x.org>
Date: Sun, 28 Jun 2015 10:23:14 +0800
Subject: [PATCH] {MAYBE UPS} scripts,tools: fix -Wsign-conversion and
 -Wsign-compare

---
 arch/x86/boot/tools/build.c             | 33 +++++++++-------
 arch/x86/entry/vdso/vdso2c.c            |  4 +-
 arch/x86/entry/vdso/vdso2c.h            |  8 ++--
 arch/x86/tools/relocs.c                 | 68 ++++++++++++++++----------------
 drivers/gpu/drm/radeon/mkregtable.c     | 12 +++---
 samples/hidraw/hid-example.c            | 20 +++++-----
 scripts/asn1_compiler.c                 | 55 +++++++++++++-------------
 scripts/basic/fixdep.c                  | 34 ++++++++--------
 scripts/genksyms/genksyms.c             | 10 ++---
 scripts/genksyms/lex.lex.c_shipped      |  2 +-
 scripts/kallsyms.c                      | 44 +++++++++++----------
 scripts/kconfig/conf.c                  |  4 +-
 scripts/kconfig/confdata.c              | 10 ++---
 scripts/kconfig/expr.c                  |  2 +-
 scripts/kconfig/menu.c                  |  2 +-
 scripts/kconfig/symbol.c                |  4 +-
 scripts/kconfig/zconf.hash.c_shipped    |  6 +--
 scripts/mod/file2alias.c                | 69 +++++++++++++++++----------------
 scripts/mod/modpost.c                   |  8 ++--
 scripts/mod/sumversion.c                | 37 +++++++++---------
 scripts/pnmtologo.c                     | 15 +++----
 scripts/selinux/genheaders/genheaders.c |  8 ++--
 scripts/sortextable.c                   | 14 +++----
 scripts/sortextable.h                   | 14 +++----
 tools/include/tools/be_byteshift.h      | 10 ++---
 tools/include/tools/le_byteshift.h      | 10 ++---
 usr/gen_init_cpio.c                     | 53 ++++++++++++-------------
 27 files changed, 286 insertions(+), 270 deletions(-)

diff --git a/arch/x86/boot/tools/build.c b/arch/x86/boot/tools/build.c
index 7a049e8324f1..1a25ba2a3921 100644
--- a/arch/x86/boot/tools/build.c
+++ b/arch/x86/boot/tools/build.c
@@ -52,10 +52,10 @@ static u8 buf[SETUP_SECT_MAX*512];
 
 #define PECOFF_RELOC_RESERVE 0x20
 
-static unsigned long efi32_stub_entry;
-static unsigned long efi64_stub_entry;
-static unsigned long efi_pe_entry;
-static unsigned long startup_64;
+static unsigned int efi32_stub_entry;
+static unsigned int efi64_stub_entry;
+static unsigned int efi_pe_entry;
+static unsigned int startup_64;
 
 /*----------------------------------------------------------------------*/
 
@@ -119,7 +119,7 @@ static u32 partial_crc32_one(u8 c, u32 crc)
 	return crctab32[(crc ^ c) & 0xff] ^ (crc >> 8);
 }
 
-static u32 partial_crc32(const u8 *s, int len, u32 crc)
+static u32 partial_crc32(const u8 *s, unsigned int len, u32 crc)
 {
 	while (len--)
 		crc = partial_crc32_one(*s++, crc);
@@ -257,7 +257,7 @@ static void efi_stub_defaults(void)
 
 static void efi_stub_entry_update(void)
 {
-	unsigned long addr = efi32_stub_entry;
+	unsigned int addr = efi32_stub_entry;
 
 #ifdef CONFIG_X86_64
 	/* Yes, this is really how we defined it :( */
@@ -294,15 +294,20 @@ static inline int reserve_pecoff_reloc_section(int c)
  * not as if parsing it is hard...
  */
 #define PARSE_ZOFS(p, sym) do { \
-	if (!strncmp(p, "#define ZO_" #sym " ", 11+sizeof(#sym)))	\
-		sym = strtoul(p + 11 + sizeof(#sym), NULL, 16);		\
+	if (!strncmp(p, "#define ZO_" #sym " ", 11+sizeof(#sym))) {	\
+		unsigned long _sym;					\
+		_sym = strtoul(p + 11 + sizeof(#sym), NULL, 16);	\
+		sym = (unsigned int)_sym;				\
+		if (_sym != (unsigned long)(sym))			\
+			die("Overflow on symbol " #sym);		\
+	}								\
 } while (0)
 
 static void parse_zoffset(char *fname)
 {
 	FILE *file;
 	char *p;
-	int c;
+	size_t c;
 
 	file = fopen(fname, "r");
 	if (!file)
@@ -352,7 +357,7 @@ int main(int argc, char ** argv)
 	file = fopen(argv[1], "r");
 	if (!file)
 		die("Unable to open `%s': %m", argv[1]);
-	c = fread(buf, 1, sizeof(buf), file);
+	c = (int)fread(buf, 1, sizeof(buf), file);
 	if (ferror(file))
 		die("read-error on `setup'");
 	if (c < 1024)
@@ -364,11 +369,11 @@ int main(int argc, char ** argv)
 	c += reserve_pecoff_reloc_section(c);
 
 	/* Pad unused space with zeros */
-	setup_sectors = (c + 511) / 512;
+	setup_sectors = ((unsigned int)c + 511) / 512;
 	if (setup_sectors < SETUP_SECT_MIN)
 		setup_sectors = SETUP_SECT_MIN;
 	i = setup_sectors*512;
-	memset(buf+c, 0, i-c);
+	memset(buf+c, 0, (size_t)(i-(unsigned)c));
 
 	update_pecoff_setup_and_reloc(i);
 
@@ -383,7 +388,7 @@ int main(int argc, char ** argv)
 		die("Unable to open `%s': %m", argv[2]);
 	if (fstat(fd, &sb))
 		die("Unable to stat `%s': %m", argv[2]);
-	sz = sb.st_size;
+	sz = (unsigned int)sb.st_size;
 	printf("System is %d kB\n", (sz+1023)/1024);
 	kernel = mmap(NULL, sz, PROT_READ, MAP_SHARED, fd, 0);
 	if (kernel == MAP_FAILED)
@@ -392,7 +397,7 @@ int main(int argc, char ** argv)
 	sys_size = (sz + 15 + 4) / 16;
 
 	/* Patch the setup code with the appropriate size parameters */
-	buf[0x1f1] = setup_sectors-1;
+	buf[0x1f1] = (u8)(setup_sectors-1);
 	put_unaligned_le32(sys_size, &buf[0x1f4]);
 
 	update_pecoff_text(setup_sectors * 512, i + (sys_size * 16));
diff --git a/arch/x86/entry/vdso/vdso2c.c b/arch/x86/entry/vdso/vdso2c.c
index 491020b2826d..0b81cfd03555 100644
--- a/arch/x86/entry/vdso/vdso2c.c
+++ b/arch/x86/entry/vdso/vdso2c.c
@@ -198,7 +198,7 @@ static void map_input(const char *name, void **addr, size_t *len, int prot)
 		err(1, "lseek");
 	*len = (size_t)tmp_len;
 
-	*addr = mmap(NULL, tmp_len, prot, MAP_PRIVATE, fd, 0);
+	*addr = mmap(NULL, (size_t)tmp_len, prot, MAP_PRIVATE, fd, 0);
 	if (*addr == MAP_FAILED)
 		err(1, "mmap");
 
@@ -211,7 +211,7 @@ int main(int argc, char **argv)
 	void *raw_addr, *stripped_addr;
 	FILE *outfile;
 	char *name, *tmp;
-	int namelen;
+	size_t namelen;
 
 	if (argc != 4) {
 		printf("Usage: vdso2c RAW_INPUT STRIPPED_INPUT OUTPUT\n");
diff --git a/arch/x86/entry/vdso/vdso2c.h b/arch/x86/entry/vdso/vdso2c.h
index 63a03bb91497..a02435d25132 100644
--- a/arch/x86/entry/vdso/vdso2c.h
+++ b/arch/x86/entry/vdso/vdso2c.h
@@ -9,10 +9,10 @@ static void BITSFUNC(go)(void *raw_addr, size_t raw_len,
 			 FILE *outfile, const char *name)
 {
 	int found_load = 0;
-	unsigned long load_size = -1;  /* Work around bogus warning */
+	unsigned long load_size = -1UL;  /* Work around bogus warning */
 	unsigned long mapping_size;
 	ELF(Ehdr) *hdr = (ELF(Ehdr) *)raw_addr;
-	int i;
+	unsigned int i;
 	unsigned long j;
 	ELF(Shdr) *symtab_hdr = NULL, *strtab_hdr, *secstrings_hdr,
 		*alt_sec = NULL;
@@ -83,7 +83,7 @@ static void BITSFUNC(go)(void *raw_addr, size_t raw_len,
 	for (i = 0;
 	     i < GET_LE(&symtab_hdr->sh_size) / GET_LE(&symtab_hdr->sh_entsize);
 	     i++) {
-		int k;
+		unsigned int k;
 		ELF(Sym) *sym = raw_addr + GET_LE(&symtab_hdr->sh_offset) +
 			GET_LE(&symtab_hdr->sh_entsize) * i;
 		const char *name = raw_addr + GET_LE(&strtab_hdr->sh_offset) +
@@ -102,7 +102,7 @@ static void BITSFUNC(go)(void *raw_addr, size_t raw_len,
 				 * on syms[k] being a signed type of the
 				 * correct width.
 				 */
-				syms[k] = GET_LE(&sym->st_value);
+				syms[k] = (INT_BITS)GET_LE(&sym->st_value);
 			}
 		}
 	}
diff --git a/arch/x86/tools/relocs.c b/arch/x86/tools/relocs.c
index 0c2fae8d929d..c2924b79e86b 100644
--- a/arch/x86/tools/relocs.c
+++ b/arch/x86/tools/relocs.c
@@ -396,9 +396,9 @@ static void read_shdrs(FILE *fp)
 		die("Unable to allocate %d section headers\n",
 		    ehdr.e_shnum);
 	}
-	if (fseek(fp, ehdr.e_shoff, SEEK_SET) < 0) {
-		die("Seek to %d failed: %s\n",
-			ehdr.e_shoff, strerror(errno));
+	if (fseek(fp, (long)ehdr.e_shoff, SEEK_SET) < 0) {
+		die("Seek to %lu failed: %s\n",
+			(unsigned long)ehdr.e_shoff, strerror(errno));
 	}
 	for (i = 0; i < ehdr.e_shnum; i++) {
 		struct section *sec = &secs[i];
@@ -431,12 +431,12 @@ static void read_strtabs(FILE *fp)
 		}
 		sec->strtab = malloc(sec->shdr.sh_size);
 		if (!sec->strtab) {
-			die("malloc of %d bytes for strtab failed\n",
-				sec->shdr.sh_size);
+			die("malloc of %lu bytes for strtab failed\n",
+				(unsigned long)sec->shdr.sh_size);
 		}
-		if (fseek(fp, sec->shdr.sh_offset, SEEK_SET) < 0) {
-			die("Seek to %d failed: %s\n",
-				sec->shdr.sh_offset, strerror(errno));
+		if (fseek(fp, (long)sec->shdr.sh_offset, SEEK_SET) < 0) {
+			die("Seek to %ld failed: %s\n",
+				(long)sec->shdr.sh_offset, strerror(errno));
 		}
 		if (fread(sec->strtab, 1, sec->shdr.sh_size, fp)
 		    != sec->shdr.sh_size) {
@@ -448,7 +448,8 @@ static void read_strtabs(FILE *fp)
 
 static void read_symtabs(FILE *fp)
 {
-	int i,j;
+	int i;
+	unsigned int j;
 	for (i = 0; i < ehdr.e_shnum; i++) {
 		struct section *sec = &secs[i];
 		if (sec->shdr.sh_type != SHT_SYMTAB) {
@@ -456,12 +457,12 @@ static void read_symtabs(FILE *fp)
 		}
 		sec->symtab = malloc(sec->shdr.sh_size);
 		if (!sec->symtab) {
-			die("malloc of %d bytes for symtab failed\n",
-				sec->shdr.sh_size);
+			die("malloc of %ld bytes for symtab failed\n",
+				(long)sec->shdr.sh_size);
 		}
-		if (fseek(fp, sec->shdr.sh_offset, SEEK_SET) < 0) {
-			die("Seek to %d failed: %s\n",
-				sec->shdr.sh_offset, strerror(errno));
+		if (fseek(fp, (long)sec->shdr.sh_offset, SEEK_SET) < 0) {
+			die("Seek to %ld failed: %s\n",
+				(long)sec->shdr.sh_offset, strerror(errno));
 		}
 		if (fread(sec->symtab, 1, sec->shdr.sh_size, fp)
 		    != sec->shdr.sh_size) {
@@ -481,7 +482,8 @@ static void read_symtabs(FILE *fp)
 
 static void read_relocs(FILE *fp)
 {
-	int i,j;
+	int i;
+	unsigned int j;
 	for (i = 0; i < ehdr.e_shnum; i++) {
 		struct section *sec = &secs[i];
 		if (sec->shdr.sh_type != SHT_REL_TYPE) {
@@ -489,12 +491,12 @@ static void read_relocs(FILE *fp)
 		}
 		sec->reltab = malloc(sec->shdr.sh_size);
 		if (!sec->reltab) {
-			die("malloc of %d bytes for relocs failed\n",
-				sec->shdr.sh_size);
+			die("malloc of %lu bytes for relocs failed\n",
+				(unsigned long)sec->shdr.sh_size);
 		}
-		if (fseek(fp, sec->shdr.sh_offset, SEEK_SET) < 0) {
-			die("Seek to %d failed: %s\n",
-				sec->shdr.sh_offset, strerror(errno));
+		if (fseek(fp, (long)sec->shdr.sh_offset, SEEK_SET) < 0) {
+			die("Seek to %ld failed: %s\n",
+				(long)sec->shdr.sh_offset, strerror(errno));
 		}
 		if (fread(sec->reltab, 1, sec->shdr.sh_size, fp)
 		    != sec->shdr.sh_size) {
@@ -506,7 +508,7 @@ static void read_relocs(FILE *fp)
 			rel->r_offset = elf_addr_to_cpu(rel->r_offset);
 			rel->r_info   = elf_xword_to_cpu(rel->r_info);
 #if (SHT_REL_TYPE == SHT_RELA)
-			rel->r_addend = elf_xword_to_cpu(rel->r_addend);
+			rel->r_addend = (long)elf_xword_to_cpu((unsigned)rel->r_addend);
 #endif
 		}
 	}
@@ -528,7 +530,7 @@ static void print_absolute_symbols(void)
 	for (i = 0; i < ehdr.e_shnum; i++) {
 		struct section *sec = &secs[i];
 		char *sym_strtab;
-		int j;
+		unsigned int j;
 
 		if (sec->shdr.sh_type != SHT_SYMTAB) {
 			continue;
@@ -568,7 +570,7 @@ static void print_absolute_relocs(void)
 		struct section *sec_applies, *sec_symtab;
 		char *sym_strtab;
 		Elf_Sym *sh_symtab;
-		int j;
+		unsigned int j;
 		if (sec->shdr.sh_type != SHT_REL_TYPE) {
 			continue;
 		}
@@ -651,7 +653,7 @@ static void walk_relocs(int (*process)(struct section *sec, Elf_Rel *rel,
 		char *sym_strtab;
 		Elf_Sym *sh_symtab;
 		struct section *sec_applies, *sec_symtab;
-		int j;
+		unsigned int j;
 		struct section *sec = &secs[i];
 
 		if (sec->shdr.sh_type != SHT_REL_TYPE) {
@@ -702,7 +704,7 @@ static Elf_Addr per_cpu_load_addr;
 
 static void percpu_init(void)
 {
-	int i;
+	unsigned int i;
 	for (i = 0; i < ehdr.e_shnum; i++) {
 		ElfW(Sym) *sym;
 		if (strcmp(sec_name(i), ".data..percpu"))
@@ -715,7 +717,7 @@ static void percpu_init(void)
 		if (!sym)
 			die("can't find __per_cpu_load\n");
 
-		per_cpu_shndx = i;
+		per_cpu_shndx = (int)i;
 		per_cpu_load_addr = sym->st_value;
 		return;
 	}
@@ -760,7 +762,7 @@ static int do_reloc64(struct section *sec, Elf_Rel *rel, ElfW(Sym) *sym,
 	/*
 	 * Adjust the offset if this reloc applies to the percpu section.
 	 */
-	if (sec->shdr.sh_info == per_cpu_shndx)
+	if ((int)sec->shdr.sh_info == per_cpu_shndx)
 		offset += per_cpu_load_addr;
 
 	switch (r_type) {
@@ -774,7 +776,7 @@ static int do_reloc64(struct section *sec, Elf_Rel *rel, ElfW(Sym) *sym,
 		 * referencing a percpu symbol.
 		 */
 		if (is_percpu_sym(sym, symname))
-			add_reloc(&relocs32neg, offset);
+			add_reloc(&relocs32neg, (uint32_t)offset);
 		break;
 
 	case R_X86_64_32:
@@ -809,9 +811,9 @@ static int do_reloc64(struct section *sec, Elf_Rel *rel, ElfW(Sym) *sym,
 			die("Relocation offset doesn't fit in 32 bits\n");
 
 		if (r_type == R_X86_64_64)
-			add_reloc(&relocs64, offset);
+			add_reloc(&relocs64, (uint32_t)offset);
 		else
-			add_reloc(&relocs32, offset);
+			add_reloc(&relocs32, (uint32_t)offset);
 		break;
 
 	default:
@@ -968,7 +970,7 @@ static int write32_as_text(uint32_t v, FILE *f)
 
 static void emit_relocs(int as_text, int use_real_mode)
 {
-	int i;
+	unsigned int i;
 	int (*write_reloc)(uint32_t, FILE *) = write32;
 	int (*do_reloc)(struct section *sec, Elf_Rel *rel, Elf_Sym *sym,
 			const char *symname);
@@ -1010,11 +1012,11 @@ static void emit_relocs(int as_text, int use_real_mode)
 	}
 
 	if (use_real_mode) {
-		write_reloc(relocs16.count, stdout);
+		write_reloc((uint32_t)relocs16.count, stdout);
 		for (i = 0; i < relocs16.count; i++)
 			write_reloc(relocs16.offset[i], stdout);
 
-		write_reloc(relocs32.count, stdout);
+		write_reloc((uint32_t)relocs32.count, stdout);
 		for (i = 0; i < relocs32.count; i++)
 			write_reloc(relocs32.offset[i], stdout);
 	} else {
diff --git a/drivers/gpu/drm/radeon/mkregtable.c b/drivers/gpu/drm/radeon/mkregtable.c
index b928c17bdeed..edd78d99a02b 100644
--- a/drivers/gpu/drm/radeon/mkregtable.c
+++ b/drivers/gpu/drm/radeon/mkregtable.c
@@ -625,13 +625,13 @@ static int parser_auth(struct table *t, const char *filename)
 	regmatch_t match[4];
 	char buf[1024];
 	size_t end;
-	int len;
+	size_t len;
 	int done = 0;
 	int r;
 	unsigned o;
 	struct offset *offset;
 	char last_reg_s[10];
-	int last_reg;
+	unsigned int last_reg;
 
 	if (regcomp
 	    (&mask_rex, "(0x[0-9a-fA-F]*) *([_a-zA-Z0-9]*)", REG_EXTENDED)) {
@@ -644,7 +644,7 @@ static int parser_auth(struct table *t, const char *filename)
 		return -1;
 	}
 	fseek(file, 0, SEEK_END);
-	end = ftell(file);
+	end = (size_t)ftell(file);
 	fseek(file, 0, SEEK_SET);
 
 	/* get header */
@@ -657,7 +657,7 @@ static int parser_auth(struct table *t, const char *filename)
 	 * and gpu name */
 	sscanf(buf, "%9s %9s", gpu_name, last_reg_s);
 	t->gpu_prefix = gpu_name;
-	last_reg = strtol(last_reg_s, NULL, 16);
+	last_reg = (unsigned int)strtoul(last_reg_s, NULL, 16);
 
 	do {
 		if (fgets(buf, 1024, file) == NULL) {
@@ -665,7 +665,7 @@ static int parser_auth(struct table *t, const char *filename)
 			return -1;
 		}
 		len = strlen(buf);
-		if (ftell(file) == end)
+		if (ftell(file) == (long)end)
 			done = 1;
 		if (len) {
 			r = regexec(&mask_rex, buf, 4, match, 0);
@@ -680,7 +680,7 @@ static int parser_auth(struct table *t, const char *filename)
 				buf[match[0].rm_eo] = 0;
 				buf[match[1].rm_eo] = 0;
 				buf[match[2].rm_eo] = 0;
-				o = strtol(&buf[match[1].rm_so], NULL, 16);
+				o = (unsigned)strtoul(&buf[match[1].rm_so], NULL, 16);
 				offset = offset_new(o);
 				table_offset_add(t, offset);
 				if (o > t->offset_max)
diff --git a/samples/hidraw/hid-example.c b/samples/hidraw/hid-example.c
index 3d0cd360b2a0..321ba2443d17 100644
--- a/samples/hidraw/hid-example.c
+++ b/samples/hidraw/hid-example.c
@@ -37,13 +37,15 @@
 #include <stdlib.h>
 #include <errno.h>
 
-const char *bus_str(int bus);
+const char *bus_str(unsigned int bus);
 
 int main(int argc, char **argv)
 {
 	int fd;
-	int i, res, desc_size = 0;
-	char buf[256];
+	unsigned int i;
+	int res;
+	unsigned int desc_size = 0;
+	unsigned char buf[256];
 	struct hidraw_report_descriptor rpt_desc;
 	struct hidraw_devinfo info;
 	const char *device = "/dev/hidraw0";
@@ -69,7 +71,7 @@ int main(int argc, char **argv)
 	if (res < 0)
 		perror("HIDIOCGRDESCSIZE");
 	else
-		printf("Report Descriptor Size: %d\n", desc_size);
+		printf("Report Descriptor Size: %u\n", desc_size);
 
 	/* Get Report Descriptor */
 	rpt_desc.size = desc_size;
@@ -128,7 +130,7 @@ int main(int argc, char **argv)
 	} else {
 		printf("ioctl HIDIOCGFEATURE returned: %d\n", res);
 		printf("Report data (not containing the report number):\n\t");
-		for (i = 0; i < res; i++)
+		for (i = 0; i < (unsigned)res; i++)
 			printf("%hhx ", buf[i]);
 		puts("\n");
 	}
@@ -136,7 +138,7 @@ int main(int argc, char **argv)
 	/* Send a Report to the Device */
 	buf[0] = 0x1; /* Report Number */
 	buf[1] = 0x77;
-	res = write(fd, buf, 2);
+	res = (int)write(fd, buf, 2);
 	if (res < 0) {
 		printf("Error: %d\n", errno);
 		perror("write");
@@ -145,12 +147,12 @@ int main(int argc, char **argv)
 	}
 
 	/* Get a report from the device */
-	res = read(fd, buf, 16);
+	res = (int)read(fd, buf, 16);
 	if (res < 0) {
 		perror("read");
 	} else {
 		printf("read() read %d bytes:\n\t", res);
-		for (i = 0; i < res; i++)
+		for (i = 0; i < (unsigned)res; i++)
 			printf("%hhx ", buf[i]);
 		puts("\n");
 	}
@@ -159,7 +161,7 @@ int main(int argc, char **argv)
 }
 
 const char *
-bus_str(int bus)
+bus_str(unsigned int bus)
 {
 	switch (bus) {
 	case BUS_USB:
diff --git a/scripts/asn1_compiler.c b/scripts/asn1_compiler.c
index c1b7ef3e24c1..cc26d1a3bec9 100644
--- a/scripts/asn1_compiler.c
+++ b/scripts/asn1_compiler.c
@@ -302,9 +302,9 @@ static struct action *action_list;
 static unsigned nr_actions;
 
 struct token {
-	unsigned short	line;
+	unsigned int	line;
 	enum token_type	token_type : 8;
-	unsigned char	size;
+	size_t	size;
 	struct action	*action;
 	char		*content;
 	struct type	*type;
@@ -341,7 +341,7 @@ static int directive_compare(const void *_key, const void *_pdir)
 		return 0;
 	}
 	//debug("%d\n", (int)dlen - (int)token->size);
-	return dlen - token->size; /* shorter -> negative */
+	return (int)(dlen - token->size); /* shorter -> negative */
 }
 
 /*
@@ -356,7 +356,7 @@ static void tokenise(char *buffer, char *end)
 	/* Assume we're going to have half as many tokens as we have
 	 * characters
 	 */
-	token_list = tokens = calloc((end - buffer) / 2, sizeof(struct token));
+	token_list = tokens = calloc((size_t)(end - buffer) / 2, sizeof(struct token));
 	if (!tokens) {
 		perror(NULL);
 		exit(1);
@@ -368,7 +368,7 @@ static void tokenise(char *buffer, char *end)
 		/* First of all, break out a line */
 		lineno++;
 		line = buffer;
-		nl = memchr(line, '\n', end - buffer);
+		nl = memchr(line, '\n', (size_t)(end - buffer));
 		if (!nl) {
 			buffer = nl = end;
 		} else {
@@ -379,15 +379,15 @@ static void tokenise(char *buffer, char *end)
 		/* Remove "--" comments */
 		p = line;
 	next_comment:
-		while ((p = memchr(p, '-', nl - p))) {
+		while ((p = memchr(p, '-', (size_t)(nl - p)))) {
 			if (p[1] == '-') {
 				/* Found a comment; see if there's a terminator */
 				q = p + 2;
-				while ((q = memchr(q, '-', nl - q))) {
+				while ((q = memchr(q, '-', (size_t)(nl - q)))) {
 					if (q[1] == '-') {
 						/* There is - excise the comment */
 						q += 2;
-						memmove(p, q, nl - q);
+						memmove(p, q, (size_t)(nl - q));
 						goto next_comment;
 					}
 					q++;
@@ -421,7 +421,7 @@ static void tokenise(char *buffer, char *end)
 				q = p + 1;
 				while (q < nl && (isalnum(*q) || *q == '-' || *q == '_'))
 					q++;
-				tokens[tix].size = q - p;
+				tokens[tix].size = (size_t)(q - p);
 				p = q;
 
 				tokens[tix].content = malloc(tokens[tix].size + 1);
@@ -448,7 +448,7 @@ static void tokenise(char *buffer, char *end)
 					      sizeof(directives[1]),
 					      directive_compare);
 				if (dir) {
-					tokens[tix++].token_type = dir - directives;
+					tokens[tix++].token_type = (enum token_type)(dir - directives);
 					continue;
 				}
 
@@ -462,7 +462,7 @@ static void tokenise(char *buffer, char *end)
 				q = p + 1;
 				while (q < nl && (isdigit(*q)))
 					q++;
-				tokens[tix].size = q - p;
+				tokens[tix].size = (size_t)(q - p);
 				p = q;
 				tokens[tix].content = malloc(tokens[tix].size + 1);
 				if (!tokens[tix].content) {
@@ -606,12 +606,12 @@ int main(int argc, char **argv)
 		exit(1);
 	}
 
-	if (!(buffer = malloc(st.st_size + 1))) {
+	if (!(buffer = malloc((size_t)st.st_size + 1))) {
 		perror(NULL);
 		exit(1);
 	}
 
-	if ((readlen = read(fd, buffer, st.st_size)) < 0) {
+	if ((readlen = read(fd, buffer, (size_t)st.st_size)) < 0) {
 		perror(filename);
 		exit(1);
 	}
@@ -698,12 +698,12 @@ struct element {
 	uint8_t		tag;
 	unsigned	entry_index;
 	unsigned	flags;
-#define ELEMENT_IMPLICIT	0x0001
-#define ELEMENT_EXPLICIT	0x0002
-#define ELEMENT_TAG_SPECIFIED	0x0004
-#define ELEMENT_RENDERED	0x0008
-#define ELEMENT_SKIPPABLE	0x0010
-#define ELEMENT_CONDITIONAL	0x0020
+#define ELEMENT_IMPLICIT	0x0001U
+#define ELEMENT_EXPLICIT	0x0002U
+#define ELEMENT_TAG_SPECIFIED	0x0004U
+#define ELEMENT_RENDERED	0x0008U
+#define ELEMENT_SKIPPABLE	0x0010U
+#define ELEMENT_CONDITIONAL	0x0020U
 };
 
 struct type {
@@ -725,7 +725,7 @@ static int type_index_compare(const void *_a, const void *_b)
 	const struct type *const *a = _a, *const *b = _b;
 
 	if ((*a)->name->size != (*b)->name->size)
-		return (*a)->name->size - (*b)->name->size;
+		return (int)((*a)->name->size - (*b)->name->size);
 	else
 		return memcmp((*a)->name->content, (*b)->name->content,
 			      (*a)->name->size);
@@ -738,7 +738,7 @@ static int type_finder(const void *_key, const void *_ti)
 	const struct type *type = *ti;
 
 	if (token->size != type->name->size)
-		return token->size - type->name->size;
+		return (int)(token->size - type->name->size);
 	else
 		return memcmp(token->content, type->name->content,
 			      token->size);
@@ -908,7 +908,7 @@ static struct element *parse_type(struct token **_cursor, struct token *end,
 		element->tag &= ~0x1f;
 		element->tag |= strtoul(cursor->content, &p, 10);
 		element->flags |= ELEMENT_TAG_SPECIFIED;
-		if (p - cursor->content != cursor->size)
+		if ((size_t)(p - cursor->content) != cursor->size)
 			abort();
 		cursor++;
 
@@ -1260,7 +1260,7 @@ static void dump_elements(void)
 static void render_element(FILE *out, struct element *e, struct element *tag);
 static void render_out_of_line_list(FILE *out);
 
-static int nr_entries;
+static unsigned int nr_entries;
 static int render_depth = 1;
 static struct element *render_list, **render_list_p = &render_list;
 
@@ -1270,7 +1270,7 @@ static void render_opcode(FILE *out, const char *fmt, ...)
 	va_list va;
 
 	if (out) {
-		fprintf(out, "\t[%4d] =%*s", nr_entries, render_depth, "");
+		fprintf(out, "\t[%4u] =%*s", nr_entries, render_depth, "");
 		va_start(va, fmt);
 		vfprintf(out, fmt, va);
 		va_end(va);
@@ -1298,7 +1298,7 @@ static void render(FILE *out, FILE *hdr)
 	struct element *e;
 	struct action *action;
 	struct type *root;
-	int index;
+	unsigned int index;
 
 	fprintf(hdr, "/*\n");
 	fprintf(hdr, " * Automatically generated by asn1_compiler.  Do not edit\n");
@@ -1397,7 +1397,7 @@ static void render_out_of_line_list(FILE *out)
 {
 	struct element *e, *ce;
 	const char *act;
-	int entry;
+	unsigned int entry;
 
 	while ((e = render_list)) {
 		render_list = e->render_next;
@@ -1444,7 +1444,8 @@ static void render_element(FILE *out, struct element *e, struct element *tag)
 {
 	struct element *ec, *x;
 	const char *cond, *act;
-	int entry, skippable = 0, outofline = 0;
+	unsigned int entry;
+	int skippable = 0, outofline = 0;
 
 	if (e->flags & ELEMENT_SKIPPABLE ||
 	    (tag && tag->flags & ELEMENT_SKIPPABLE))
diff --git a/scripts/basic/fixdep.c b/scripts/basic/fixdep.c
index 746ec1ece614..0051498577cb 100644
--- a/scripts/basic/fixdep.c
+++ b/scripts/basic/fixdep.c
@@ -190,14 +190,14 @@ static unsigned int strhash(const char *str, unsigned int sz)
 	unsigned int i, hash = 2166136261U;
 
 	for (i = 0; i < sz; i++)
-		hash = (hash ^ str[i]) * 0x01000193;
+		hash = (hash ^ (unsigned int)str[i]) * 0x01000193;
 	return hash;
 }
 
 /*
  * Lookup a value in the configuration string.
  */
-static int is_defined_config(const char *name, int len, unsigned int hash)
+static int is_defined_config(const char *name, unsigned int len, unsigned int hash)
 {
 	struct item *aux;
 
@@ -212,7 +212,7 @@ static int is_defined_config(const char *name, int len, unsigned int hash)
 /*
  * Add a new value to the configuration string.
  */
-static void define_config(const char *name, int len, unsigned int hash)
+static void define_config(const char *name, unsigned int len, unsigned int hash)
 {
 	struct item *aux = malloc(sizeof(*aux) + len);
 
@@ -230,7 +230,7 @@ static void define_config(const char *name, int len, unsigned int hash)
 /*
  * Record the use of a CONFIG_* word.
  */
-static void use_config(const char *m, int slen)
+static void use_config(const char *m, unsigned int slen)
 {
 	unsigned int hash = strhash(m, slen);
 
@@ -243,9 +243,9 @@ static void use_config(const char *m, int slen)
 
 static void parse_config_file(const char *map, size_t len)
 {
-	const int *end = (const int *) (map + len);
+	const unsigned int *end = (const unsigned int *) (map + len);
 	/* start at +1, so that p can never be < map */
-	const int *m   = (const int *) map + 1;
+	const unsigned int *m = (const unsigned int *) map + 1;
 	const char *p, *q;
 
 	for (; m < end; m++) {
@@ -271,15 +271,15 @@ static void parse_config_file(const char *map, size_t len)
 			q -= 7;
 		if (q - p < 0)
 			continue;
-		use_config(p, q - p);
+		use_config(p, (unsigned int)(q - p));
 	}
 }
 
 /* test if s ends in sub */
 static int strrcmp(const char *s, const char *sub)
 {
-	int slen = strlen(s);
-	int sublen = strlen(sub);
+	size_t slen = strlen(s);
+	size_t sublen = strlen(sub);
 
 	if (sublen > slen)
 		return 1;
@@ -308,16 +308,16 @@ static void do_config_file(const char *filename)
 		close(fd);
 		return;
 	}
-	map = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
+	map = mmap(NULL, (size_t)st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
 	if ((long) map == -1) {
 		perror("fixdep: mmap");
 		close(fd);
 		return;
 	}
 
-	parse_config_file(map, st.st_size);
+	parse_config_file(map, (size_t)st.st_size);
 
-	munmap(map, st.st_size);
+	munmap(map, (size_t)st.st_size);
 
 	close(fd);
 }
@@ -353,7 +353,7 @@ static void parse_dep_file(void *map, size_t len)
 			is_first_dep = 1;
 		} else {
 			/* Save this token/filename */
-			memcpy(s, m, p-m);
+			memcpy(s, m, (size_t)(p-m));
 			s[p - m] = 0;
 
 			/* Ignore certain dependencies */
@@ -432,16 +432,16 @@ static void print_deps(void)
 		close(fd);
 		return;
 	}
-	map = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
+	map = mmap(NULL, (size_t)st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
 	if ((long) map == -1) {
 		perror("fixdep: mmap");
 		close(fd);
 		return;
 	}
 
-	parse_dep_file(map, st.st_size);
+	parse_dep_file(map, (size_t)st.st_size);
 
-	munmap(map, st.st_size);
+	munmap(map, (size_t)st.st_size);
 
 	close(fd);
 }
@@ -449,7 +449,7 @@ static void print_deps(void)
 static void traps(void)
 {
 	static char test[] __attribute__((aligned(sizeof(int)))) = "CONF";
-	int *p = (int *)test;
+	unsigned int *p = (unsigned int *)test;
 
 	if (*p != INT_CONF) {
 		fprintf(stderr, "fixdep: sizeof(int) != 4 or wrong endianness? %#x\n",
diff --git a/scripts/genksyms/genksyms.c b/scripts/genksyms/genksyms.c
index 06121ce524a7..5e73453e791a 100644
--- a/scripts/genksyms/genksyms.c
+++ b/scripts/genksyms/genksyms.c
@@ -137,7 +137,7 @@ static unsigned long partial_crc32_one(unsigned char c, unsigned long crc)
 static unsigned long partial_crc32(const char *s, unsigned long crc)
 {
 	while (*s)
-		crc = partial_crc32_one(*s++, crc);
+		crc = partial_crc32_one((unsigned char)*s++, crc);
 	return crc;
 }
 
@@ -442,7 +442,7 @@ static struct string_list *read_node(FILE *f)
 			fprintf(stderr, "Token too long\n");
 			exit(1);
 		}
-		*node.string++ = c;
+		*node.string++ = (char)c;
 	}
 	if (node.string == buffer)
 		return NULL;
@@ -454,7 +454,7 @@ static struct string_list *read_node(FILE *f)
 
 		for (n = 0; n < ARRAY_SIZE(symbol_types); n++) {
 			if (node.string[0] == symbol_types[n].n) {
-				node.tag = n;
+				node.tag = (enum symbol_type)n;
 				node.string += 2;
 				return copy_node(&node);
 			}
@@ -514,7 +514,7 @@ static void print_list(FILE * f, struct string_list *list)
 {
 	struct string_list **e, **b;
 	struct string_list *tmp, **tmp2;
-	int elem = 1;
+	unsigned int elem = 1;
 
 	if (list == NULL) {
 		fputs("(nil)", f);
@@ -544,7 +544,7 @@ static unsigned long expand_and_crc_sym(struct symbol *sym, unsigned long crc)
 	struct string_list *list = sym->defn;
 	struct string_list **e, **b;
 	struct string_list *tmp, **tmp2;
-	int elem = 1;
+	unsigned int elem = 1;
 
 	if (!list)
 		return crc;
diff --git a/scripts/genksyms/lex.lex.c_shipped b/scripts/genksyms/lex.lex.c_shipped
index f82740a69b85..cf0ee807db92 100644
--- a/scripts/genksyms/lex.lex.c_shipped
+++ b/scripts/genksyms/lex.lex.c_shipped
@@ -671,7 +671,7 @@ static int input (void );
 	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
 		{ \
 		int c = '*'; \
-		int n; \
+		size_t n; \
 		for ( n = 0; n < max_size && \
 			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
 			buf[n] = (char) c; \
diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 1f22a186c18c..970c27d85d3e 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -92,7 +92,7 @@ static inline int is_arm_mapping_symbol(const char *str)
 }
 
 static int check_symbol_range(const char *sym, unsigned long long addr,
-			      struct addr_range *ranges, int entries)
+			      struct addr_range *ranges, size_t entries)
 {
 	size_t i;
 	struct addr_range *ar;
@@ -164,7 +164,7 @@ static int read_symbol(FILE *in, struct sym_entry *s)
 
 	/* include the type field in the symbol name, so that it gets
 	 * compressed together */
-	s->len = strlen(str) + 1;
+	s->len = (unsigned int)strlen(str) + 1;
 	s->sym = malloc(s->len + 1);
 	if (!s->sym) {
 		fprintf(stderr, "kallsyms failure: "
@@ -172,7 +172,7 @@ static int read_symbol(FILE *in, struct sym_entry *s)
 		exit(EXIT_FAILURE);
 	}
 	strcpy((char *)s->sym + 1, str);
-	s->sym[0] = stype;
+	s->sym[0] = (unsigned char)stype;
 
 	s->percpu_absolute = 0;
 
@@ -183,7 +183,7 @@ static int read_symbol(FILE *in, struct sym_entry *s)
 }
 
 static int symbol_in_range(struct sym_entry *s, struct addr_range *ranges,
-			   int entries)
+			   size_t entries)
 {
 	size_t i;
 	struct addr_range *ar;
@@ -261,7 +261,7 @@ static int symbol_valid(struct sym_entry *s)
 			return 0;
 
 	for (i = 0; special_suffixes[i]; i++) {
-		int l = strlen(sym_name) - strlen(special_suffixes[i]);
+		ssize_t l = (ssize_t)(strlen(sym_name) - strlen(special_suffixes[i]));
 
 		if (l >= 0 && strcmp(sym_name + l, special_suffixes[i]) == 0)
 			return 0;
@@ -305,14 +305,15 @@ static void output_label(char *label)
  * might still be compressed itself, so the function needs to be recursive */
 static int expand_symbol(unsigned char *data, int len, char *result)
 {
-	int c, rlen, total=0;
+	int rlen, total=0;
+	unsigned char c;
 
 	while (len) {
 		c = *data;
 		/* if the table holds a single char that is the same as the one
 		 * we are looking for, then end the search */
 		if (best_table[c][0]==c && best_table_len[c]==1) {
-			*result++ = c;
+			*result++ = (char)c;
 			total++;
 		} else {
 			/* if not, recurse and expand */
@@ -466,20 +467,20 @@ static void write_src(void)
 /* table lookup compression functions */
 
 /* count all the possible tokens in a symbol */
-static void learn_symbol(unsigned char *symbol, int len)
+static void learn_symbol(unsigned char *symbol, unsigned int len)
 {
-	int i;
+	unsigned int i;
 
-	for (i = 0; i < len - 1; i++)
+	for (i = 0; i + 1 < len; i++)
 		token_profit[ symbol[i] + (symbol[i + 1] << 8) ]++;
 }
 
 /* decrease the count for all the possible tokens in a symbol */
-static void forget_symbol(unsigned char *symbol, int len)
+static void forget_symbol(unsigned char *symbol, unsigned int len)
 {
-	int i;
+	unsigned int i;
 
-	for (i = 0; i < len - 1; i++)
+	for (i = 0; i + 1 < len; i++)
 		token_profit[ symbol[i] + (symbol[i + 1] << 8) ]--;
 }
 
@@ -500,11 +501,11 @@ static void build_initial_tok_table(void)
 	table_cnt = pos;
 }
 
-static void *find_token(unsigned char *str, int len, unsigned char *token)
+static void *find_token(unsigned char *str, unsigned int len, unsigned char *token)
 {
-	int i;
+	unsigned int i;
 
-	for (i = 0; i < len - 1; i++) {
+	for (i = 0; i + 1 < len; i++) {
 		if (str[i] == token[0] && str[i+1] == token[1])
 			return &str[i];
 	}
@@ -533,7 +534,7 @@ static void compress_symbols(unsigned char *str, int idx)
 		size = len;
 
 		do {
-			*p2 = idx;
+			*p2 = (unsigned char)idx;
 			p2++;
 			size -= (p2 - p1);
 			memmove(p2, p2 + 1, size);
@@ -603,7 +604,8 @@ static void optimize_result(void)
 /* start by placing the symbols that are actually used on the table */
 static void insert_real_symbols_in_table(void)
 {
-	unsigned int i, j, c;
+	unsigned int i, j;
+	unsigned char c;
 
 	memset(best_table, 0, sizeof(best_table));
 	memset(best_table_len, 0, sizeof(best_table_len));
@@ -636,7 +638,7 @@ static void optimize_token_table(void)
 static int may_be_linker_script_provide_symbol(const struct sym_entry *se)
 {
 	const char *symbol = (char *)se->sym + 1;
-	int len = se->len - 1;
+	int len = (int)(se->len - 1);
 
 	if (len < 8)
 		return 0;
@@ -674,7 +676,7 @@ static int prefix_underscores_count(const char *str)
 	while (*tail == '_')
 		tail++;
 
-	return tail - str;
+	return (int)(tail - str);
 }
 
 static int compare_symbols(const void *a, const void *b)
@@ -711,7 +713,7 @@ static int compare_symbols(const void *a, const void *b)
 		return wa - wb;
 
 	/* sort by initial order, so that other symbols are left undisturbed */
-	return sa->start_pos - sb->start_pos;
+	return (int)(sa->start_pos - sb->start_pos);
 }
 
 static void sort_symbols(void)
diff --git a/scripts/kconfig/conf.c b/scripts/kconfig/conf.c
index 866369f10ff8..224c7e065bee 100644
--- a/scripts/kconfig/conf.c
+++ b/scripts/kconfig/conf.c
@@ -58,7 +58,7 @@ static void print_help(struct menu *menu)
 static void strip(char *str)
 {
 	char *p = str;
-	int l;
+	size_t l;
 
 	while ((isspace(*p)))
 		p++;
@@ -532,7 +532,7 @@ int main(int ac, char **av)
 			seed_env = getenv("KCONFIG_SEED");
 			if( seed_env && *seed_env ) {
 				char *endp;
-				int tmp = (int)strtol(seed_env, &endp, 0);
+				unsigned int tmp = (unsigned int)strtol(seed_env, &endp, 0);
 				if (*endp == '\0') {
 					seed = tmp;
 				}
diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index 297b079ae4d9..fc2c1e709b3e 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -209,7 +209,7 @@ static int add_byte(int c, char **lineptr, size_t slen, size_t *n)
 		*n = new_size;
 	}
 
-	(*lineptr)[slen] = c;
+	(*lineptr)[slen] = (char)c;
 
 	return 0;
 }
@@ -234,7 +234,7 @@ static ssize_t compat_getline(char **lineptr, size_t *n, FILE *stream)
 			*lineptr = line;
 			if (slen == 0)
 				return -1;
-			return slen;
+			return (ssize_t)slen;
 		default:
 			if (add_byte(c, &line, slen, n) < 0)
 				goto e_out;
@@ -758,7 +758,7 @@ int conf_write(const char *name)
 			strcat(dirname, "/");
 			basename = conf_get_configname();
 		} else if ((slash = strrchr(name, '/'))) {
-			int size = slash - name + 1;
+			size_t size = slash - name + 1;
 			memcpy(dirname, name, size);
 			dirname[size] = 0;
 			if (slash[1])
@@ -910,7 +910,7 @@ static int conf_split_config(void)
 		s = sym->name;
 		d = path;
 		while ((c = *s++)) {
-			c = tolower(c);
+			c = (char)tolower(c);
 			*d++ = (c == '_') ? '/' : c;
 		}
 		strcpy(d, ".h");
@@ -1137,7 +1137,7 @@ bool conf_set_all_new_symbols(enum conf_def_mode mode)
 		n = 0;
 		while( env && *env ) {
 			char *endp;
-			int tmp = strtol( env, &endp, 10 );
+			int tmp = (int)strtol( env, &endp, 10 );
 			if( tmp >= 0 && tmp <= 100 ) {
 				p[n++] = tmp;
 			} else {
diff --git a/scripts/kconfig/expr.c b/scripts/kconfig/expr.c
index cbf4996dd9c1..db5813106674 100644
--- a/scripts/kconfig/expr.c
+++ b/scripts/kconfig/expr.c
@@ -1191,7 +1191,7 @@ static void expr_print_gstr_helper(void *data, struct symbol *sym, const char *s
 
 		last_line_length = strlen(gs->s) - (last_cr - gs->s);
 
-		if ((last_line_length + extra_length) > gs->max_width)
+		if ((int)(last_line_length + extra_length) > gs->max_width)
 			str_append(gs, "\\\n");
 	}
 
diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index 59f0d152667a..facfc99caa52 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -113,7 +113,7 @@ void menu_set_type(int type)
 {
 	struct symbol *sym = current_entry->sym;
 
-	if (sym->type == type)
+	if ((int)sym->type == type)
 		return;
 	if (sym->type == S_UNKNOWN) {
 		sym->type = type;
diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 981d535dfcad..d24f9f8ca726 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -992,8 +992,8 @@ static int sym_rel_comp(const void *sym1, const void *sym2)
 	 * exactly; if this is the case, we can't decide which comes first,
 	 * and we fallback to sorting alphabetically.
 	 */
-	exact1 = (s1->eo - s1->so) == strlen(s1->sym->name);
-	exact2 = (s2->eo - s2->so) == strlen(s2->sym->name);
+	exact1 = (size_t)(s1->eo - s1->so) == strlen(s1->sym->name);
+	exact2 = (size_t)(s2->eo - s2->so) == strlen(s2->sym->name);
 	if (exact1 && !exact2)
 		return -1;
 	if (!exact1 && exact2)
diff --git a/scripts/kconfig/zconf.hash.c_shipped b/scripts/kconfig/zconf.hash.c_shipped
index 360a62df2b5e..3e6b97697aa5 100644
--- a/scripts/kconfig/zconf.hash.c_shipped
+++ b/scripts/kconfig/zconf.hash.c_shipped
@@ -73,7 +73,7 @@ kconf_id_hash (register const char *str, register unsigned int len)
       73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
       73, 73, 73, 73, 73, 73
     };
-  register int hval = len;
+  register unsigned int hval = len;
 
   switch (hval)
     {
@@ -273,9 +273,9 @@ kconf_id_lookup (register const char *str, register unsigned int len)
 
   if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
     {
-      register int key = kconf_id_hash (str, len);
+      register unsigned int key = kconf_id_hash (str, len);
 
-      if (key <= MAX_HASH_VALUE && key >= 0)
+      if (key <= MAX_HASH_VALUE)
         {
           register int o = wordlist[key].name;
           if (o >= 0)
diff --git a/scripts/mod/file2alias.c b/scripts/mod/file2alias.c
index 14d840e01917..46ed5b7deb75 100644
--- a/scripts/mod/file2alias.c
+++ b/scripts/mod/file2alias.c
@@ -128,7 +128,7 @@ do {                                                            \
 /* End in a wildcard, for future extension */
 static inline void add_wildcard(char *str)
 {
-	int len = strlen(str);
+	size_t len = strlen(str);
 
 	if (str[len - 1] != '*')
 		strcat(str + len, "*");
@@ -136,7 +136,7 @@ static inline void add_wildcard(char *str)
 
 static inline void add_uuid(char *str, uuid_le uuid)
 {
-	int len = strlen(str);
+	size_t len = strlen(str);
 
 	sprintf(str + len, "%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x",
 		uuid.b[3], uuid.b[2], uuid.b[1], uuid.b[0],
@@ -156,7 +156,7 @@ static void device_id_check(const char *modname, const char *device_id,
 			    unsigned long size, unsigned long id_size,
 			    void *symval)
 {
-	int i;
+	unsigned long i;
 
 	if (size % id_size || size < id_size) {
 		fatal("%s: sizeof(struct %s_device_id)=%lu is not a modulo "
@@ -229,7 +229,7 @@ static void do_usb_entry(void *symval,
 				range_hi);
 		}
 	}
-	if (bcdDevice_initial_digits < (sizeof(bcdDevice_lo) * 2 - 1))
+	if (bcdDevice_initial_digits < (int)(sizeof(bcdDevice_lo) * 2 - 1))
 		strcat(alias, "*");
 
 	ADD(alias, "dc", match_flags&USB_DEVICE_ID_MATCH_DEV_CLASS,
@@ -264,7 +264,7 @@ static unsigned int incbcd(unsigned int *bcd,
 
 	/* If bcd is not in BCD format, just increment */
 	if (max > 0x9) {
-		*bcd += inc;
+		*bcd += (unsigned int)inc;
 		return init;
 	}
 
@@ -278,7 +278,7 @@ static unsigned int incbcd(unsigned int *bcd,
 	}
 
 	/* Do our increment/decrement */
-	dec += inc;
+	dec += (unsigned long long)inc;
 	*bcd  = 0;
 
 	/* Convert back to BCD */
@@ -312,7 +312,7 @@ static void do_usb_entry_multi(void *symval, struct module *mod)
 
 	/* Figure out if this entry is in bcd or hex format */
 	max = 0x9; /* Default to decimal format */
-	for (ndigits = 0 ; ndigits < sizeof(bcdDevice_lo) * 2 ; ndigits++) {
+	for (ndigits = 0 ; ndigits < (int)sizeof(bcdDevice_lo) * 2 ; ndigits++) {
 		clo = (devlo >> (ndigits << 2)) & 0xf;
 		chi = ((devhi > 0x9999 ? 0x9999 : devhi) >> (ndigits << 2)) & 0xf;
 		if (clo > max || chi > max) {
@@ -426,8 +426,8 @@ static int do_hid_entry(const char *filename,
 	sprintf(alias, "hid:");
 	ADD(alias, "b", bus != HID_BUS_ANY, bus);
 	ADD(alias, "g", group != HID_GROUP_ANY, group);
-	ADD(alias, "v", vendor != HID_ANY_ID, vendor);
-	ADD(alias, "p", product != HID_ANY_ID, product);
+	ADD(alias, "v", vendor != (unsigned int)HID_ANY_ID, vendor);
+	ADD(alias, "p", product != (unsigned int)HID_ANY_ID, product);
 
 	return 1;
 }
@@ -474,17 +474,17 @@ static int do_pci_entry(const char *filename,
 	DEF_FIELD(symval, pci_device_id, class_mask);
 
 	strcpy(alias, "pci:");
-	ADD(alias, "v", vendor != PCI_ANY_ID, vendor);
-	ADD(alias, "d", device != PCI_ANY_ID, device);
-	ADD(alias, "sv", subvendor != PCI_ANY_ID, subvendor);
-	ADD(alias, "sd", subdevice != PCI_ANY_ID, subdevice);
-
-	baseclass = (class) >> 16;
-	baseclass_mask = (class_mask) >> 16;
-	subclass = (class) >> 8;
-	subclass_mask = (class_mask) >> 8;
-	interface = class;
-	interface_mask = class_mask;
+	ADD(alias, "v", vendor != (unsigned int)PCI_ANY_ID, vendor);
+	ADD(alias, "d", device != (unsigned int)PCI_ANY_ID, device);
+	ADD(alias, "sv", subvendor != (unsigned int)PCI_ANY_ID, subvendor);
+	ADD(alias, "sd", subdevice != (unsigned int)PCI_ANY_ID, subdevice);
+
+	baseclass = (unsigned char)((class) >> 16);
+	baseclass_mask = (unsigned char)((class_mask) >> 16);
+	subclass = (unsigned char)((class) >> 8);
+	subclass_mask = (unsigned char)((class_mask) >> 8);
+	interface = (unsigned char)class;
+	interface_mask = (unsigned char)class_mask;
 
 	if ((baseclass_mask != 0 && baseclass_mask != 0xFF)
 	    || (subclass_mask != 0 && subclass_mask != 0xFF)
@@ -611,7 +611,7 @@ static void do_pnp_device_entry(void *symval, unsigned long size,
 				struct module *mod)
 {
 	const unsigned long id_size = SIZE_pnp_device_id;
-	const unsigned int count = (size / id_size)-1;
+	const unsigned int count = (unsigned int)((size / id_size)-1);
 	unsigned int i;
 
 	device_id_check(mod->name, "pnp", size, id_size, symval);
@@ -619,14 +619,14 @@ static void do_pnp_device_entry(void *symval, unsigned long size,
 	for (i = 0; i < count; i++) {
 		DEF_FIELD_ADDR(symval + i*id_size, pnp_device_id, id);
 		char acpi_id[sizeof(*id)];
-		int j;
+		size_t j;
 
 		buf_printf(&mod->dev_table_buf,
 			   "MODULE_ALIAS(\"pnp:d%s*\");\n", *id);
 
 		/* fix broken pnp bus lowercasing */
 		for (j = 0; j < sizeof(acpi_id); j++)
-			acpi_id[j] = toupper((*id)[j]);
+			acpi_id[j] = (char)toupper((*id)[j]);
 		buf_printf(&mod->dev_table_buf,
 			   "MODULE_ALIAS(\"acpi*:%s:*\");\n", acpi_id);
 	}
@@ -637,7 +637,7 @@ static void do_pnp_card_entries(void *symval, unsigned long size,
 				struct module *mod)
 {
 	const unsigned long id_size = SIZE_pnp_card_device_id;
-	const unsigned int count = (size / id_size)-1;
+	const unsigned int count = (unsigned int)((size / id_size)-1);
 	unsigned int i;
 
 	device_id_check(mod->name, "pnp", size, id_size, symval);
@@ -648,7 +648,7 @@ static void do_pnp_card_entries(void *symval, unsigned long size,
 
 		for (j = 0; j < PNP_MAX_DEVICES; j++) {
 			const char *id = (char *)(*devs)[j].id;
-			int i2, j2;
+			unsigned int i2, j2;
 			int dup = 0;
 
 			if (!id[0])
@@ -680,8 +680,8 @@ static void do_pnp_card_entries(void *symval, unsigned long size,
 					   "MODULE_ALIAS(\"pnp:d%s*\");\n", id);
 
 				/* fix broken pnp bus lowercasing */
-				for (k = 0; k < sizeof(acpi_id); k++)
-					acpi_id[k] = toupper(id[k]);
+				for (k = 0; k < (int)sizeof(acpi_id); k++)
+					acpi_id[k] = (char)toupper(id[k]);
 				buf_printf(&mod->dev_table_buf,
 					   "MODULE_ALIAS(\"acpi*:%s:*\");\n", acpi_id);
 			}
@@ -930,7 +930,7 @@ ADD_TO_DEVTABLE("virtio", virtio_device_id, do_virtio_entry);
 static int do_vmbus_entry(const char *filename, void *symval,
 			  char *alias)
 {
-	int i;
+	size_t i;
 	DEF_FIELD_ADDR(symval, hv_vmbus_device_id, guid);
 	char guid_name[(sizeof(*guid) + 1) * 2];
 
@@ -999,7 +999,8 @@ static void dmi_ascii_filter(char *d, const char *s)
 static int do_dmi_entry(const char *filename, void *symval,
 			char *alias)
 {
-	int i, j;
+	size_t i;
+	int j;
 	DEF_FIELD_ADDR(symval, dmi_system_id, matches);
 	sprintf(alias, "dmi*");
 
@@ -1091,8 +1092,8 @@ static int do_ipack_entry(const char *filename,
 	DEF_FIELD(symval, ipack_device_id, device);
 	strcpy(alias, "ipack:");
 	ADD(alias, "f", format != IPACK_ANY_FORMAT, format);
-	ADD(alias, "v", vendor != IPACK_ANY_ID, vendor);
-	ADD(alias, "d", device != IPACK_ANY_ID, device);
+	ADD(alias, "v", vendor != (unsigned int)IPACK_ANY_ID, vendor);
+	ADD(alias, "d", device != (unsigned int)IPACK_ANY_ID, device);
 	add_wildcard(alias);
 	return 1;
 }
@@ -1290,7 +1291,7 @@ static int do_hda_entry(const char *filename, void *symval, char *alias)
 ADD_TO_DEVTABLE("hdaudio", hda_device_id, do_hda_entry);
 
 /* Does namelen bytes of name exactly match the symbol? */
-static bool sym_is(const char *name, unsigned namelen, const char *symbol)
+static bool sym_is(const char *name, size_t namelen, const char *symbol)
 {
 	if (namelen != strlen(symbol))
 		return false;
@@ -1329,7 +1330,7 @@ void handle_moddevtable(struct module *mod, struct elf_info *info,
 	void *symval;
 	char *zeros = NULL;
 	const char *name, *identifier;
-	unsigned int namelen;
+	size_t namelen;
 
 	/* We're looking for a section relative symbol */
 	if (!sym->st_shndx || get_secindex(info, sym) >= info->num_sections)
@@ -1352,7 +1353,7 @@ void handle_moddevtable(struct module *mod, struct elf_info *info,
 	identifier = strstr(name, "__");
 	if (!identifier)
 		return;
-	namelen = identifier - name;
+	namelen = (size_t)(identifier - name);
 
 	/* Handle all-NULL symbols allocated into .bss */
 	if (info->sechdrs[get_secindex(info, sym)].sh_type & SHT_NOBITS) {
diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 48958d3cec9e..c4b248b41bbd 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1204,7 +1204,7 @@ static int secref_whitelist(const struct sectioncheck *mismatch,
  * In other cases the symbol needs to be looked up in the symbol table
  * based on section and address.
  *  **/
-static Elf_Sym *find_elf_symbol(struct elf_info *elf, Elf64_Sword addr,
+static Elf_Sym *find_elf_symbol(struct elf_info *elf, Elf_Addr addr,
 				Elf_Sym *relsym)
 {
 	Elf_Sym *sym;
@@ -1897,7 +1897,7 @@ static void section_rel(const char *modname, struct elf_info *elf,
 static void check_sec_ref(struct module *mod, const char *modname,
 			  struct elf_info *elf)
 {
-	int i;
+	unsigned int i;
 	Elf_Shdr *sechdrs = elf->sechdrs;
 
 	/* Walk through all sections */
@@ -2262,7 +2262,7 @@ static void write_if_changed(struct buffer *b, const char *fname)
 		goto close_write;
 
 	tmp = NOFAIL(malloc(b->pos));
-	if (fread(tmp, 1, b->pos, file) != b->pos)
+	if (fread(tmp, 1, b->pos, file) != (size_t)b->pos)
 		goto free_write;
 
 	if (memcmp(tmp, b->p, b->pos) != 0)
@@ -2282,7 +2282,7 @@ static void write_if_changed(struct buffer *b, const char *fname)
 		perror(fname);
 		exit(1);
 	}
-	if (fwrite(b->p, 1, b->pos, file) != b->pos) {
+	if (fwrite(b->p, 1, b->pos, file) != (size_t)b->pos) {
 		perror(fname);
 		exit(1);
 	}
diff --git a/scripts/mod/sumversion.c b/scripts/mod/sumversion.c
index 944418da9fe3..0075d74e4562 100644
--- a/scripts/mod/sumversion.c
+++ b/scripts/mod/sumversion.c
@@ -199,20 +199,20 @@ static void md4_update(struct md4_ctx *mctx,
 static void md4_final_ascii(struct md4_ctx *mctx, char *out, unsigned int len)
 {
 	const unsigned int offset = mctx->byte_count & 0x3f;
-	char *p = (char *)mctx->block + offset;
-	int padding = 56 - (offset + 1);
+	unsigned char *p = (unsigned char *)mctx->block + offset;
+	int padding = 56 - (int)(offset + 1);
 
 	*p++ = 0x80;
 	if (padding < 0) {
-		memset(p, 0x00, padding + sizeof (uint64_t));
+		memset(p, 0x00, (size_t)(padding + (int)sizeof (uint64_t)));
 		md4_transform_helper(mctx);
-		p = (char *)mctx->block;
+		p = (unsigned char *)mctx->block;
 		padding = 56;
 	}
 
-	memset(p, 0, padding);
-	mctx->block[14] = mctx->byte_count << 3;
-	mctx->block[15] = mctx->byte_count >> 29;
+	memset(p, 0, (size_t)padding);
+	mctx->block[14] = (uint32_t)(mctx->byte_count << 3);
+	mctx->block[15] = (uint32_t)(mctx->byte_count >> 29);
 	le32_to_cpu_array(mctx->block, (sizeof(mctx->block) -
 			  sizeof(uint64_t)) / sizeof(uint32_t));
 	md4_transform(mctx->hash, mctx->block);
@@ -222,12 +222,12 @@ static void md4_final_ascii(struct md4_ctx *mctx, char *out, unsigned int len)
 		 mctx->hash[0], mctx->hash[1], mctx->hash[2], mctx->hash[3]);
 }
 
-static inline void add_char(unsigned char c, struct md4_ctx *md)
+static inline void add_char(char c, struct md4_ctx *md)
 {
-	md4_update(md, &c, 1);
+	md4_update(md, (unsigned char *)&c, 1);
 }
 
-static int parse_string(const char *file, unsigned long len,
+static unsigned long parse_string(const char *file, unsigned long len,
 			struct md4_ctx *md)
 {
 	unsigned long i;
@@ -241,7 +241,7 @@ static int parse_string(const char *file, unsigned long len,
 	return i;
 }
 
-static int parse_comment(const char *file, unsigned long len)
+static unsigned long parse_comment(const char *file, unsigned long len)
 {
 	unsigned long i;
 
@@ -293,7 +293,7 @@ static int parse_file(const char *fname, struct md4_ctx *md)
 /* Check whether the file is a static library or not */
 static int is_static_library(const char *objfile)
 {
-	int len = strlen(objfile);
+	size_t len = strlen(objfile);
 	if (objfile[len - 2] == '.' && objfile[len - 1] == 'a')
 		return 1;
 	else
@@ -307,15 +307,16 @@ static int parse_source_files(const char *objfile, struct md4_ctx *md)
 	char *cmd, *file, *line, *dir;
 	const char *base;
 	unsigned long flen, pos = 0;
-	int dirlen, ret = 0, check_files = 0;
+	int ret = 0, check_files = 0;
+	size_t dirlen;
 
 	cmd = NOFAIL(malloc(strlen(objfile) + sizeof("..cmd")));
 
 	base = strrchr(objfile, '/');
 	if (base) {
 		base++;
-		dirlen = base - objfile;
-		sprintf(cmd, "%.*s.%s.cmd", dirlen, objfile, base);
+		dirlen = (size_t)(base - objfile);
+		sprintf(cmd, "%.*s.%s.cmd", (int)dirlen, objfile, base);
 	} else {
 		dirlen = 0;
 		sprintf(cmd, ".%s.cmd", objfile);
@@ -464,13 +465,13 @@ static void write_version(const char *filename, const char *sum,
 		return;
 	}
 
-	if (lseek(fd, offset, SEEK_SET) == (off_t)-1) {
+	if (lseek(fd, (off_t)offset, SEEK_SET) == (off_t)-1) {
 		warn("changing sum in %s:%lu failed: %s\n",
 			filename, offset, strerror(errno));
 		goto out;
 	}
 
-	if (write(fd, sum, strlen(sum)+1) != strlen(sum)+1) {
+	if (write(fd, sum, strlen(sum)+1) != (ssize_t)(strlen(sum)+1)) {
 		warn("writing sum in %s failed: %s\n",
 			filename, strerror(errno));
 		goto out;
@@ -481,7 +482,7 @@ out:
 
 static int strip_rcs_crap(char *version)
 {
-	unsigned int len, full_len;
+	size_t len, full_len;
 
 	if (strncmp(version, "$Revision", strlen("$Revision")) != 0)
 		return 0;
diff --git a/scripts/pnmtologo.c b/scripts/pnmtologo.c
index 4718d7895f0b..14ee56460b6f 100644
--- a/scripts/pnmtologo.c
+++ b/scripts/pnmtologo.c
@@ -83,7 +83,8 @@ static void usage(void) __attribute ((noreturn));
 
 static unsigned int get_number(FILE *fp)
 {
-    int c, val;
+    int c;
+    unsigned int val;
 
     /* Skip leading whitespace */
     do {
@@ -103,7 +104,7 @@ static unsigned int get_number(FILE *fp)
     /* Parse decimal number */
     val = 0;
     while (isdigit(c)) {
-	val = 10*val+c-'0';
+	val = 10*val+(unsigned int)(c-'0');
 	/* some PBM are 'broken'; GiMP for example exports a PBM without space
 	 * between the digits. This is Ok cause we know a PBM can only have a '1'
 	 * or a '0' for the digit. */
@@ -116,10 +117,10 @@ static unsigned int get_number(FILE *fp)
     return val;
 }
 
-static unsigned int get_number255(FILE *fp, unsigned int maxval)
+static unsigned char get_number255(FILE *fp, unsigned int maxval)
 {
     unsigned int val = get_number(fp);
-    return (255*val+maxval/2)/maxval;
+    return (unsigned char)((255*val+maxval/2)/maxval);
 }
 
 static void read_image(void)
@@ -177,7 +178,7 @@ static void read_image(void)
 	    for (i = 0; i < logo_height; i++)
 		for (j = 0; j < logo_width; j++)
 		    logo_data[i][j].red = logo_data[i][j].green =
-			logo_data[i][j].blue = 255*(1-get_number(fp));
+			logo_data[i][j].blue = (unsigned char)(255*(1-get_number(fp)));
 	    break;
 
 	case '2':
@@ -334,7 +335,7 @@ static void write_logo_vga16(void)
 	    for (k = 0; k < 16; k++)
 		if (is_equal(logo_data[i][j], clut_vga16[k]))
 		    break;
-	    val = k<<4;
+	    val = (unsigned char)(k<<4);
 	    if (++j < logo_width) {
 		for (k = 0; k < 16; k++)
 		    if (is_equal(logo_data[i][j], clut_vga16[k]))
@@ -376,7 +377,7 @@ static void write_logo_clut224(void)
 	    for (k = 0; k < logo_clutsize; k++)
 		if (is_equal(logo_data[i][j], logo_clut[k]))
 		    break;
-	    write_hex(k+32);
+	    write_hex((unsigned char)(k+32));
 	}
     fputs("\n};\n\n", out);
 
diff --git a/scripts/selinux/genheaders/genheaders.c b/scripts/selinux/genheaders/genheaders.c
index 539855ff31f9..48af6aa50c5c 100644
--- a/scripts/selinux/genheaders/genheaders.c
+++ b/scripts/selinux/genheaders/genheaders.c
@@ -34,7 +34,7 @@ static char *stoupperx(const char *s)
 	}
 
 	for (p = s2; *p; p++)
-		*p = toupper(*p);
+		*p = (char)toupper(*p);
 	return s2;
 }
 
@@ -75,7 +75,7 @@ int main(int argc, char *argv[])
 	for (i = 0; secclass_map[i].name; i++) {
 		struct security_class_mapping *map = &secclass_map[i];
 		fprintf(fout, "#define SECCLASS_%s", map->name);
-		for (j = 0; j < max(1, 40 - strlen(map->name)); j++)
+		for (j = 0; j < max(1, 40 - (int)strlen(map->name)); j++)
 			fprintf(fout, " ");
 		fprintf(fout, "%2d\n", i+1);
 	}
@@ -85,7 +85,7 @@ int main(int argc, char *argv[])
 	for (i = 1; i < isids_len; i++) {
 		const char *s = initial_sid_to_string[i];
 		fprintf(fout, "#define SECINITSID_%s", s);
-		for (j = 0; j < max(1, 40 - strlen(s)); j++)
+		for (j = 0; j < max(1, 40 - (int)strlen(s)); j++)
 			fprintf(fout, " ");
 		fprintf(fout, "%2d\n", i);
 	}
@@ -126,7 +126,7 @@ int main(int argc, char *argv[])
 		for (j = 0; map->perms[j]; j++) {
 			fprintf(fout, "#define %s__%s", map->name,
 				map->perms[j]);
-			for (k = 0; k < max(1, 40 - strlen(map->name) - strlen(map->perms[j])); k++)
+			for (k = 0; k < max(1, 40 - (int)strlen(map->name) - (int)strlen(map->perms[j])); k++)
 				fprintf(fout, " ");
 			fprintf(fout, "0x%08xUL\n", (1<<j));
 		}
diff --git a/scripts/sortextable.c b/scripts/sortextable.c
index f453b7ce99d6..c7c01902107a 100644
--- a/scripts/sortextable.c
+++ b/scripts/sortextable.c
@@ -69,7 +69,7 @@ static void
 cleanup(void)
 {
 	if (!mmap_failed)
-		munmap(ehdr_curr, sb.st_size);
+		munmap(ehdr_curr, (size_t)sb.st_size);
 	close(fd_map);
 }
 
@@ -99,7 +99,7 @@ static void *mmap_file(char const *fname)
 		fprintf(stderr, "not a regular file: %s\n", fname);
 		fail_file();
 	}
-	addr = mmap(0, sb.st_size, PROT_READ|PROT_WRITE, MAP_SHARED,
+	addr = mmap(0, (size_t)sb.st_size, PROT_READ|PROT_WRITE, MAP_SHARED,
 		    fd_map, 0);
 	if (addr == MAP_FAILED) {
 		mmap_failed = 1;
@@ -166,7 +166,7 @@ static void (*w8)(uint64_t, uint64_t *);
 static void (*w)(uint32_t, uint32_t *);
 static void (*w2)(uint16_t, uint16_t *);
 
-typedef void (*table_sort_t)(char *, int);
+typedef void (*table_sort_t)(char *, size_t);
 
 /*
  * Move reserved section indices SHN_LORESERVE..SHN_HIRESERVE out of
@@ -209,9 +209,9 @@ static int compare_relative_table(const void *a, const void *b)
 	return 0;
 }
 
-static void x86_sort_relative_table(char *extab_image, int image_size)
+static void x86_sort_relative_table(char *extab_image, size_t image_size)
 {
-	int i;
+	size_t i;
 
 	i = 0;
 	while (i < image_size) {
@@ -238,9 +238,9 @@ static void x86_sort_relative_table(char *extab_image, int image_size)
 	}
 }
 
-static void sort_relative_table(char *extab_image, int image_size)
+static void sort_relative_table(char *extab_image, size_t image_size)
 {
-	int i;
+	size_t i;
 
 	/*
 	 * Do the same thing the runtime sort does, first normalize to
diff --git a/scripts/sortextable.h b/scripts/sortextable.h
index ba8700428e21..53aed5946dee 100644
--- a/scripts/sortextable.h
+++ b/scripts/sortextable.h
@@ -103,14 +103,14 @@ do_func(Elf_Ehdr *ehdr, char const *const fname, table_sort_t custom_sort)
 	Elf_Sym *sort_needed_sym;
 	Elf_Shdr *sort_needed_sec;
 	Elf_Rel *relocs = NULL;
-	int relocs_size = 0;
+	size_t relocs_size = 0;
 	uint32_t *sort_done_location;
 	const char *secstrtab;
 	const char *strtab;
 	char *extab_image;
-	int extab_index = 0;
-	int i;
-	int idx;
+	unsigned int extab_index = 0;
+	unsigned int i;
+	unsigned int idx;
 	unsigned int num_sections;
 	unsigned int secindex_strings;
 
@@ -118,7 +118,7 @@ do_func(Elf_Ehdr *ehdr, char const *const fname, table_sort_t custom_sort)
 
 	num_sections = r2(&ehdr->e_shnum);
 	if (num_sections == SHN_UNDEF)
-		num_sections = _r(&shdr[0].sh_size);
+		num_sections = (unsigned int)_r(&shdr[0].sh_size);
 
 	secindex_strings = r2(&ehdr->e_shstrndx);
 	if (secindex_strings == SHN_XINDEX)
@@ -167,7 +167,7 @@ do_func(Elf_Ehdr *ehdr, char const *const fname, table_sort_t custom_sort)
 	if (custom_sort) {
 		custom_sort(extab_image, _r(&extab_sec->sh_size));
 	} else {
-		int num_entries = _r(&extab_sec->sh_size) / extable_ent_size;
+		size_t num_entries = _r(&extab_sec->sh_size) / extable_ent_size;
 		qsort(extab_image, num_entries,
 		      extable_ent_size, compare_extable);
 	}
@@ -195,7 +195,7 @@ do_func(Elf_Ehdr *ehdr, char const *const fname, table_sort_t custom_sort)
 		fail_file();
 	}
 	sort_needed_sec = &shdr[get_secindex(r2(&sym->st_shndx),
-					     sort_needed_sym - symtab,
+					     (unsigned int)(sort_needed_sym - symtab),
 					     symtab_shndx_start)];
 	sort_done_location = (void *)ehdr +
 		_r(&sort_needed_sec->sh_offset) +
diff --git a/tools/include/tools/be_byteshift.h b/tools/include/tools/be_byteshift.h
index 84c17d836578..d94f67aa2707 100644
--- a/tools/include/tools/be_byteshift.h
+++ b/tools/include/tools/be_byteshift.h
@@ -5,12 +5,12 @@
 
 static inline uint16_t __get_unaligned_be16(const uint8_t *p)
 {
-	return p[0] << 8 | p[1];
+	return (uint16_t)(p[0] << 8 | p[1]);
 }
 
 static inline uint32_t __get_unaligned_be32(const uint8_t *p)
 {
-	return p[0] << 24 | p[1] << 16 | p[2] << 8 | p[3];
+	return (uint32_t)(p[0] << 24 | p[1] << 16 | p[2] << 8 | p[3]);
 }
 
 static inline uint64_t __get_unaligned_be64(const uint8_t *p)
@@ -22,19 +22,19 @@ static inline uint64_t __get_unaligned_be64(const uint8_t *p)
 static inline void __put_unaligned_be16(uint16_t val, uint8_t *p)
 {
 	*p++ = val >> 8;
-	*p++ = val;
+	*p++ = (uint8_t)val;
 }
 
 static inline void __put_unaligned_be32(uint32_t val, uint8_t *p)
 {
 	__put_unaligned_be16(val >> 16, p);
-	__put_unaligned_be16(val, p + 2);
+	__put_unaligned_be16((uint16_t)val, p + 2);
 }
 
 static inline void __put_unaligned_be64(uint64_t val, uint8_t *p)
 {
 	__put_unaligned_be32(val >> 32, p);
-	__put_unaligned_be32(val, p + 4);
+	__put_unaligned_be32((uint32_t)val, p + 4);
 }
 
 static inline uint16_t get_unaligned_be16(const void *p)
diff --git a/tools/include/tools/le_byteshift.h b/tools/include/tools/le_byteshift.h
index 8fe9f2488ec7..6a0be9a612de 100644
--- a/tools/include/tools/le_byteshift.h
+++ b/tools/include/tools/le_byteshift.h
@@ -5,12 +5,12 @@
 
 static inline uint16_t __get_unaligned_le16(const uint8_t *p)
 {
-	return p[0] | p[1] << 8;
+	return (uint16_t)(p[0] | p[1] << 8);
 }
 
 static inline uint32_t __get_unaligned_le32(const uint8_t *p)
 {
-	return p[0] | p[1] << 8 | p[2] << 16 | p[3] << 24;
+	return (uint32_t)(p[0] | p[1] << 8 | p[2] << 16 | p[3] << 24);
 }
 
 static inline uint64_t __get_unaligned_le64(const uint8_t *p)
@@ -21,20 +21,20 @@ static inline uint64_t __get_unaligned_le64(const uint8_t *p)
 
 static inline void __put_unaligned_le16(uint16_t val, uint8_t *p)
 {
-	*p++ = val;
+	*p++ = (uint8_t)val;
 	*p++ = val >> 8;
 }
 
 static inline void __put_unaligned_le32(uint32_t val, uint8_t *p)
 {
 	__put_unaligned_le16(val >> 16, p + 2);
-	__put_unaligned_le16(val, p);
+	__put_unaligned_le16((uint16_t)val, p);
 }
 
 static inline void __put_unaligned_le64(uint64_t val, uint8_t *p)
 {
 	__put_unaligned_le32(val >> 32, p + 4);
-	__put_unaligned_le32(val, p);
+	__put_unaligned_le32((uint32_t)val, p);
 }
 
 static inline uint16_t get_unaligned_le16(const void *p)
diff --git a/usr/gen_init_cpio.c b/usr/gen_init_cpio.c
index 225ad244cf88..b942fdd67bfc 100644
--- a/usr/gen_init_cpio.c
+++ b/usr/gen_init_cpio.c
@@ -20,7 +20,7 @@
 #define xstr(s) #s
 #define str(s) xstr(s)
 
-static unsigned int offset;
+static size_t offset;
 static unsigned int ino = 721;
 static time_t default_mtime;
 
@@ -31,7 +31,7 @@ struct file_handler {
 
 static void push_string(const char *name)
 {
-	unsigned int name_len = strlen(name) + 1;
+	size_t name_len = strlen(name) + 1;
 
 	fputs(name, stdout);
 	putchar(0);
@@ -48,8 +48,8 @@ static void push_pad (void)
 
 static void push_rest(const char *name)
 {
-	unsigned int name_len = strlen(name) + 1;
-	unsigned int tmp_ofs;
+	size_t name_len = strlen(name) + 1;
+	size_t tmp_ofs;
 
 	fputs(name, stdout);
 	putchar(0);
@@ -135,11 +135,11 @@ static int cpio_mkslink_line(const char *line)
 	char name[PATH_MAX + 1];
 	char target[PATH_MAX + 1];
 	unsigned int mode;
-	int uid;
-	int gid;
+	uid_t uid;
+	gid_t gid;
 	int rc = -1;
 
-	if (5 != sscanf(line, "%" str(PATH_MAX) "s %" str(PATH_MAX) "s %o %d %d", name, target, &mode, &uid, &gid)) {
+	if (5 != sscanf(line, "%" str(PATH_MAX) "s %" str(PATH_MAX) "s %o %u %u", name, target, &mode, &uid, &gid)) {
 		fprintf(stderr, "Unrecognized dir format '%s'", line);
 		goto fail;
 	}
@@ -206,11 +206,11 @@ static int cpio_mkgeneric_line(const char *line, enum generic_types gt)
 {
 	char name[PATH_MAX + 1];
 	unsigned int mode;
-	int uid;
-	int gid;
+	uid_t uid;
+	gid_t gid;
 	int rc = -1;
 
-	if (4 != sscanf(line, "%" str(PATH_MAX) "s %o %d %d", name, &mode, &uid, &gid)) {
+	if (4 != sscanf(line, "%" str(PATH_MAX) "s %o %u %u", name, &mode, &uid, &gid)) {
 		fprintf(stderr, "Unrecognized %s format '%s'",
 			line, generic_type_table[gt].type);
 		goto fail;
@@ -274,14 +274,14 @@ static int cpio_mknod_line(const char *line)
 {
 	char name[PATH_MAX + 1];
 	unsigned int mode;
-	int uid;
-	int gid;
+	uid_t uid;
+	gid_t gid;
 	char dev_type;
 	unsigned int maj;
 	unsigned int min;
 	int rc = -1;
 
-	if (7 != sscanf(line, "%" str(PATH_MAX) "s %o %d %d %c %u %u",
+	if (7 != sscanf(line, "%" str(PATH_MAX) "s %o %u %u %c %u %u",
 			 name, &mode, &uid, &gid, &dev_type, &maj, &min)) {
 		fprintf(stderr, "Unrecognized nod format '%s'", line);
 		goto fail;
@@ -298,11 +298,11 @@ static int cpio_mkfile(const char *name, const char *location,
 	char s[256];
 	char *filebuf = NULL;
 	struct stat buf;
-	long size;
+	size_t size;
 	int file = -1;
 	int retval;
 	int rc = -1;
-	int namesize;
+	size_t namesize;
 	unsigned int i;
 
 	mode |= S_IFREG;
@@ -319,13 +319,13 @@ static int cpio_mkfile(const char *name, const char *location,
 		goto error;
 	}
 
-	filebuf = malloc(buf.st_size);
+	filebuf = malloc((size_t)buf.st_size);
 	if (!filebuf) {
 		fprintf (stderr, "out of memory\n");
 		goto error;
 	}
 
-	retval = read (file, filebuf, buf.st_size);
+	retval = (int)read (file, filebuf, (size_t)buf.st_size);
 	if (retval < 0) {
 		fprintf (stderr, "Can not read %s file\n", location);
 		goto error;
@@ -334,13 +334,13 @@ static int cpio_mkfile(const char *name, const char *location,
 	size = 0;
 	for (i = 1; i <= nlinks; i++) {
 		/* data goes on last link */
-		if (i == nlinks) size = buf.st_size;
+		if (i == nlinks) size = (size_t)buf.st_size;
 
 		if (name[0] == '/')
 			name++;
 		namesize = strlen(name) + 1;
 		sprintf(s,"%s%08X%08X%08lX%08lX%08X%08lX"
-		       "%08lX%08X%08X%08X%08X%08X%08X",
+		       "%08zX%08X%08X%08X%08X%08zX%08X",
 			"070701",		/* magic */
 			ino,			/* ino */
 			mode,			/* mode */
@@ -402,25 +402,26 @@ static int cpio_mkfile_line(const char *line)
 	char *dname = NULL; /* malloc'ed buffer for hard links */
 	char location[PATH_MAX + 1];
 	unsigned int mode;
-	int uid;
-	int gid;
-	int nlinks = 1;
-	int end = 0, dname_len = 0;
+	uid_t uid;
+	gid_t gid;
+	unsigned int nlinks = 1;
+	int end = 0;
+	size_t dname_len = 0;
 	int rc = -1;
 
 	if (5 > sscanf(line, "%" str(PATH_MAX) "s %" str(PATH_MAX)
-				"s %o %d %d %n",
+				"s %o %u %u %n",
 				name, location, &mode, &uid, &gid, &end)) {
 		fprintf(stderr, "Unrecognized file format '%s'", line);
 		goto fail;
 	}
 	if (end && isgraph(line[end])) {
-		int len;
+		size_t len;
 		int nend;
 
 		dname = malloc(strlen(line));
 		if (!dname) {
-			fprintf (stderr, "out of memory (%d)\n", dname_len);
+			fprintf (stderr, "out of memory (%zu)\n", dname_len);
 			goto fail;
 		}
 
-- 
