From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Nicolas Iooss <nicolas.iooss_linux@m4x.org>
Date: Wed, 18 Mar 2015 16:17:32 +0800
Subject: [PATCH] {NOT UPSTREAMABLE} fix harmless uninitialized warnings
 reported by clang

---
 arch/x86/kernel/hw_breakpoint.c                       | 1 +
 drivers/acpi/sysfs.c                                  | 2 ++
 drivers/gpu/drm/amd/powerplay/hwmgr/processpptables.c | 4 ++++
 drivers/gpu/drm/i915/i915_gem_request.c               | 2 +-
 drivers/gpu/drm/qxl/qxl_draw.c                        | 2 +-
 drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c               | 1 +
 drivers/iio/common/ssp_sensors/ssp_iio.c              | 3 ++-
 drivers/md/bcache/alloc.c                             | 2 +-
 drivers/media/tuners/tda8290.c                        | 2 ++
 drivers/misc/qcom-coincell.c                          | 4 ++++
 drivers/misc/sgi-xp/xpc_partition.c                   | 2 +-
 drivers/net/ethernet/sun/niu.c                        | 1 +
 drivers/net/sb1000.c                                  | 2 +-
 drivers/net/wireless/broadcom/b43/phy_lp.c            | 2 +-
 drivers/pwm/pwm-img.c                                 | 2 +-
 drivers/scsi/qla2xxx/qla_mr.c                         | 1 +
 drivers/scsi/qla4xxx/ql4_os.c                         | 2 +-
 drivers/usb/atm/cxacru.c                              | 3 ++-
 fs/btrfs/uuid-tree.c                                  | 3 ++-
 fs/ocfs2/localalloc.c                                 | 1 +
 fs/xfs/libxfs/xfs_dir2_node.c                         | 6 ++++--
 fs/xfs/libxfs/xfs_ialloc.c                            | 2 +-
 fs/xfs/xfs_log_recover.c                              | 2 +-
 include/linux/sunrpc/cache.h                          | 2 +-
 mm/filemap.c                                          | 2 +-
 net/mac80211/mlme.c                                   | 2 +-
 net/mac80211/tx.c                                     | 2 +-
 net/tipc/socket.c                                     | 3 ++-
 28 files changed, 43 insertions(+), 20 deletions(-)

diff --git a/arch/x86/kernel/hw_breakpoint.c b/arch/x86/kernel/hw_breakpoint.c
index 8771766d46b6..df760ec0e44e 100644
--- a/arch/x86/kernel/hw_breakpoint.c
+++ b/arch/x86/kernel/hw_breakpoint.c
@@ -352,6 +352,7 @@ int arch_validate_hwbkpt_settings(struct perf_event *bp)
 #endif
 	default:
 		WARN_ON_ONCE(1);
+		align = 0;
 	}
 
 	/*
diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index 4fc59c3bc673..5f79db5f5fd2 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -666,6 +666,8 @@ static int get_status(u32 index, acpi_event_status *status,
 		result = acpi_get_gpe_status(*handle, index, status);
 	} else if (index < (num_gpes + ACPI_NUM_FIXED_EVENTS))
 		result = acpi_get_event_status(index - num_gpes, status);
+	else
+	    return -EINVAL; /* -Wsometimes-uninitialized false positive: the compiler thinks num_gpes can change in a racy way */
 
 	return result;
 }
diff --git a/drivers/gpu/drm/amd/powerplay/hwmgr/processpptables.c b/drivers/gpu/drm/amd/powerplay/hwmgr/processpptables.c
index c3e7e34535e8..6526bdefa84c 100644
--- a/drivers/gpu/drm/amd/powerplay/hwmgr/processpptables.c
+++ b/drivers/gpu/drm/amd/powerplay/hwmgr/processpptables.c
@@ -1073,6 +1073,10 @@ static int init_overdrive_limits(struct pp_hwmgr *hwmgr,
 		result = init_overdrive_limits_V2_1(hwmgr,
 				powerplay_table,
 				(const ATOM_FIRMWARE_INFO_V2_1 *)fw_info);
+	else {
+		/* Should not happen, but silent compiler warnings about unitialized variable */
+		result = 0;
+	}
 
 	if (hwmgr->platform_descriptor.overdriveLimit.engineClock > 0
 		&& hwmgr->platform_descriptor.overdriveLimit.memoryClock > 0
diff --git a/drivers/gpu/drm/i915/i915_gem_request.c b/drivers/gpu/drm/i915/i915_gem_request.c
index a3e93d46316a..2e11134f780c 100644
--- a/drivers/gpu/drm/i915/i915_gem_request.c
+++ b/drivers/gpu/drm/i915/i915_gem_request.c
@@ -1073,7 +1073,7 @@ static unsigned long local_clock_us(unsigned int *cpu)
 
 static bool busywait_stop(unsigned long timeout, unsigned int cpu)
 {
-	unsigned int this_cpu;
+	unsigned int this_cpu = 0; /* clang -Wsometimes-uninitialized false positive, because time_after does a typecheck on local_clock_us return value */
 
 	if (time_after(local_clock_us(&this_cpu), timeout))
 		return true;
diff --git a/drivers/gpu/drm/qxl/qxl_draw.c b/drivers/gpu/drm/qxl/qxl_draw.c
index 4d8681e84e68..18f862ad3e05 100644
--- a/drivers/gpu/drm/qxl/qxl_draw.c
+++ b/drivers/gpu/drm/qxl/qxl_draw.c
@@ -278,7 +278,7 @@ void qxl_draw_dirty_fb(struct qxl_device *qdev,
 	int i;
 	int left, right, top, bottom;
 	int width, height;
-	struct qxl_drawable *drawable;
+	struct qxl_drawable *drawable = NULL;
 	struct qxl_rect drawable_rect;
 	struct qxl_rect *rects;
 	int stride = qxl_fb->base.pitches[0];
diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c b/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c
index c9d5cc237124..d7f02160e21b 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c
@@ -4217,6 +4217,7 @@ int vmw_execbuf_process(struct drm_file *file_priv,
 		goto out_err;
 
 	vmw_query_bo_switch_commit(dev_priv, sw_context);
+	handle = 0; /* False positive: vmw_user_fence_create() sets the value if the function returns successfully */
 	ret = vmw_execbuf_fence_commands(file_priv, dev_priv,
 					 &fence,
 					 (user_fence_rep) ? &handle : NULL);
diff --git a/drivers/iio/common/ssp_sensors/ssp_iio.c b/drivers/iio/common/ssp_sensors/ssp_iio.c
index 645f2e3975db..e5aa6d1abcf5 100644
--- a/drivers/iio/common/ssp_sensors/ssp_iio.c
+++ b/drivers/iio/common/ssp_sensors/ssp_iio.c
@@ -96,7 +96,8 @@ int ssp_common_process_data(struct iio_dev *indio_dev, void *buf,
 		memcpy(&time, &((char *)buf)[len], SSP_TIME_SIZE);
 		calculated_time =
 			timestamp + (int64_t)le32_to_cpu(time) * 1000000;
-	}
+	} else
+		calculated_time = 0; /* BUG? */
 
 	return iio_push_to_buffers_with_timestamp(indio_dev, spd->buffer,
 						  calculated_time);
diff --git a/drivers/md/bcache/alloc.c b/drivers/md/bcache/alloc.c
index 458e1d38577d..02cf3080fafd 100644
--- a/drivers/md/bcache/alloc.c
+++ b/drivers/md/bcache/alloc.c
@@ -326,7 +326,7 @@ static int bch_allocator_thread(void *arg)
 		 * the free list:
 		 */
 		while (!fifo_empty(&ca->free_inc)) {
-			long bucket;
+			long bucket = 0; /* False positive: fifo_pop uses if(!fifo_empty()...) which is always true here. Maybe merge the while cond with the call to fifo_pop? */
 
 			fifo_pop(&ca->free_inc, bucket);
 
diff --git a/drivers/media/tuners/tda8290.c b/drivers/media/tuners/tda8290.c
index 9f1f1d2b8bdc..3258a43b5da2 100644
--- a/drivers/media/tuners/tda8290.c
+++ b/drivers/media/tuners/tda8290.c
@@ -240,6 +240,8 @@ static void tda8290_set_params(struct dvb_frontend *fe,
 	if (fe->ops.tuner_ops.set_analog_params)
 		fe->ops.tuner_ops.set_analog_params(fe, params);
 
+	adc_sat = 0; /* BUG? After 3 tries, what happens? */
+	agc_stat = 0; /* BUG? */
 	for (i = 0; i < 3; i++) {
 		tuner_i2c_xfer_send_recv(&priv->i2c_props,
 					 &addr_pll_stat, 1, &pll_stat, 1);
diff --git a/drivers/misc/qcom-coincell.c b/drivers/misc/qcom-coincell.c
index 829a61dbd65f..cb958e350926 100644
--- a/drivers/misc/qcom-coincell.c
+++ b/drivers/misc/qcom-coincell.c
@@ -127,6 +127,10 @@ static int qcom_coincell_probe(struct platform_device *pdev)
 			    "can't find 'qcom,vset-millivolts' in DT block");
 			return rc;
 		}
+	} else {
+		/* make clang happy, as rset and vset are never used when !enable */
+		rset = 0;
+		vset = 0;
 	}
 
 	return qcom_coincell_chgr_config(&chgr, rset, vset, enable);
diff --git a/drivers/misc/sgi-xp/xpc_partition.c b/drivers/misc/sgi-xp/xpc_partition.c
index 6956f7e7d439..b5ddd77d01a9 100644
--- a/drivers/misc/sgi-xp/xpc_partition.c
+++ b/drivers/misc/sgi-xp/xpc_partition.c
@@ -70,7 +70,7 @@ xpc_get_rsvd_page_pa(int nasid)
 	unsigned long rp_pa = nasid;	/* seed with nasid */
 	size_t len = 0;
 	size_t buf_len = 0;
-	void *buf = buf;
+	void *buf = NULL; /* BUG? No. May need an uninitialized_variable macro instead */
 	void *buf_base = NULL;
 	enum xp_retval (*get_partition_rsvd_page_pa)
 		(void *, u64 *, unsigned long *, size_t *) =
diff --git a/drivers/net/ethernet/sun/niu.c b/drivers/net/ethernet/sun/niu.c
index 8dd545fed30d..6f951c348617 100644
--- a/drivers/net/ethernet/sun/niu.c
+++ b/drivers/net/ethernet/sun/niu.c
@@ -7481,6 +7481,7 @@ static int niu_add_ethtool_tcam_entry(struct niu *np,
 					class = CLASS_CODE_USER_PROG4;
 					break;
 				default:
+					class = 0; /* BUG? */
 					break;
 				}
 				ret = tcam_user_ip_class_set(np, class, 0,
diff --git a/drivers/net/sb1000.c b/drivers/net/sb1000.c
index 7820fced33f6..c99c06a9f9ec 100644
--- a/drivers/net/sb1000.c
+++ b/drivers/net/sb1000.c
@@ -742,7 +742,7 @@ sb1000_rx(struct net_device *dev)
 {
 
 #define FRAMESIZE 184
-	unsigned char st[2], buffer[FRAMESIZE], session_id, frame_id;
+	unsigned char st[2] = {0, 0}, buffer[FRAMESIZE], session_id, frame_id;
 	short dlen;
 	int ioaddr, ns;
 	unsigned int skbsize;
diff --git a/drivers/net/wireless/broadcom/b43/phy_lp.c b/drivers/net/wireless/broadcom/b43/phy_lp.c
index 6922cbb99a04..7f71ede46738 100644
--- a/drivers/net/wireless/broadcom/b43/phy_lp.c
+++ b/drivers/net/wireless/broadcom/b43/phy_lp.c
@@ -1834,7 +1834,7 @@ static void lpphy_papd_cal(struct b43_wldev *dev, struct lpphy_tx_gains gains,
 static void lpphy_papd_cal_txpwr(struct b43_wldev *dev)
 {
 	struct b43_phy_lp *lpphy = dev->phy.lp;
-	struct lpphy_tx_gains gains, oldgains;
+	struct lpphy_tx_gains gains = {} /* harmless BUG */, oldgains;
 	int old_txpctl, old_afe_ovr, old_rf, old_bbmult;
 
 	lpphy_read_tx_pctl_mode_from_hardware(dev);
diff --git a/drivers/pwm/pwm-img.c b/drivers/pwm/pwm-img.c
index 815f5333bb8f..cf50604ba973 100644
--- a/drivers/pwm/pwm-img.c
+++ b/drivers/pwm/pwm-img.c
@@ -123,7 +123,7 @@ static int img_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,
 	} else if (mul <= max_timebase * 512) {
 		div = PWM_CTRL_CFG_SUB_DIV0_DIV1;
 		timebase = DIV_ROUND_UP(mul, 512);
-	} else if (mul > max_timebase * 512) {
+	} else /* if (mul > max_timebase * 512) */ {
 		dev_err(chip->dev,
 			"failed to configure timebase steps/divider value\n");
 		return -EINVAL;
diff --git a/drivers/scsi/qla2xxx/qla_mr.c b/drivers/scsi/qla2xxx/qla_mr.c
index d5da3981cefe..0f07dda860f5 100644
--- a/drivers/scsi/qla2xxx/qla_mr.c
+++ b/drivers/scsi/qla2xxx/qla_mr.c
@@ -2227,6 +2227,7 @@ qlafx00_ioctl_iosb_entry(scsi_qla_host_t *vha, struct req_que *req,
 		if (iocb_job->u.fxiocb.flags & SRB_FXDISC_RSP_DWRD_VALID)
 			iocb_job->u.fxiocb.req_data =
 			    pkt->dataword_r;
+		res = iocb_job->u.fxiocb.result; /* BUG? Not important because qla2x00_fxdisc_sp_done does not use res */
 	} else {
 		bsg_job = sp->u.bsg_job;
 		bsg_reply = bsg_job->reply;
diff --git a/drivers/scsi/qla4xxx/ql4_os.c b/drivers/scsi/qla4xxx/ql4_os.c
index fc2c97d9a0d6..5f46fe72207c 100644
--- a/drivers/scsi/qla4xxx/ql4_os.c
+++ b/drivers/scsi/qla4xxx/ql4_os.c
@@ -5889,7 +5889,7 @@ static void qla4xxx_boot_release(void *data)
 
 static int get_fw_boot_info(struct scsi_qla_host *ha, uint16_t ddb_index[])
 {
-	dma_addr_t buf_dma;
+	dma_addr_t buf_dma = 0; /* False positive: always initialized by dma_alloc_coherent() when used */
 	uint32_t addr, pri_addr, sec_addr;
 	uint32_t offset;
 	uint16_t func_num;
diff --git a/drivers/usb/atm/cxacru.c b/drivers/usb/atm/cxacru.c
index c8e633594479..c99968bf2df8 100644
--- a/drivers/usb/atm/cxacru.c
+++ b/drivers/usb/atm/cxacru.c
@@ -1104,7 +1104,8 @@ static int cxacru_heavy_init(struct usbatm_data *usbatm_instance,
 			release_firmware(fw);
 			return ret;
 		}
-	}
+	} else
+		bp = NULL; /* not a bug as its uses are always under if(instance->modem_type->boot_rom_patch) */
 
 	cxacru_upload_firmware(instance, fw, bp);
 
diff --git a/fs/btrfs/uuid-tree.c b/fs/btrfs/uuid-tree.c
index 726f928238d0..1ff74bf53692 100644
--- a/fs/btrfs/uuid-tree.c
+++ b/fs/btrfs/uuid-tree.c
@@ -144,7 +144,8 @@ int btrfs_uuid_tree_add(struct btrfs_trans_handle *trans,
 			   ret, (unsigned long long)key.objectid,
 			   (unsigned long long)key.offset, type);
 		goto out;
-	}
+	} else
+		BUG();
 
 	ret = 0;
 	subid_le = cpu_to_le64(subid_cpu);
diff --git a/fs/ocfs2/localalloc.c b/fs/ocfs2/localalloc.c
index fe0d1f9571bb..202b795867fa 100644
--- a/fs/ocfs2/localalloc.c
+++ b/fs/ocfs2/localalloc.c
@@ -844,6 +844,7 @@ static int ocfs2_local_alloc_find_clear_bits(struct ocfs2_super *osb,
 
 	if (!alloc->id1.bitmap1.i_total) {
 		bitoff = -1;
+		numfound = 0;
 		goto bail;
 	}
 
diff --git a/fs/xfs/libxfs/xfs_dir2_node.c b/fs/xfs/libxfs/xfs_dir2_node.c
index 239d97a64296..795d9db893c4 100644
--- a/fs/xfs/libxfs/xfs_dir2_node.c
+++ b/fs/xfs/libxfs/xfs_dir2_node.c
@@ -441,12 +441,12 @@ xfs_dir2_leafn_add(
 {
 	int			compact;	/* compacting stale leaves */
 	xfs_inode_t		*dp;		/* incore directory inode */
-	int			highstale;	/* next stale entry */
+	int			highstale = 0;	/* next stale entry */
 	xfs_dir2_leaf_t		*leaf;		/* leaf structure */
 	xfs_dir2_leaf_entry_t	*lep;		/* leaf entry */
 	int			lfloghigh;	/* high leaf entry logging */
 	int			lfloglow;	/* low leaf entry logging */
-	int			lowstale;	/* previous stale entry */
+	int			lowstale = 0;	/* previous stale entry */
 	struct xfs_dir3_icleaf_hdr leafhdr;
 	struct xfs_dir2_leaf_entry *ents;
 
@@ -497,6 +497,8 @@ xfs_dir2_leafn_add(
 		 */
 		lfloglow = leafhdr.count;
 		lfloghigh = -1;
+		highstale = 0; /* Make clang happy */
+		lowstale = 0; /* Make clang happy */
 	}
 
 	/*
diff --git a/fs/xfs/libxfs/xfs_ialloc.c b/fs/xfs/libxfs/xfs_ialloc.c
index 0e2cf5f0be1f..dffedba4c1c6 100644
--- a/fs/xfs/libxfs/xfs_ialloc.c
+++ b/fs/xfs/libxfs/xfs_ialloc.c
@@ -2033,7 +2033,7 @@ xfs_difree_finobt(
 	struct xfs_agi			*agi = XFS_BUF_TO_AGI(agbp);
 	xfs_agnumber_t			agno = be32_to_cpu(agi->agi_seqno);
 	struct xfs_btree_cur		*cur;
-	struct xfs_inobt_rec_incore	rec;
+	struct xfs_inobt_rec_incore	rec = {}; /* gcc -Wmaybe-uninitialized false positive */
 	int				offset = agino - ibtrec->ir_startino;
 	int				error;
 	int				i;
diff --git a/fs/xfs/xfs_log_recover.c b/fs/xfs/xfs_log_recover.c
index 05e3395d698f..7b8ffa8de5c9 100644
--- a/fs/xfs/xfs_log_recover.c
+++ b/fs/xfs/xfs_log_recover.c
@@ -1085,7 +1085,7 @@ xlog_verify_tail(
 	xfs_daddr_t		first_bad;
 	int			error = 0;
 	bool			wrapped;
-	xfs_daddr_t		tmp_tail;
+	xfs_daddr_t		tmp_tail = 0 /* -Wmaybe-uninitialized false positive */;
 	xfs_daddr_t		orig_tail = *tail_blk;
 
 	bp = xlog_get_bp(log, 1);
diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 40d2822f0e2f..f2eb1bcbd47f 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -288,7 +288,7 @@ static inline int get_time(char **bpp, time_t *time)
 
 static inline time_t get_expiry(char **bpp)
 {
-	time_t rv;
+	time_t rv = 0; /* gcc -Wmaybe-uninitialized false positive */
 	struct timespec boot;
 
 	if (get_time(bpp, &rv))
diff --git a/mm/filemap.c b/mm/filemap.c
index 693f62212a59..eba6220773c1 100644
--- a/mm/filemap.c
+++ b/mm/filemap.c
@@ -828,7 +828,7 @@ static int __add_to_page_cache_locked(struct page *page,
 				      void **shadowp)
 {
 	int huge = PageHuge(page);
-	struct mem_cgroup *memcg;
+	struct mem_cgroup *memcg = NULL; /* false positive of uninitialized warning: its uses depends on !huge */
 	int error;
 
 	VM_BUG_ON_PAGE(!PageLocked(page), page);
diff --git a/net/mac80211/mlme.c b/net/mac80211/mlme.c
index 39b660b9a908..a736798fa5fa 100644
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@ -1304,7 +1304,7 @@ static u32 ieee80211_handle_pwr_constr(struct ieee80211_sub_if_data *sdata,
 {
 	bool has_80211h_pwr = false, has_cisco_pwr = false;
 	int chan_pwr = 0, pwr_reduction_80211h = 0;
-	int pwr_level_cisco, pwr_level_80211h;
+	int pwr_level_cisco = 0 /* gcc -Wmaybe-uninitialized false positive */, pwr_level_80211h;
 	int new_ap_level;
 	__le16 capab = mgmt->u.probe_resp.capab_info;
 
diff --git a/net/mac80211/tx.c b/net/mac80211/tx.c
index 25904af38839..3ac4f192d33c 100644
--- a/net/mac80211/tx.c
+++ b/net/mac80211/tx.c
@@ -2399,7 +2399,7 @@ static struct sk_buff *ieee80211_build_hdr(struct ieee80211_sub_if_data *sdata,
 	bool tdls_peer;
 	bool multicast;
 	u16 info_id = 0;
-	struct ieee80211_chanctx_conf *chanctx_conf;
+	struct ieee80211_chanctx_conf *chanctx_conf = NULL; /* gcc -Wmaybe-uninitialized false positive */
 	struct ieee80211_sub_if_data *ap_sdata;
 	enum nl80211_band band;
 	int ret;
diff --git a/net/tipc/socket.c b/net/tipc/socket.c
index b0323ec7971e..22bc6e6e6533 100644
--- a/net/tipc/socket.c
+++ b/net/tipc/socket.c
@@ -1351,7 +1351,8 @@ static int __tipc_sendmsg(struct socket *sock, struct msghdr *m, size_t dlen)
 		msg_set_destnode(hdr, dnode);
 		msg_set_destport(hdr, dest->addr.id.ref);
 		msg_set_hdr_sz(hdr, BASIC_H_SIZE);
-	}
+	} else
+		dnode = 0; /* BUG? */
 
 	/* Block or return if destination link is congested */
 	rc = tipc_wait_for_cond(sock, &timeout,
-- 
