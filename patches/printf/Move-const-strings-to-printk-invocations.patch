From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Nicolas Iooss <nicolas.iooss_linux@m4x.org>
Date: Wed, 1 Feb 2017 23:46:54 +0100
Subject: [PATCH] {PRINTF} Move const strings to printk invocations
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This fixes errors like:

    arch/x86/mm/fault.c: In function ‘is_errata93’:
    include/linux/printk.h:345:3: error: Call with a non-constant string
    [-Werror=format-security]
       printk(fmt, ##__VA_ARGS__);   \
       ^~~~~~~~~~~~~~~~~~~~~~~~~~
    arch/x86/mm/fault.c:600:3: note: in expansion of macro ‘printk_once’
       printk_once(errata93_warning);
       ^~~~~~~~~~~
    arch/x86/mm/fault.c: In function ‘show_fault_oops’:
    arch/x86/mm/fault.c:668:4: error: Call with a non-constant string
     [-Werror=format-security]
        printk(nx_warning, from_kuid(&init_user_ns, current_uid()));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    arch/x86/mm/fault.c:672:4: error: Call with a non-constant string
     [-Werror=format-security]
        printk(smep_warning, from_kuid(&init_user_ns, current_uid()));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
---
 arch/arm/mach-omap2/board-n8x0.c             |   3 +-
 arch/arm/mach-omap2/usb-tusb6010.c           |  23 +--
 arch/x86/mm/fault.c                          |  15 +-
 arch/x86/platform/intel-quark/imr_selftest.c |   7 +-
 drivers/clk/ti/adpll.c                       |   3 +-
 drivers/iommu/omap-iommu-debug.c             |   3 +-
 drivers/misc/habanalabs/gaudi/gaudi.c        |  15 +-
 drivers/net/appletalk/ipddp.c                |   4 +-
 drivers/net/hamradio/6pack.c                 |   9 +-
 drivers/net/hamradio/baycom_epp.c            |   5 +-
 drivers/net/hamradio/mkiss.c                 |   9 +-
 drivers/net/wan/z85230.c                     |   4 +-
 drivers/remoteproc/keystone_remoteproc.c     |   5 +-
 drivers/scsi/esas2r/esas2r_log.c             |   6 +-
 drivers/scsi/fnic/fnic_trace.c               |   5 +-
 drivers/tty/serial/st-asc.c                  |   4 +-
 fs/ext4/super.c                              |   8 +-
 fs/nilfs2/sysfs.c                            | 168 +++++++++----------
 fs/ntfs/super.c                              |   7 +-
 kernel/power/suspend_test.c                  |  33 +---
 net/802/psnap.c                              |   5 +-
 net/core/net-sysfs.c                         |  57 +++----
 net/decnet/af_decnet.c                       |   5 +-
 net/llc/af_llc.c                             |  13 +-
 security/apparmor/lib.c                      |   6 +-
 sound/usb/mixer_scarlett_gen2.c              |  12 +-
 26 files changed, 172 insertions(+), 262 deletions(-)

diff --git a/arch/arm/mach-omap2/board-n8x0.c b/arch/arm/mach-omap2/board-n8x0.c
index 5e86145db0e2..4b9d13d8bafc 100644
--- a/arch/arm/mach-omap2/board-n8x0.c
+++ b/arch/arm/mach-omap2/board-n8x0.c
@@ -112,7 +112,6 @@ static struct musb_hdrc_platform_data tusb_data = {
 static void __init n8x0_usb_init(void)
 {
 	int ret = 0;
-	static const char announce[] __initconst = KERN_INFO "TUSB 6010\n";
 
 	/* PM companion chip power control pin */
 	ret = gpio_request_one(TUSB6010_GPIO_ENABLE, GPIOF_OUT_INIT_LOW,
@@ -130,7 +129,7 @@ static void __init n8x0_usb_init(void)
 	if (ret != 0)
 		goto err;
 
-	printk(announce);
+	printk(KERN_INFO "TUSB 6010\n");
 
 	return;
 
diff --git a/arch/arm/mach-omap2/usb-tusb6010.c b/arch/arm/mach-omap2/usb-tusb6010.c
index a0c4c42e56b9..8b651f5f9cac 100644
--- a/arch/arm/mach-omap2/usb-tusb6010.c
+++ b/arch/arm/mach-omap2/usb-tusb6010.c
@@ -99,9 +99,6 @@ static int tusb_set_sync_mode(unsigned sysclk_ps)
 /* tusb driver calls this when it changes the chip's clocking */
 int tusb6010_platform_retime(unsigned is_refclk)
 {
-	static const char	error[] =
-		KERN_ERR "tusb6010 %s retime error %d\n";
-
 	unsigned	sysclk_ps;
 	int		status;
 
@@ -112,12 +109,12 @@ int tusb6010_platform_retime(unsigned is_refclk)
 
 	status = tusb_set_async_mode(sysclk_ps);
 	if (status < 0) {
-		printk(error, "async", status);
+		printk("tusb6010 %s retime error %d\n", "async", status);
 		goto done;
 	}
 	status = tusb_set_sync_mode(sysclk_ps);
 	if (status < 0)
-		printk(error, "sync", status);
+		printk("tusb6010 %s retime error %d\n", "sync", status);
 done:
 	return status;
 }
@@ -161,14 +158,12 @@ tusb6010_setup_interface(struct musb_hdrc_platform_data *data,
 		unsigned irq, unsigned dmachan)
 {
 	int		status;
-	static char	error[] __initdata =
-		KERN_ERR "tusb6010 init error %d, %d\n";
 
 	/* ASYNC region, primarily for PIO */
 	status = gpmc_cs_request(async, SZ_16M, (unsigned long *)
 				&tusb_resources[0].start);
 	if (status < 0) {
-		printk(error, 1, status);
+		printk(KERN_ERR "tusb6010 init error %d, %d\n", 1, status);
 		return status;
 	}
 	tusb_resources[0].end = tusb_resources[0].start + 0x9ff;
@@ -183,7 +178,7 @@ tusb6010_setup_interface(struct musb_hdrc_platform_data *data,
 	status = gpmc_cs_request(sync, SZ_16M, (unsigned long *)
 				&tusb_resources[1].start);
 	if (status < 0) {
-		printk(error, 2, status);
+		printk(KERN_ERR "tusb6010 init error %d, %d\n", 2, status);
 		return status;
 	}
 	tusb_resources[1].end = tusb_resources[1].start + 0x9ff;
@@ -197,26 +192,26 @@ tusb6010_setup_interface(struct musb_hdrc_platform_data *data,
 	/* IRQ */
 	status = gpio_request_one(irq, GPIOF_IN, "TUSB6010 irq");
 	if (status < 0) {
-		printk(error, 3, status);
+		printk(KERN_ERR "tusb6010 init error %d, %d\n", 3, status);
 		return status;
 	}
 	tusb_resources[2].start = gpio_to_irq(irq);
 
 	/* set up memory timings ... can speed them up later */
 	if (!ps_refclk) {
-		printk(error, 4, status);
+		printk(KERN_ERR "tusb6010 init error %d, %d\n", 4, status);
 		return -ENODEV;
 	}
 	refclk_psec = ps_refclk;
 	status = tusb6010_platform_retime(1);
 	if (status < 0) {
-		printk(error, 5, status);
+		printk(KERN_ERR "tusb6010 init error %d, %d\n", 5, status);
 		return status;
 	}
 
 	/* finish device setup ... */
 	if (!data) {
-		printk(error, 6, status);
+		printk(KERN_ERR "tusb6010 init error %d, %d\n", 6, status);
 		return -ENODEV;
 	}
 	tusb_device.dev.platform_data = data;
@@ -224,7 +219,7 @@ tusb6010_setup_interface(struct musb_hdrc_platform_data *data,
 	/* so far so good ... register the device */
 	status = platform_device_register(&tusb_device);
 	if (status < 0) {
-		printk(error, 7, status);
+		printk(KERN_ERR "tusb6010 init error %d, %d\n", 7, status);
 		return status;
 	}
 	return 0;
diff --git a/arch/x86/mm/fault.c b/arch/x86/mm/fault.c
index 84a2c8c4af73..e65d34ee3ae4 100644
--- a/arch/x86/mm/fault.c
+++ b/arch/x86/mm/fault.c
@@ -328,14 +328,6 @@ static void dump_pagetable(unsigned long address)
 
 #else /* CONFIG_X86_64: */
 
-#ifdef CONFIG_CPU_SUP_AMD
-static const char errata93_warning[] =
-KERN_ERR 
-"******* Your BIOS seems to not contain a fix for K8 errata #93\n"
-"******* Working around it, but it may cause SEGVs or burn power.\n"
-"******* Please consider a BIOS update.\n"
-"******* Disabling USB legacy in the BIOS may also help.\n";
-#endif
 
 static int bad_address(void *p)
 {
@@ -432,7 +424,12 @@ static int is_errata93(struct pt_regs *regs, unsigned long address)
 	address |= 0xffffffffUL << 32;
 	if ((address >= (u64)_stext && address <= (u64)_etext) ||
 	    (address >= MODULES_VADDR && address <= MODULES_END)) {
-		printk_once(errata93_warning);
+		printk_once(
+KERN_ERR
+"******* Your BIOS seems to not contain a fix for K8 errata #93\n"
+"******* Working around it, but it may cause SEGVs or burn power.\n"
+"******* Please consider a BIOS update.\n"
+"******* Disabling USB legacy in the BIOS may also help.\n");
 		regs->ip = address;
 		return 1;
 	}
diff --git a/arch/x86/platform/intel-quark/imr_selftest.c b/arch/x86/platform/intel-quark/imr_selftest.c
index 761f3689f60a..06a6811c5111 100644
--- a/arch/x86/platform/intel-quark/imr_selftest.c
+++ b/arch/x86/platform/intel-quark/imr_selftest.c
@@ -60,7 +60,6 @@ static void __init imr_self_test(void)
 {
 	phys_addr_t base  = virt_to_phys(&_text);
 	size_t size = virt_to_phys(&__end_rodata) - base;
-	const char *fmt_over = "overlapped IMR @ (0x%08lx - 0x%08lx)\n";
 	int ret;
 
 	/* Test zero zero. */
@@ -69,17 +68,17 @@ static void __init imr_self_test(void)
 
 	/* Test exact overlap. */
 	ret = imr_add_range(base, size, IMR_CPU, IMR_CPU);
-	imr_self_test_result(ret < 0, fmt_over, __va(base), __va(base + size));
+	imr_self_test_result(ret < 0, "overlapped IMR @ (%p - %p)\n", __va(base), __va(base + size));
 
 	/* Test overlap with base inside of existing. */
 	base += size - IMR_ALIGN;
 	ret = imr_add_range(base, size, IMR_CPU, IMR_CPU);
-	imr_self_test_result(ret < 0, fmt_over, __va(base), __va(base + size));
+	imr_self_test_result(ret < 0, "overlapped IMR @ (%p - %p)\n", __va(base), __va(base + size));
 
 	/* Test overlap with end inside of existing. */
 	base -= size + IMR_ALIGN * 2;
 	ret = imr_add_range(base, size, IMR_CPU, IMR_CPU);
-	imr_self_test_result(ret < 0, fmt_over, __va(base), __va(base + size));
+	imr_self_test_result(ret < 0, "overlapped IMR @ (%p - %p)\n", __va(base), __va(base + size));
 
 	/* Test that a 1 KiB IMR @ zero with read/write all will bomb out. */
 	ret = imr_add_range(0, IMR_ALIGN, IMR_READ_ACCESS_ALL,
diff --git a/drivers/clk/ti/adpll.c b/drivers/clk/ti/adpll.c
index 32aed4cf5c8b..4e0b7035b0bd 100644
--- a/drivers/clk/ti/adpll.c
+++ b/drivers/clk/ti/adpll.c
@@ -810,13 +810,12 @@ static int ti_adpll_init_registers(struct ti_adpll_data *d)
 
 static int ti_adpll_init_inputs(struct ti_adpll_data *d)
 {
-	const char *error = "need at least %i inputs";
 	struct clk *clock;
 	int nr_inputs;
 
 	nr_inputs = of_clk_get_parent_count(d->np);
 	if (nr_inputs < d->c->nr_max_inputs) {
-		dev_err(d->dev, error, nr_inputs);
+		dev_err(d->dev, "need at least %i inputs", nr_inputs);
 		return -EINVAL;
 	}
 	of_clk_parent_fill(d->np, d->parent_names, nr_inputs);
diff --git a/drivers/iommu/omap-iommu-debug.c b/drivers/iommu/omap-iommu-debug.c
index a99afb5d9011..60dab42e6538 100644
--- a/drivers/iommu/omap-iommu-debug.c
+++ b/drivers/iommu/omap-iommu-debug.c
@@ -30,9 +30,8 @@ static inline bool is_omap_iommu_detached(struct omap_iommu *obj)
 #define pr_reg(name)							\
 	do {								\
 		ssize_t bytes;						\
-		const char *str = "%20s: %08x\n";			\
 		const int maxcol = 32;					\
-		bytes = snprintf(p, maxcol, str, __stringify(name),	\
+		bytes = snprintf(p, maxcol, "%20s: %08x\n", __stringify(name),	\
 				 iommu_read_reg(obj, MMU_##name));	\
 		p += bytes;						\
 		len -= bytes;						\
diff --git a/drivers/misc/habanalabs/gaudi/gaudi.c b/drivers/misc/habanalabs/gaudi/gaudi.c
index 14da87b38e83..6ab65483e8d8 100644
--- a/drivers/misc/habanalabs/gaudi/gaudi.c
+++ b/drivers/misc/habanalabs/gaudi/gaudi.c
@@ -8317,9 +8317,6 @@ static bool gaudi_is_device_idle(struct hl_device *hdev, u64 *mask_arr,
 					u8 mask_len, struct seq_file *s)
 {
 	struct gaudi_device *gaudi = hdev->asic_specific;
-	const char *fmt = "%-5d%-9s%#-14x%#-12x%#x\n";
-	const char *mme_slave_fmt = "%-5d%-9s%-14s%-12s%#x\n";
-	const char *nic_fmt = "%-5d%-9s%#-14x%#x\n";
 	unsigned long *mask = (unsigned long *)mask_arr;
 	u32 qm_glbl_sts0, qm_cgm_sts, dma_core_sts0, tpc_cfg_sts, mme_arch_sts;
 	bool is_idle = true, is_eng_idle, is_slave;
@@ -8349,7 +8346,7 @@ static bool gaudi_is_device_idle(struct hl_device *hdev, u64 *mask_arr,
 		if (mask && !is_eng_idle)
 			set_bit(GAUDI_ENGINE_ID_DMA_0 + dma_id, mask);
 		if (s)
-			seq_printf(s, fmt, dma_id,
+			seq_printf(s, "%-5d%-9s%#-14x%#-12x%#x\n", dma_id,
 				is_eng_idle ? "Y" : "N", qm_glbl_sts0,
 				qm_cgm_sts, dma_core_sts0);
 	}
@@ -8371,7 +8368,7 @@ static bool gaudi_is_device_idle(struct hl_device *hdev, u64 *mask_arr,
 		if (mask && !is_eng_idle)
 			set_bit(GAUDI_ENGINE_ID_TPC_0 + i, mask);
 		if (s)
-			seq_printf(s, fmt, i,
+			seq_printf(s, "%-5d%-9s%#-14x%#-12x%#x\n", i,
 				is_eng_idle ? "Y" : "N",
 				qm_glbl_sts0, qm_cgm_sts, tpc_cfg_sts);
 	}
@@ -8400,11 +8397,11 @@ static bool gaudi_is_device_idle(struct hl_device *hdev, u64 *mask_arr,
 			set_bit(GAUDI_ENGINE_ID_MME_0 + i, mask);
 		if (s) {
 			if (!is_slave)
-				seq_printf(s, fmt, i,
+				seq_printf(s, "%-5d%-9s%#-14x%#-12x%#x\n", i,
 					is_eng_idle ? "Y" : "N",
 					qm_glbl_sts0, qm_cgm_sts, mme_arch_sts);
 			else
-				seq_printf(s, mme_slave_fmt, i,
+				seq_printf(s, "%-5d%-9s%-14s%-12s%#x\n", i,
 					is_eng_idle ? "Y" : "N", "-",
 					"-", mme_arch_sts);
 		}
@@ -8426,7 +8423,7 @@ static bool gaudi_is_device_idle(struct hl_device *hdev, u64 *mask_arr,
 			if (mask && !is_eng_idle)
 				set_bit(GAUDI_ENGINE_ID_NIC_0 + port, mask);
 			if (s)
-				seq_printf(s, nic_fmt, port,
+				seq_printf(s, "%-5d%-9s%#-14x%#x\n", port,
 						is_eng_idle ? "Y" : "N",
 						qm_glbl_sts0, qm_cgm_sts);
 		}
@@ -8441,7 +8438,7 @@ static bool gaudi_is_device_idle(struct hl_device *hdev, u64 *mask_arr,
 			if (mask && !is_eng_idle)
 				set_bit(GAUDI_ENGINE_ID_NIC_0 + port, mask);
 			if (s)
-				seq_printf(s, nic_fmt, port,
+				seq_printf(s, "%-5d%-9s%#-14x%#x\n", port,
 						is_eng_idle ? "Y" : "N",
 						qm_glbl_sts0, qm_cgm_sts);
 		}
diff --git a/drivers/net/appletalk/ipddp.c b/drivers/net/appletalk/ipddp.c
index 5566daefbff4..69c8d9e0b05f 100644
--- a/drivers/net/appletalk/ipddp.c
+++ b/drivers/net/appletalk/ipddp.c
@@ -37,8 +37,6 @@
 
 #include "ipddp.h"		/* Our stuff */
 
-static const char version[] = KERN_INFO "ipddp.c:v0.01 8/28/97 Bradford W. Johnson <johns393@maroon.tc.umn.edu>\n";
-
 static struct ipddp_route *ipddp_route_list;
 static DEFINE_SPINLOCK(ipddp_route_lock);
 
@@ -78,7 +76,7 @@ static struct net_device * __init ipddp_init(void)
 	strcpy(dev->name, "ipddp%d");
 
 	if (version_printed++ == 0)
-                printk(version);
+                printk(KERN_INFO "ipddp.c:v0.01 8/28/97 Bradford W. Johnson <johns393@maroon.tc.umn.edu>\n");
 
 	/* Initialize the device structure. */
 	dev->netdev_ops = &ipddp_netdev_ops;
diff --git a/drivers/net/hamradio/6pack.c b/drivers/net/hamradio/6pack.c
index 6192244b304a..d83fd7c04fbc 100644
--- a/drivers/net/hamradio/6pack.c
+++ b/drivers/net/hamradio/6pack.c
@@ -753,21 +753,16 @@ static struct tty_ldisc_ops sp_ldisc = {
 
 /* Initialize 6pack control device -- register 6pack line discipline */
 
-static const char msg_banner[]  __initconst = KERN_INFO \
-	"AX.25: 6pack driver, " SIXPACK_VERSION "\n";
-static const char msg_regfail[] __initconst = KERN_ERR  \
-	"6pack: can't register line discipline (err = %d)\n";
-
 static int __init sixpack_init_driver(void)
 {
 	int status;
 
-	printk(msg_banner);
+	printk(KERN_INFO "AX.25: 6pack driver, " SIXPACK_VERSION "\n");
 
 	/* Register the provided line protocol discipline */
 	status = tty_register_ldisc(&sp_ldisc);
 	if (status)
-		printk(msg_regfail, status);
+		printk(KERN_ERR "6pack: can't register line discipline (err = %d)\n", status);
 
 	return status;
 }
diff --git a/drivers/net/hamradio/baycom_epp.c b/drivers/net/hamradio/baycom_epp.c
index b111636adb9b..820180613d42 100644
--- a/drivers/net/hamradio/baycom_epp.c
+++ b/drivers/net/hamradio/baycom_epp.c
@@ -49,9 +49,6 @@
 
 /* --------------------------------------------------------------------- */
 
-static const char paranoia_str[] = KERN_ERR 
-	"baycom_epp: bad magic number for hdlcdrv_state struct in routine %s\n";
-
 static const char bc_drvname[] = "baycom_epp";
 static const char bc_drvinfo[] = KERN_INFO "baycom_epp: (C) 1998-2000 Thomas Sailer, HB9JNX/AE4WA\n"
 "baycom_epp: version 0.7\n";
@@ -1287,7 +1284,7 @@ static void __exit cleanup_baycomepp(void)
 				unregister_netdev(dev);
 				free_netdev(dev);
 			} else
-				printk(paranoia_str, "cleanup_module");
+				printk(KERN_ERR "baycom_epp: bad magic number for hdlcdrv_state struct in routine %s\n", "cleanup_module");
 		}
 	}
 	parport_unregister_driver(&baycom_epp_par_driver);
diff --git a/drivers/net/hamradio/mkiss.c b/drivers/net/hamradio/mkiss.c
index 8666110bec55..b5cc71cc7d02 100644
--- a/drivers/net/hamradio/mkiss.c
+++ b/drivers/net/hamradio/mkiss.c
@@ -943,20 +943,15 @@ static struct tty_ldisc_ops ax_ldisc = {
 	.write_wakeup	= mkiss_write_wakeup
 };
 
-static const char banner[] __initconst = KERN_INFO \
-	"mkiss: AX.25 Multikiss, Hans Albas PE1AYX\n";
-static const char msg_regfail[] __initconst = KERN_ERR \
-	"mkiss: can't register line discipline (err = %d)\n";
-
 static int __init mkiss_init_driver(void)
 {
 	int status;
 
-	printk(banner);
+	printk(KERN_INFO "mkiss: AX.25 Multikiss, Hans Albas PE1AYX\n");
 
 	status = tty_register_ldisc(&ax_ldisc);
 	if (status != 0)
-		printk(msg_regfail, status);
+		printk(KERN_ERR "mkiss: can't register line discipline (err = %d)\n", status);
 
 	return status;
 }
diff --git a/drivers/net/wan/z85230.c b/drivers/net/wan/z85230.c
index 982a03488a00..236f5fcec01e 100644
--- a/drivers/net/wan/z85230.c
+++ b/drivers/net/wan/z85230.c
@@ -1621,12 +1621,10 @@ EXPORT_SYMBOL(z8530_queue_xmit);
 
 /*	Module support
  */
-static const char banner[] __initconst =
-	KERN_INFO "Generic Z85C30/Z85230 interface driver v0.02\n";
 
 static int __init z85230_init_driver(void)
 {
-	printk(banner);
+	printk(KERN_INFO "Generic Z85C30/Z85230 interface driver v0.02\n");
 	return 0;
 }
 module_init(z85230_init_driver);
diff --git a/drivers/remoteproc/keystone_remoteproc.c b/drivers/remoteproc/keystone_remoteproc.c
index 54781f553f4e..357ad56af490 100644
--- a/drivers/remoteproc/keystone_remoteproc.c
+++ b/drivers/remoteproc/keystone_remoteproc.c
@@ -366,7 +366,6 @@ static int keystone_rproc_probe(struct platform_device *pdev)
 	struct rproc *rproc;
 	int dsp_id;
 	char *fw_name = NULL;
-	char *template = "keystone-dsp%d-fw";
 	int name_len = 0;
 	int ret = 0;
 
@@ -382,11 +381,11 @@ static int keystone_rproc_probe(struct platform_device *pdev)
 	}
 
 	/* construct a custom default fw name - subject to change in future */
-	name_len = strlen(template); /* assuming a single digit alias */
+	name_len = strlen("keystone-dsp%d-fw"); /* assuming a single digit alias */
 	fw_name = devm_kzalloc(dev, name_len, GFP_KERNEL);
 	if (!fw_name)
 		return -ENOMEM;
-	snprintf(fw_name, name_len, template, dsp_id);
+	snprintf(fw_name, name_len, "keystone-dsp%d-fw", dsp_id);
 
 	rproc = rproc_alloc(dev, dev_name(dev), &keystone_rproc_ops, fw_name,
 			    sizeof(*ksproc));
diff --git a/drivers/scsi/esas2r/esas2r_log.c b/drivers/scsi/esas2r/esas2r_log.c
index 1672c52f855d..566e15d040b7 100644
--- a/drivers/scsi/esas2r/esas2r_log.c
+++ b/drivers/scsi/esas2r/esas2r_log.c
@@ -128,8 +128,6 @@ static __printf(3, 0) int esas2r_log_master(const long level,
 		int retval = 0;
 		char *buffer = event_buffer;
 		size_t buflen = EVENT_LOG_BUFF_SIZE;
-		const char *fmt_nodev = "%s%s: ";
-		const char *fmt_dev = "%s%s [%s, %s, %s]";
 		const char *slevel =
 			translate_esas2r_event_level_to_kernel(level);
 
@@ -144,10 +142,10 @@ static __printf(3, 0) int esas2r_log_master(const long level,
 		 */
 
 		if (dev == NULL) {
-			snprintf(buffer, buflen, fmt_nodev, slevel,
+			snprintf(buffer, buflen, "%s%s: ", slevel,
 				 ESAS2R_DRVR_NAME);
 		} else {
-			snprintf(buffer, buflen, fmt_dev, slevel,
+			snprintf(buffer, buflen, "%s%s [%s, %s, %s]", slevel,
 				 ESAS2R_DRVR_NAME,
 				 (dev->driver ? dev->driver->name : "unknown"),
 				 (dev->bus ? dev->bus->name : "unknown"),
diff --git a/drivers/scsi/fnic/fnic_trace.c b/drivers/scsi/fnic/fnic_trace.c
index 4a7536bb0ab3..ee6c84a19367 100644
--- a/drivers/scsi/fnic/fnic_trace.c
+++ b/drivers/scsi/fnic/fnic_trace.c
@@ -797,7 +797,7 @@ void copy_and_format_trace_data(struct fc_trace_hdr *tdata,
 {
 	struct tm tm;
 	int j, i = 1, len;
-	char *fc_trace, *fmt;
+	char *fc_trace;
 	int ethhdr_len = sizeof(struct ethhdr) - 1;
 	int fcoehdr_len = sizeof(struct fcoe_hdr);
 	int fchdr_len = sizeof(struct fc_frame_header);
@@ -809,10 +809,9 @@ void copy_and_format_trace_data(struct fc_trace_hdr *tdata,
 
 	time64_to_tm(tdata->time_stamp.tv_sec, 0, &tm);
 
-	fmt = "%02d:%02d:%04ld %02d:%02d:%02d.%09lu ns%8x       %c%8x\t";
 	len += scnprintf(fnic_dbgfs_prt->buffer + len,
 		max_size - len,
-		fmt,
+		"%02d:%02d:%04ld %02d:%02d:%02d.%09lu ns%8x       %c%8x\t",
 		tm.tm_mon + 1, tm.tm_mday, tm.tm_year + 1900,
 		tm.tm_hour, tm.tm_min, tm.tm_sec,
 		tdata->time_stamp.tv_nsec, tdata->host_no,
diff --git a/drivers/tty/serial/st-asc.c b/drivers/tty/serial/st-asc.c
index 87e480cc8206..f0c16ff7805b 100644
--- a/drivers/tty/serial/st-asc.c
+++ b/drivers/tty/serial/st-asc.c
@@ -975,10 +975,8 @@ static struct platform_driver asc_serial_driver = {
 static int __init asc_init(void)
 {
 	int ret;
-	static const char banner[] __initconst =
-		KERN_INFO "STMicroelectronics ASC driver initialized\n";
 
-	printk(banner);
+	printk(KERN_INFO "STMicroelectronics ASC driver initialized\n");
 
 	ret = uart_register_driver(&asc_uart_driver);
 	if (ret)
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index 88d5d274a868..96490dd1c14a 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -1817,9 +1817,6 @@ static ext4_fsblk_t get_sb_block(void **data)
 #define DEFAULT_JOURNAL_IOPRIO (IOPRIO_PRIO_VALUE(IOPRIO_CLASS_BE, 3))
 #define DEFAULT_MB_OPTIMIZE_SCAN	(-1)
 
-static const char deprecated_msg[] =
-	"Mount option \"%s\" will be removed by %s\n"
-	"Contact linux-ext4@vger.kernel.org if you think we should keep it.\n";
 
 #ifdef CONFIG_QUOTA
 static int set_qf_name(struct super_block *sb, int qtype, substring_t *args)
@@ -2116,7 +2113,10 @@ static int handle_mount_opt(struct super_block *sb, char *opt, int token,
 	switch (token) {
 	case Opt_noacl:
 	case Opt_nouser_xattr:
-		ext4_msg(sb, KERN_WARNING, deprecated_msg, opt, "3.5");
+		ext4_msg(sb, KERN_WARNING,
+			"Mount option \"%s\" will be removed by %s\n"
+			"Contact linux-ext4@vger.kernel.org if you think we should keep it.\n",
+			opt, "3.5");
 		break;
 	case Opt_sb:
 		return 1;	/* handled by get_sb_block() */
diff --git a/fs/nilfs2/sysfs.c b/fs/nilfs2/sysfs.c
index 62f8a7ac19c8..b59f88274f53 100644
--- a/fs/nilfs2/sysfs.c
+++ b/fs/nilfs2/sysfs.c
@@ -107,16 +107,14 @@ nilfs_snapshot_blocks_count_show(struct nilfs_snapshot_attr *attr,
 			(unsigned long long)atomic64_read(&root->blocks_count));
 }
 
-static const char snapshot_readme_str[] =
-	"The group contains details about mounted snapshot.\n\n"
-	"(1) inodes_count\n\tshow number of inodes for snapshot.\n\n"
-	"(2) blocks_count\n\tshow number of blocks for snapshot.\n\n";
-
 static ssize_t
 nilfs_snapshot_README_show(struct nilfs_snapshot_attr *attr,
 			    struct nilfs_root *root, char *buf)
 {
-	return snprintf(buf, PAGE_SIZE, snapshot_readme_str);
+	return snprintf(buf, PAGE_SIZE,
+		"The group contains details about mounted snapshot.\n\n"
+		"(1) inodes_count\n\tshow number of inodes for snapshot.\n\n"
+		"(2) blocks_count\n\tshow number of blocks for snapshot.\n\n");
 }
 
 NILFS_SNAPSHOT_RO_ATTR(inodes_count);
@@ -209,15 +207,13 @@ void nilfs_sysfs_delete_snapshot_group(struct nilfs_root *root)
  *                    NILFS mounted snapshots attrs                     *
  ************************************************************************/
 
-static const char mounted_snapshots_readme_str[] =
-	"The mounted_snapshots group contains group for\n"
-	"every mounted snapshot.\n";
-
 static ssize_t
 nilfs_mounted_snapshots_README_show(struct nilfs_mounted_snapshots_attr *attr,
 				    struct the_nilfs *nilfs, char *buf)
 {
-	return snprintf(buf, PAGE_SIZE, mounted_snapshots_readme_str);
+	return snprintf(buf, PAGE_SIZE,
+		"The mounted_snapshots group contains group for\n"
+		"every mounted snapshot.\n");
 }
 
 NILFS_MOUNTED_SNAPSHOTS_RO_ATTR(README);
@@ -309,20 +305,18 @@ nilfs_checkpoints_next_checkpoint_show(struct nilfs_checkpoints_attr *attr,
 	return snprintf(buf, PAGE_SIZE, "%llu\n", cno);
 }
 
-static const char checkpoints_readme_str[] =
-	"The checkpoints group contains attributes that describe\n"
-	"details about volume's checkpoints.\n\n"
-	"(1) checkpoints_number\n\tshow number of checkpoints on volume.\n\n"
-	"(2) snapshots_number\n\tshow number of snapshots on volume.\n\n"
-	"(3) last_seg_checkpoint\n"
-	"\tshow checkpoint number of the latest segment.\n\n"
-	"(4) next_checkpoint\n\tshow next checkpoint number.\n\n";
-
 static ssize_t
 nilfs_checkpoints_README_show(struct nilfs_checkpoints_attr *attr,
 				struct the_nilfs *nilfs, char *buf)
 {
-	return snprintf(buf, PAGE_SIZE, checkpoints_readme_str);
+	return snprintf(buf, PAGE_SIZE,
+		"The checkpoints group contains attributes that describe\n"
+		"details about volume's checkpoints.\n\n"
+		"(1) checkpoints_number\n\tshow number of checkpoints on volume.\n\n"
+		"(2) snapshots_number\n\tshow number of snapshots on volume.\n\n"
+		"(3) last_seg_checkpoint\n"
+		"\tshow checkpoint number of the latest segment.\n\n"
+		"(4) next_checkpoint\n\tshow next checkpoint number.\n\n");
 }
 
 NILFS_CHECKPOINTS_RO_ATTR(checkpoints_number);
@@ -398,20 +392,18 @@ nilfs_segments_dirty_segments_show(struct nilfs_segments_attr *attr,
 	return snprintf(buf, PAGE_SIZE, "%llu\n", sustat.ss_ndirtysegs);
 }
 
-static const char segments_readme_str[] =
-	"The segments group contains attributes that describe\n"
-	"details about volume's segments.\n\n"
-	"(1) segments_number\n\tshow number of segments on volume.\n\n"
-	"(2) blocks_per_segment\n\tshow number of blocks in segment.\n\n"
-	"(3) clean_segments\n\tshow count of clean segments.\n\n"
-	"(4) dirty_segments\n\tshow count of dirty segments.\n\n";
-
 static ssize_t
 nilfs_segments_README_show(struct nilfs_segments_attr *attr,
 			    struct the_nilfs *nilfs,
 			    char *buf)
 {
-	return snprintf(buf, PAGE_SIZE, segments_readme_str);
+	return snprintf(buf, PAGE_SIZE,
+		"The segments group contains attributes that describe\n"
+		"details about volume's segments.\n\n"
+		"(1) segments_number\n\tshow number of segments on volume.\n\n"
+		"(2) blocks_per_segment\n\tshow number of blocks in segment.\n\n"
+		"(3) clean_segments\n\tshow count of clean segments.\n\n"
+		"(4) dirty_segments\n\tshow count of dirty segments.\n\n");
 }
 
 NILFS_SEGMENTS_RO_ATTR(segments_number);
@@ -620,41 +612,39 @@ nilfs_segctor_dirty_data_blocks_count_show(struct nilfs_segctor_attr *attr,
 	return snprintf(buf, PAGE_SIZE, "%u\n", ndirtyblks);
 }
 
-static const char segctor_readme_str[] =
-	"The segctor group contains attributes that describe\n"
-	"segctor thread activity details.\n\n"
-	"(1) last_pseg_block\n"
-	"\tshow start block number of the latest segment.\n\n"
-	"(2) last_seg_sequence\n"
-	"\tshow sequence value of the latest segment.\n\n"
-	"(3) last_seg_checkpoint\n"
-	"\tshow checkpoint number of the latest segment.\n\n"
-	"(4) current_seg_sequence\n\tshow segment sequence counter.\n\n"
-	"(5) current_last_full_seg\n"
-	"\tshow index number of the latest full segment.\n\n"
-	"(6) next_full_seg\n"
-	"\tshow index number of the full segment index to be used next.\n\n"
-	"(7) next_pseg_offset\n"
-	"\tshow offset of next partial segment in the current full segment.\n\n"
-	"(8) next_checkpoint\n\tshow next checkpoint number.\n\n"
-	"(9) last_seg_write_time\n"
-	"\tshow write time of the last segment in human-readable format.\n\n"
-	"(10) last_seg_write_time_secs\n"
-	"\tshow write time of the last segment in seconds.\n\n"
-	"(11) last_nongc_write_time\n"
-	"\tshow write time of the last segment not for cleaner operation "
-	"in human-readable format.\n\n"
-	"(12) last_nongc_write_time_secs\n"
-	"\tshow write time of the last segment not for cleaner operation "
-	"in seconds.\n\n"
-	"(13) dirty_data_blocks_count\n"
-	"\tshow number of dirty data blocks.\n\n";
-
 static ssize_t
 nilfs_segctor_README_show(struct nilfs_segctor_attr *attr,
 			  struct the_nilfs *nilfs, char *buf)
 {
-	return snprintf(buf, PAGE_SIZE, segctor_readme_str);
+	return snprintf(buf, PAGE_SIZE,
+		"The segctor group contains attributes that describe\n"
+		"segctor thread activity details.\n\n"
+		"(1) last_pseg_block\n"
+		"\tshow start block number of the latest segment.\n\n"
+		"(2) last_seg_sequence\n"
+		"\tshow sequence value of the latest segment.\n\n"
+		"(3) last_seg_checkpoint\n"
+		"\tshow checkpoint number of the latest segment.\n\n"
+		"(4) current_seg_sequence\n\tshow segment sequence counter.\n\n"
+		"(5) current_last_full_seg\n"
+		"\tshow index number of the latest full segment.\n\n"
+		"(6) next_full_seg\n"
+		"\tshow index number of the full segment index to be used next.\n\n"
+		"(7) next_pseg_offset\n"
+		"\tshow offset of next partial segment in the current full segment.\n\n"
+		"(8) next_checkpoint\n\tshow next checkpoint number.\n\n"
+		"(9) last_seg_write_time\n"
+		"\tshow write time of the last segment in human-readable format.\n\n"
+		"(10) last_seg_write_time_secs\n"
+		"\tshow write time of the last segment in seconds.\n\n"
+		"(11) last_nongc_write_time\n"
+		"\tshow write time of the last segment not for cleaner operation "
+		"in human-readable format.\n\n"
+		"(12) last_nongc_write_time_secs\n"
+		"\tshow write time of the last segment not for cleaner operation "
+		"in seconds.\n\n"
+		"(13) dirty_data_blocks_count\n"
+		"\tshow number of dirty data blocks.\n\n");
 }
 
 NILFS_SEGCTOR_RO_ATTR(last_pseg_block);
@@ -782,24 +772,22 @@ nilfs_superblock_sb_update_frequency_store(struct nilfs_superblock_attr *attr,
 	return count;
 }
 
-static const char sb_readme_str[] =
-	"The superblock group contains attributes that describe\n"
-	"superblock's details.\n\n"
-	"(1) sb_write_time\n\tshow previous write time of super block "
-	"in human-readable format.\n\n"
-	"(2) sb_write_time_secs\n\tshow previous write time of super block "
-	"in seconds.\n\n"
-	"(3) sb_write_count\n\tshow write count of super block.\n\n"
-	"(4) sb_update_frequency\n"
-	"\tshow/set interval of periodical update of superblock (in seconds).\n\n"
-	"\tYou can set preferable frequency of superblock update by command:\n\n"
-	"\t'echo <val> > /sys/fs/<nilfs>/<dev>/superblock/sb_update_frequency'\n";
-
 static ssize_t
 nilfs_superblock_README_show(struct nilfs_superblock_attr *attr,
 				struct the_nilfs *nilfs, char *buf)
 {
-	return snprintf(buf, PAGE_SIZE, sb_readme_str);
+	return snprintf(buf, PAGE_SIZE,
+		"The superblock group contains attributes that describe\n"
+		"superblock's details.\n\n"
+		"(1) sb_write_time\n\tshow previous write time of super block "
+		"in human-readable format.\n\n"
+		"(2) sb_write_time_secs\n\tshow previous write time of super block "
+		"in seconds.\n\n"
+		"(3) sb_write_count\n\tshow write count of super block.\n\n"
+		"(4) sb_update_frequency\n"
+		"\tshow/set interval of periodical update of superblock (in seconds).\n\n"
+		"\tYou can set preferable frequency of superblock update by command:\n\n"
+		"\t'echo <val> > /sys/fs/<nilfs>/<dev>/superblock/sb_update_frequency'\n");
 }
 
 NILFS_SUPERBLOCK_RO_ATTR(sb_write_time);
@@ -889,21 +877,19 @@ ssize_t nilfs_dev_volume_name_show(struct nilfs_dev_attr *attr,
 			 sbp[0]->s_volume_name);
 }
 
-static const char dev_readme_str[] =
-	"The <device> group contains attributes that describe file system\n"
-	"partition's details.\n\n"
-	"(1) revision\n\tshow NILFS file system revision.\n\n"
-	"(2) blocksize\n\tshow volume block size in bytes.\n\n"
-	"(3) device_size\n\tshow volume size in bytes.\n\n"
-	"(4) free_blocks\n\tshow count of free blocks on volume.\n\n"
-	"(5) uuid\n\tshow volume's UUID.\n\n"
-	"(6) volume_name\n\tshow volume's name.\n\n";
-
 static ssize_t nilfs_dev_README_show(struct nilfs_dev_attr *attr,
 				     struct the_nilfs *nilfs,
 				     char *buf)
 {
-	return snprintf(buf, PAGE_SIZE, dev_readme_str);
+	return snprintf(buf, PAGE_SIZE,
+		"The <device> group contains attributes that describe file system\n"
+		"partition's details.\n\n"
+		"(1) revision\n\tshow NILFS file system revision.\n\n"
+		"(2) blocksize\n\tshow volume block size in bytes.\n\n"
+		"(3) device_size\n\tshow volume size in bytes.\n\n"
+		"(4) free_blocks\n\tshow count of free blocks on volume.\n\n"
+		"(5) uuid\n\tshow volume's UUID.\n\n"
+		"(6) volume_name\n\tshow volume's name.\n\n");
 }
 
 NILFS_DEV_RO_ATTR(revision);
@@ -1051,16 +1037,14 @@ static ssize_t nilfs_feature_revision_show(struct kobject *kobj,
 			NILFS_CURRENT_REV, NILFS_MINOR_REV);
 }
 
-static const char features_readme_str[] =
-	"The features group contains attributes that describe NILFS file\n"
-	"system driver features.\n\n"
-	"(1) revision\n\tshow current revision of NILFS file system driver.\n";
-
 static ssize_t nilfs_feature_README_show(struct kobject *kobj,
 					 struct attribute *attr,
 					 char *buf)
 {
-	return snprintf(buf, PAGE_SIZE, features_readme_str);
+	return snprintf(buf, PAGE_SIZE,
+		"The features group contains attributes that describe NILFS file\n"
+		"system driver features.\n\n"
+		"(1) revision\n\tshow current revision of NILFS file system driver.\n");
 }
 
 NILFS_FEATURE_RO_ATTR(revision);
diff --git a/fs/ntfs/super.c b/fs/ntfs/super.c
index 0d7e948cb29c..a486521a3483 100644
--- a/fs/ntfs/super.c
+++ b/fs/ntfs/super.c
@@ -662,7 +662,6 @@ static bool is_boot_sector_ntfs(const struct super_block *sb,
 static struct buffer_head *read_ntfs_boot_sector(struct super_block *sb,
 		const int silent)
 {
-	const char *read_err_str = "Unable to read %s boot sector.";
 	struct buffer_head *bh_primary, *bh_backup;
 	sector_t nr_blocks = NTFS_SB(sb)->nr_blocks;
 
@@ -674,7 +673,7 @@ static struct buffer_head *read_ntfs_boot_sector(struct super_block *sb,
 		if (!silent)
 			ntfs_error(sb, "Primary boot sector is invalid.");
 	} else if (!silent)
-		ntfs_error(sb, read_err_str, "primary");
+		ntfs_error(sb, "Unable to read %s boot sector.", "primary");
 	if (!(NTFS_SB(sb)->on_errors & ON_ERRORS_RECOVER)) {
 		if (bh_primary)
 			brelse(bh_primary);
@@ -690,7 +689,7 @@ static struct buffer_head *read_ntfs_boot_sector(struct super_block *sb,
 			goto hotfix_primary_boot_sector;
 		brelse(bh_backup);
 	} else if (!silent)
-		ntfs_error(sb, read_err_str, "backup");
+		ntfs_error(sb, "Unable to read %s boot sector.", "backup");
 	/* Try to read NT3.51- backup boot sector. */
 	if ((bh_backup = sb_bread(sb, nr_blocks >> 1))) {
 		if (is_boot_sector_ntfs(sb, (NTFS_BOOT_SECTOR*)
@@ -701,7 +700,7 @@ static struct buffer_head *read_ntfs_boot_sector(struct super_block *sb,
 					"sector.");
 		brelse(bh_backup);
 	} else if (!silent)
-		ntfs_error(sb, read_err_str, "backup");
+		ntfs_error(sb, "Unable to read %s boot sector.", "backup");
 	/* We failed. Cleanup and return. */
 	if (bh_primary)
 		brelse(bh_primary);
diff --git a/kernel/power/suspend_test.c b/kernel/power/suspend_test.c
index b146e0d84fc1..98b845558d9a 100644
--- a/kernel/power/suspend_test.c
+++ b/kernel/power/suspend_test.c
@@ -61,15 +61,6 @@ void suspend_test_finish(const char *label)
 
 static void __init test_wakealarm(struct rtc_device *rtc, suspend_state_t state)
 {
-	static char err_readtime[] __initdata =
-		KERN_ERR "PM: can't read %s time, err %d\n";
-	static char err_wakealarm [] __initdata =
-		KERN_ERR "PM: can't set %s wakealarm, err %d\n";
-	static char err_suspend[] __initdata =
-		KERN_ERR "PM: suspend test failed, error %d\n";
-	static char info_test[] __initdata =
-		KERN_INFO "PM: test RTC wakeup from '%s' suspend\n";
-
 	time64_t		now;
 	struct rtc_wkalrm	alm;
 	int			status;
@@ -78,7 +69,7 @@ static void __init test_wakealarm(struct rtc_device *rtc, suspend_state_t state)
 repeat:
 	status = rtc_read_time(rtc, &alm.time);
 	if (status < 0) {
-		printk(err_readtime, dev_name(&rtc->dev), status);
+		printk(KERN_ERR "PM: can't read %s time, err %d\n", dev_name(&rtc->dev), status);
 		return;
 	}
 	now = rtc_tm_to_time64(&alm.time);
@@ -89,29 +80,29 @@ static void __init test_wakealarm(struct rtc_device *rtc, suspend_state_t state)
 
 	status = rtc_set_alarm(rtc, &alm);
 	if (status < 0) {
-		printk(err_wakealarm, dev_name(&rtc->dev), status);
+		printk(KERN_ERR "PM: can't set %s wakealarm, err %d\n", dev_name(&rtc->dev), status);
 		return;
 	}
 
 	if (state == PM_SUSPEND_MEM) {
-		printk(info_test, pm_states[state]);
+		printk(KERN_INFO "PM: test RTC wakeup from '%s' suspend\n", pm_states[state]);
 		status = pm_suspend(state);
 		if (status == -ENODEV)
 			state = PM_SUSPEND_STANDBY;
 	}
 	if (state == PM_SUSPEND_STANDBY) {
-		printk(info_test, pm_states[state]);
+		printk(KERN_INFO "PM: test RTC wakeup from '%s' suspend\n", pm_states[state]);
 		status = pm_suspend(state);
 		if (status < 0)
 			state = PM_SUSPEND_TO_IDLE;
 	}
 	if (state == PM_SUSPEND_TO_IDLE) {
-		printk(info_test, pm_states[state]);
+		printk(KERN_INFO "PM: test RTC wakeup from '%s' suspend\n", pm_states[state]);
 		status = pm_suspend(state);
 	}
 
 	if (status < 0)
-		printk(err_suspend, status);
+		printk(KERN_ERR "PM: suspend test failed, error %d\n", status);
 
 	test_repeat_count_current++;
 	if (test_repeat_count_current < test_repeat_count_max)
@@ -144,9 +135,6 @@ static int __init has_wakealarm(struct device *dev, const void *data)
  */
 static const char *test_state_label __initdata;
 
-static char warn_bad_state[] __initdata =
-	KERN_WARNING "PM: can't test '%s' suspend state\n";
-
 static int __init setup_test_suspend(char *value)
 {
 	int i;
@@ -171,16 +159,13 @@ static int __init setup_test_suspend(char *value)
 			return 0;
 		}
 
-	printk(warn_bad_state, suspend_type);
+	printk(KERN_WARNING "PM: can't test '%s' suspend state\n", suspend_type);
 	return 0;
 }
 __setup("test_suspend", setup_test_suspend);
 
 static int __init test_suspend(void)
 {
-	static const char warn_no_rtc[] __initconst =
-		KERN_WARNING "PM: no wakealarm-capable RTC driver is ready\n";
-
 	struct rtc_device	*rtc = NULL;
 	struct device		*dev;
 	suspend_state_t test_state;
@@ -196,7 +181,7 @@ static int __init test_suspend(void)
 			break;
 	}
 	if (test_state == PM_SUSPEND_MAX) {
-		printk(warn_bad_state, test_state_label);
+		printk(KERN_WARNING "PM: can't test '%s' suspend state\n", test_state_label);
 		return 0;
 	}
 
@@ -207,7 +192,7 @@ static int __init test_suspend(void)
 		put_device(dev);
 	}
 	if (!rtc) {
-		printk(warn_no_rtc);
+		printk(KERN_WARNING "PM: no wakealarm-capable RTC driver is ready\n");
 		return 0;
 	}
 
diff --git a/net/802/psnap.c b/net/802/psnap.c
index 4492e8d7ad20..820f90e6b283 100644
--- a/net/802/psnap.c
+++ b/net/802/psnap.c
@@ -92,14 +92,11 @@ static int snap_request(struct datalink_proto *dl,
 EXPORT_SYMBOL(register_snap_client);
 EXPORT_SYMBOL(unregister_snap_client);
 
-static const char snap_err_msg[] __initconst =
-	KERN_CRIT "SNAP - unable to register with 802.2\n";
-
 static int __init snap_init(void)
 {
 	snap_sap = llc_sap_open(0xAA, snap_rcv);
 	if (!snap_sap) {
-		printk(snap_err_msg);
+		printk(KERN_CRIT "SNAP - unable to register with 802.2\n");
 		return -EBUSY;
 	}
 
diff --git a/net/core/net-sysfs.c b/net/core/net-sysfs.c
index f6197774048b..efc6bea44d0b 100644
--- a/net/core/net-sysfs.c
+++ b/net/core/net-sysfs.c
@@ -27,11 +27,6 @@
 #include "net-sysfs.h"
 
 #ifdef CONFIG_SYSFS
-static const char fmt_hex[] = "%#x\n";
-static const char fmt_dec[] = "%d\n";
-static const char fmt_ulong[] = "%lu\n";
-static const char fmt_u64[] = "%llu\n";
-
 static inline int dev_isalive(const struct net_device *dev)
 {
 	return dev->reg_state <= NETREG_REGISTERED;
@@ -103,26 +98,26 @@ static ssize_t netdev_store(struct device *dev, struct device_attribute *attr,
 	return ret;
 }
 
-NETDEVICE_SHOW_RO(dev_id, fmt_hex);
-NETDEVICE_SHOW_RO(dev_port, fmt_dec);
-NETDEVICE_SHOW_RO(addr_assign_type, fmt_dec);
-NETDEVICE_SHOW_RO(addr_len, fmt_dec);
-NETDEVICE_SHOW_RO(ifindex, fmt_dec);
-NETDEVICE_SHOW_RO(type, fmt_dec);
-NETDEVICE_SHOW_RO(link_mode, fmt_dec);
+NETDEVICE_SHOW_RO(dev_id, "%#x\n");
+NETDEVICE_SHOW_RO(dev_port, "%d\n");
+NETDEVICE_SHOW_RO(addr_assign_type, "%d\n");
+NETDEVICE_SHOW_RO(addr_len, "%d\n");
+NETDEVICE_SHOW_RO(ifindex, "%d\n");
+NETDEVICE_SHOW_RO(type, "%d\n");
+NETDEVICE_SHOW_RO(link_mode, "%d\n");
 
 static ssize_t iflink_show(struct device *dev, struct device_attribute *attr,
 			   char *buf)
 {
 	struct net_device *ndev = to_net_dev(dev);
 
-	return sprintf(buf, fmt_dec, dev_get_iflink(ndev));
+	return sprintf(buf, "%d\n", dev_get_iflink(ndev));
 }
 static DEVICE_ATTR_RO(iflink);
 
 static ssize_t format_name_assign_type(const struct net_device *dev, char *buf)
 {
-	return sprintf(buf, fmt_dec, dev->name_assign_type);
+	return sprintf(buf, "%d\n", dev->name_assign_type);
 }
 
 static ssize_t name_assign_type_show(struct device *dev,
@@ -184,7 +179,7 @@ static ssize_t carrier_show(struct device *dev,
 	struct net_device *netdev = to_net_dev(dev);
 
 	if (netif_running(netdev))
-		return sprintf(buf, fmt_dec, !!netif_carrier_ok(netdev));
+		return sprintf(buf, "%d\n", !!netif_carrier_ok(netdev));
 
 	return -EINVAL;
 }
@@ -203,7 +198,7 @@ static ssize_t speed_show(struct device *dev,
 		struct ethtool_link_ksettings cmd;
 
 		if (!__ethtool_get_link_ksettings(netdev, &cmd))
-			ret = sprintf(buf, fmt_dec, cmd.base.speed);
+			ret = sprintf(buf, "%d\n", cmd.base.speed);
 	}
 	rtnl_unlock();
 	return ret;
@@ -250,7 +245,7 @@ static ssize_t testing_show(struct device *dev,
 	struct net_device *netdev = to_net_dev(dev);
 
 	if (netif_running(netdev))
-		return sprintf(buf, fmt_dec, !!netif_testing(netdev));
+		return sprintf(buf, "%d\n", !!netif_testing(netdev));
 
 	return -EINVAL;
 }
@@ -262,7 +257,7 @@ static ssize_t dormant_show(struct device *dev,
 	struct net_device *netdev = to_net_dev(dev);
 
 	if (netif_running(netdev))
-		return sprintf(buf, fmt_dec, !!netif_dormant(netdev));
+		return sprintf(buf, "%d\n", !!netif_dormant(netdev));
 
 	return -EINVAL;
 }
@@ -303,7 +298,7 @@ static ssize_t carrier_changes_show(struct device *dev,
 {
 	struct net_device *netdev = to_net_dev(dev);
 
-	return sprintf(buf, fmt_dec,
+	return sprintf(buf, "%d\n",
 		       atomic_read(&netdev->carrier_up_count) +
 		       atomic_read(&netdev->carrier_down_count));
 }
@@ -315,7 +310,7 @@ static ssize_t carrier_up_count_show(struct device *dev,
 {
 	struct net_device *netdev = to_net_dev(dev);
 
-	return sprintf(buf, fmt_dec, atomic_read(&netdev->carrier_up_count));
+	return sprintf(buf, "%d\n", atomic_read(&netdev->carrier_up_count));
 }
 static DEVICE_ATTR_RO(carrier_up_count);
 
@@ -325,7 +320,7 @@ static ssize_t carrier_down_count_show(struct device *dev,
 {
 	struct net_device *netdev = to_net_dev(dev);
 
-	return sprintf(buf, fmt_dec, atomic_read(&netdev->carrier_down_count));
+	return sprintf(buf, "%d\n", atomic_read(&netdev->carrier_down_count));
 }
 static DEVICE_ATTR_RO(carrier_down_count);
 
@@ -341,7 +336,7 @@ static ssize_t mtu_store(struct device *dev, struct device_attribute *attr,
 {
 	return netdev_store(dev, attr, buf, len, change_mtu);
 }
-NETDEVICE_SHOW_RW(mtu, fmt_dec);
+NETDEVICE_SHOW_RW(mtu, "%d\n");
 
 static int change_flags(struct net_device *dev, unsigned long new_flags)
 {
@@ -353,7 +348,7 @@ static ssize_t flags_store(struct device *dev, struct device_attribute *attr,
 {
 	return netdev_store(dev, attr, buf, len, change_flags);
 }
-NETDEVICE_SHOW_RW(flags, fmt_hex);
+NETDEVICE_SHOW_RW(flags, "%#x\n");
 
 static ssize_t tx_queue_len_store(struct device *dev,
 				  struct device_attribute *attr,
@@ -364,7 +359,7 @@ static ssize_t tx_queue_len_store(struct device *dev,
 
 	return netdev_store(dev, attr, buf, len, dev_change_tx_queue_len);
 }
-NETDEVICE_SHOW_RW(tx_queue_len, fmt_dec);
+NETDEVICE_SHOW_RW(tx_queue_len, "%d\n");
 
 static int change_gro_flush_timeout(struct net_device *dev, unsigned long val)
 {
@@ -381,7 +376,7 @@ static ssize_t gro_flush_timeout_store(struct device *dev,
 
 	return netdev_store(dev, attr, buf, len, change_gro_flush_timeout);
 }
-NETDEVICE_SHOW_RW(gro_flush_timeout, fmt_ulong);
+NETDEVICE_SHOW_RW(gro_flush_timeout, "%lu\n");
 
 static int change_napi_defer_hard_irqs(struct net_device *dev, unsigned long val)
 {
@@ -398,7 +393,7 @@ static ssize_t napi_defer_hard_irqs_store(struct device *dev,
 
 	return netdev_store(dev, attr, buf, len, change_napi_defer_hard_irqs);
 }
-NETDEVICE_SHOW_RW(napi_defer_hard_irqs, fmt_dec);
+NETDEVICE_SHOW_RW(napi_defer_hard_irqs, "%d\n");
 
 static ssize_t ifalias_store(struct device *dev, struct device_attribute *attr,
 			     const char *buf, size_t len)
@@ -456,7 +451,7 @@ static ssize_t group_store(struct device *dev, struct device_attribute *attr,
 {
 	return netdev_store(dev, attr, buf, len, change_group);
 }
-NETDEVICE_SHOW(group, fmt_dec);
+NETDEVICE_SHOW(group, "%d\n");
 static DEVICE_ATTR(netdev_group, 0644, group_show, group_store);
 
 static int change_proto_down(struct net_device *dev, unsigned long proto_down)
@@ -470,7 +465,7 @@ static ssize_t proto_down_store(struct device *dev,
 {
 	return netdev_store(dev, attr, buf, len, change_proto_down);
 }
-NETDEVICE_SHOW_RW(proto_down, fmt_dec);
+NETDEVICE_SHOW_RW(proto_down, "%d\n");
 
 static ssize_t phys_port_id_show(struct device *dev,
 				 struct device_attribute *attr, char *buf)
@@ -548,7 +543,7 @@ static ssize_t threaded_show(struct device *dev,
 		return restart_syscall();
 
 	if (dev_isalive(netdev))
-		ret = sprintf(buf, fmt_dec, netdev->threaded);
+		ret = sprintf(buf, "%d\n", netdev->threaded);
 
 	rtnl_unlock();
 	return ret;
@@ -630,7 +625,7 @@ static ssize_t netstat_show(const struct device *d,
 		struct rtnl_link_stats64 temp;
 		const struct rtnl_link_stats64 *stats = dev_get_stats(dev, &temp);
 
-		ret = sprintf(buf, fmt_u64, *(u64 *)(((u8 *)stats) + offset));
+		ret = sprintf(buf, "%llu\n", *(u64 *)(((u8 *)stats) + offset));
 	}
 	read_unlock(&dev_base_lock);
 	return ret;
@@ -1158,7 +1153,7 @@ static ssize_t tx_timeout_show(struct netdev_queue *queue, char *buf)
 	trans_timeout = queue->trans_timeout;
 	spin_unlock_irq(&queue->_xmit_lock);
 
-	return sprintf(buf, fmt_ulong, trans_timeout);
+	return sprintf(buf, "%lu\n", trans_timeout);
 }
 
 static unsigned int get_netdev_queue_index(struct netdev_queue *queue)
diff --git a/net/decnet/af_decnet.c b/net/decnet/af_decnet.c
index dc92a67baea3..e3e2b88cb3a8 100644
--- a/net/decnet/af_decnet.c
+++ b/net/decnet/af_decnet.c
@@ -2337,14 +2337,11 @@ MODULE_AUTHOR("Linux DECnet Project Team");
 MODULE_LICENSE("GPL");
 MODULE_ALIAS_NETPROTO(PF_DECnet);
 
-static const char banner[] __initconst = KERN_INFO
-"NET4: DECnet for Linux: V.2.5.68s (C) 1995-2003 Linux DECnet Project Team\n";
-
 static int __init decnet_init(void)
 {
 	int rc;
 
-	printk(banner);
+	printk(KERN_INFO "NET4: DECnet for Linux: V.2.5.68s (C) 1995-2003 Linux DECnet Project Team\n");
 
 	rc = proto_register(&dn_proto, 1);
 	if (rc != 0)
diff --git a/net/llc/af_llc.c b/net/llc/af_llc.c
index 3086f4a6ae68..565d0211c939 100644
--- a/net/llc/af_llc.c
+++ b/net/llc/af_llc.c
@@ -1215,13 +1215,6 @@ static const struct proto_ops llc_ui_ops = {
 	.sendpage    = sock_no_sendpage,
 };
 
-static const char llc_proc_err_msg[] __initconst =
-	KERN_CRIT "LLC: Unable to register the proc_fs entries\n";
-static const char llc_sysctl_err_msg[] __initconst =
-	KERN_CRIT "LLC: Unable to register the sysctl entries\n";
-static const char llc_sock_err_msg[] __initconst =
-	KERN_CRIT "LLC: Unable to register the network family\n";
-
 static int __init llc2_init(void)
 {
 	int rc = proto_register(&llc_proto, 0);
@@ -1234,17 +1227,17 @@ static int __init llc2_init(void)
 	llc_ui_sap_last_autoport = LLC_SAP_DYN_START;
 	rc = llc_proc_init();
 	if (rc != 0) {
-		printk(llc_proc_err_msg);
+		printk(KERN_CRIT "LLC: Unable to register the proc_fs entries\n");
 		goto out_station;
 	}
 	rc = llc_sysctl_init();
 	if (rc) {
-		printk(llc_sysctl_err_msg);
+		printk(KERN_CRIT "LLC: Unable to register the sysctl entries\n");
 		goto out_proc;
 	}
 	rc = sock_register(&llc_ui_family_ops);
 	if (rc) {
-		printk(llc_sock_err_msg);
+		printk(KERN_CRIT "LLC: Unable to register the network family\n");
 		goto out_sysctl;
 	}
 	llc_add_pack(LLC_DEST_SAP, llc_sap_handler);
diff --git a/security/apparmor/lib.c b/security/apparmor/lib.c
index fa49b81eb54c..71a905c061cd 100644
--- a/security/apparmor/lib.c
+++ b/security/apparmor/lib.c
@@ -221,16 +221,16 @@ void aa_perm_mask_to_str(char *str, size_t str_size, const char *chrs, u32 mask)
 void aa_audit_perm_names(struct audit_buffer *ab, const char * const *names,
 			 u32 mask)
 {
-	const char *fmt = "%s";
 	unsigned int i, perm = 1;
 	bool prev = false;
 
 	for (i = 0; i < 32; perm <<= 1, i++) {
 		if (mask & perm) {
-			audit_log_format(ab, fmt, names[i]);
 			if (!prev) {
+				audit_log_format(ab, "%s", names[i]);
 				prev = true;
-				fmt = " %s";
+			} else {
+				audit_log_format(ab, " %s", names[i]);
 			}
 		}
 	}
diff --git a/sound/usb/mixer_scarlett_gen2.c b/sound/usb/mixer_scarlett_gen2.c
index dc803ff3969c..015ce39cdfaa 100644
--- a/sound/usb/mixer_scarlett_gen2.c
+++ b/sound/usb/mixer_scarlett_gen2.c
@@ -3047,12 +3047,10 @@ static int scarlett2_add_line_in_ctls(struct usb_mixer_interface *mixer)
 	const struct scarlett2_device_info *info = private->info;
 	int err, i;
 	char s[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];
-	const char *fmt = "Line In %d %s Capture %s";
-	const char *fmt2 = "Line In %d-%d %s Capture %s";
 
 	/* Add input level (line/inst) controls */
 	for (i = 0; i < info->level_input_count; i++) {
-		snprintf(s, sizeof(s), fmt, i + 1 + info->level_input_first,
+		snprintf(s, sizeof(s), "Line In %d %s Capture %s", i + 1 + info->level_input_first,
 			 "Level", "Enum");
 		err = scarlett2_add_new_ctl(mixer, &scarlett2_level_enum_ctl,
 					    i, 1, s, &private->level_ctls[i]);
@@ -3062,7 +3060,7 @@ static int scarlett2_add_line_in_ctls(struct usb_mixer_interface *mixer)
 
 	/* Add input pad controls */
 	for (i = 0; i < info->pad_input_count; i++) {
-		snprintf(s, sizeof(s), fmt, i + 1, "Pad", "Switch");
+		snprintf(s, sizeof(s), "Line In %d %s Capture %s", i + 1, "Pad", "Switch");
 		err = scarlett2_add_new_ctl(mixer, &scarlett2_pad_ctl,
 					    i, 1, s, &private->pad_ctls[i]);
 		if (err < 0)
@@ -3071,7 +3069,7 @@ static int scarlett2_add_line_in_ctls(struct usb_mixer_interface *mixer)
 
 	/* Add input air controls */
 	for (i = 0; i < info->air_input_count; i++) {
-		snprintf(s, sizeof(s), fmt, i + 1, "Air", "Switch");
+		snprintf(s, sizeof(s), "Line In %d %s Capture %s", i + 1, "Air", "Switch");
 		err = scarlett2_add_new_ctl(mixer, &scarlett2_air_ctl,
 					    i, 1, s, &private->air_ctls[i]);
 		if (err < 0)
@@ -3081,7 +3079,7 @@ static int scarlett2_add_line_in_ctls(struct usb_mixer_interface *mixer)
 	/* Add input phantom controls */
 	if (info->inputs_per_phantom == 1) {
 		for (i = 0; i < info->phantom_count; i++) {
-			snprintf(s, sizeof(s), fmt, i + 1,
+			snprintf(s, sizeof(s), "Line In %d %s Capture %s", i + 1,
 				 "Phantom Power", "Switch");
 			err = scarlett2_add_new_ctl(
 				mixer, &scarlett2_phantom_ctl,
@@ -3094,7 +3092,7 @@ static int scarlett2_add_line_in_ctls(struct usb_mixer_interface *mixer)
 			int from = i * info->inputs_per_phantom + 1;
 			int to = (i + 1) * info->inputs_per_phantom;
 
-			snprintf(s, sizeof(s), fmt2, from, to,
+			snprintf(s, sizeof(s), "Line In %d-%d %s Capture %s", from, to,
 				 "Phantom Power", "Switch");
 			err = scarlett2_add_new_ctl(
 				mixer, &scarlett2_phantom_ctl,
-- 
