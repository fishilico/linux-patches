From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Nicolas Iooss <nicolas.iooss_linux@m4x.org>
Date: Wed, 1 Feb 2017 23:46:54 +0100
Subject: [PATCH] {PRINTF} Move const strings to printk invocations
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This fixes errors like:

    arch/x86/mm/fault.c: In function ‘is_errata93’:
    include/linux/printk.h:345:3: error: Call with a non-constant string
    [-Werror=format-security]
       printk(fmt, ##__VA_ARGS__);   \
       ^~~~~~~~~~~~~~~~~~~~~~~~~~
    arch/x86/mm/fault.c:600:3: note: in expansion of macro ‘printk_once’
       printk_once(errata93_warning);
       ^~~~~~~~~~~
    arch/x86/mm/fault.c: In function ‘show_fault_oops’:
    arch/x86/mm/fault.c:668:4: error: Call with a non-constant string
     [-Werror=format-security]
        printk(nx_warning, from_kuid(&init_user_ns, current_uid()));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    arch/x86/mm/fault.c:672:4: error: Call with a non-constant string
     [-Werror=format-security]
        printk(smep_warning, from_kuid(&init_user_ns, current_uid()));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
---
 arch/arm/mach-omap2/usb-tusb6010.c           |  21 +--
 arch/x86/mm/fault.c                          |  15 +-
 arch/x86/platform/intel-quark/imr_selftest.c |   7 +-
 drivers/accel/habanalabs/gaudi/gaudi.c       |  15 +-
 drivers/clk/ti/adpll.c                       |   3 +-
 drivers/iommu/omap-iommu-debug.c             |   3 +-
 drivers/mtd/mtdcore.c                        |   6 +-
 drivers/net/appletalk/ipddp.c                |   4 +-
 drivers/net/hamradio/6pack.c                 |   9 +-
 drivers/net/hamradio/baycom_epp.c            |   5 +-
 drivers/net/hamradio/mkiss.c                 |   9 +-
 drivers/net/wireless/realtek/rtw89/debug.c   |  11 +-
 drivers/remoteproc/keystone_remoteproc.c     |   5 +-
 drivers/scsi/esas2r/esas2r_log.c             |   6 +-
 drivers/tty/serial/st-asc.c                  |   4 +-
 fs/nilfs2/sysfs.c                            | 168 +++++++++----------
 fs/ntfs/super.c                              |   7 +-
 kernel/power/suspend_test.c                  |  33 +---
 net/802/psnap.c                              |   5 +-
 net/core/net-sysfs.c                         |  56 +++----
 net/llc/af_llc.c                             |  13 +-
 security/apparmor/lib.c                      |   6 +-
 sound/usb/mixer_scarlett_gen2.c              |  12 +-
 23 files changed, 167 insertions(+), 256 deletions(-)

diff --git a/arch/arm/mach-omap2/usb-tusb6010.c b/arch/arm/mach-omap2/usb-tusb6010.c
index b46c254c2bc4..a1420ae1d1c1 100644
--- a/arch/arm/mach-omap2/usb-tusb6010.c
+++ b/arch/arm/mach-omap2/usb-tusb6010.c
@@ -99,9 +99,6 @@ static int tusb_set_sync_mode(unsigned sysclk_ps)
 /* tusb driver calls this when it changes the chip's clocking */
 static int tusb6010_platform_retime(unsigned is_refclk)
 {
-	static const char	error[] =
-		KERN_ERR "tusb6010 %s retime error %d\n";
-
 	unsigned	sysclk_ps;
 	int		status;
 
@@ -112,12 +109,12 @@ static int tusb6010_platform_retime(unsigned is_refclk)
 
 	status = tusb_set_async_mode(sysclk_ps);
 	if (status < 0) {
-		printk(error, "async", status);
+		printk("tusb6010 %s retime error %d\n", "async", status);
 		goto done;
 	}
 	status = tusb_set_sync_mode(sysclk_ps);
 	if (status < 0)
-		printk(error, "sync", status);
+		printk("tusb6010 %s retime error %d\n", "sync", status);
 done:
 	return status;
 }
@@ -155,14 +152,12 @@ int __init tusb6010_setup_interface(struct musb_hdrc_platform_data *data,
 		unsigned int dmachan)
 {
 	int		status;
-	static char	error[] __initdata =
-		KERN_ERR "tusb6010 init error %d, %d\n";
 
 	/* ASYNC region, primarily for PIO */
 	status = gpmc_cs_request(async, SZ_16M, (unsigned long *)
 				&tusb_resources[0].start);
 	if (status < 0) {
-		printk(error, 1, status);
+		printk(KERN_ERR "tusb6010 init error %d, %d\n", 1, status);
 		return status;
 	}
 	tusb_resources[0].end = tusb_resources[0].start + 0x9ff;
@@ -177,7 +172,7 @@ int __init tusb6010_setup_interface(struct musb_hdrc_platform_data *data,
 	status = gpmc_cs_request(sync, SZ_16M, (unsigned long *)
 				&tusb_resources[1].start);
 	if (status < 0) {
-		printk(error, 2, status);
+		printk(KERN_ERR "tusb6010 init error %d, %d\n", 2, status);
 		return status;
 	}
 	tusb_resources[1].end = tusb_resources[1].start + 0x9ff;
@@ -190,19 +185,19 @@ int __init tusb6010_setup_interface(struct musb_hdrc_platform_data *data,
 
 	/* set up memory timings ... can speed them up later */
 	if (!ps_refclk) {
-		printk(error, 4, status);
+		printk(KERN_ERR "tusb6010 init error %d, %d\n", 4, status);
 		return -ENODEV;
 	}
 	refclk_psec = ps_refclk;
 	status = tusb6010_platform_retime(1);
 	if (status < 0) {
-		printk(error, 5, status);
+		printk(KERN_ERR "tusb6010 init error %d, %d\n", 5, status);
 		return status;
 	}
 
 	/* finish device setup ... */
 	if (!data) {
-		printk(error, 6, status);
+		printk(KERN_ERR "tusb6010 init error %d, %d\n", 6, status);
 		return -ENODEV;
 	}
 	tusb_device.dev.platform_data = data;
@@ -210,7 +205,7 @@ int __init tusb6010_setup_interface(struct musb_hdrc_platform_data *data,
 	/* so far so good ... register the device */
 	status = platform_device_register(&tusb_device);
 	if (status < 0) {
-		printk(error, 7, status);
+		printk(KERN_ERR "tusb6010 init error %d, %d\n", 7, status);
 		return status;
 	}
 	return 0;
diff --git a/arch/x86/mm/fault.c b/arch/x86/mm/fault.c
index e8711b2cafaf..f65dc79c64cd 100644
--- a/arch/x86/mm/fault.c
+++ b/arch/x86/mm/fault.c
@@ -330,14 +330,6 @@ static void dump_pagetable(unsigned long address)
 
 #else /* CONFIG_X86_64: */
 
-#ifdef CONFIG_CPU_SUP_AMD
-static const char errata93_warning[] =
-KERN_ERR 
-"******* Your BIOS seems to not contain a fix for K8 errata #93\n"
-"******* Working around it, but it may cause SEGVs or burn power.\n"
-"******* Please consider a BIOS update.\n"
-"******* Disabling USB legacy in the BIOS may also help.\n";
-#endif
 
 static int bad_address(void *p)
 {
@@ -434,7 +426,12 @@ static int is_errata93(struct pt_regs *regs, unsigned long address)
 	address |= 0xffffffffUL << 32;
 	if ((address >= (u64)_stext && address <= (u64)_etext) ||
 	    (address >= MODULES_VADDR && address <= MODULES_END)) {
-		printk_once(errata93_warning);
+		printk_once(
+KERN_ERR
+"******* Your BIOS seems to not contain a fix for K8 errata #93\n"
+"******* Working around it, but it may cause SEGVs or burn power.\n"
+"******* Please consider a BIOS update.\n"
+"******* Disabling USB legacy in the BIOS may also help.\n");
 		regs->ip = address;
 		return 1;
 	}
diff --git a/arch/x86/platform/intel-quark/imr_selftest.c b/arch/x86/platform/intel-quark/imr_selftest.c
index 761f3689f60a..06a6811c5111 100644
--- a/arch/x86/platform/intel-quark/imr_selftest.c
+++ b/arch/x86/platform/intel-quark/imr_selftest.c
@@ -60,7 +60,6 @@ static void __init imr_self_test(void)
 {
 	phys_addr_t base  = virt_to_phys(&_text);
 	size_t size = virt_to_phys(&__end_rodata) - base;
-	const char *fmt_over = "overlapped IMR @ (0x%08lx - 0x%08lx)\n";
 	int ret;
 
 	/* Test zero zero. */
@@ -69,17 +68,17 @@ static void __init imr_self_test(void)
 
 	/* Test exact overlap. */
 	ret = imr_add_range(base, size, IMR_CPU, IMR_CPU);
-	imr_self_test_result(ret < 0, fmt_over, __va(base), __va(base + size));
+	imr_self_test_result(ret < 0, "overlapped IMR @ (%p - %p)\n", __va(base), __va(base + size));
 
 	/* Test overlap with base inside of existing. */
 	base += size - IMR_ALIGN;
 	ret = imr_add_range(base, size, IMR_CPU, IMR_CPU);
-	imr_self_test_result(ret < 0, fmt_over, __va(base), __va(base + size));
+	imr_self_test_result(ret < 0, "overlapped IMR @ (%p - %p)\n", __va(base), __va(base + size));
 
 	/* Test overlap with end inside of existing. */
 	base -= size + IMR_ALIGN * 2;
 	ret = imr_add_range(base, size, IMR_CPU, IMR_CPU);
-	imr_self_test_result(ret < 0, fmt_over, __va(base), __va(base + size));
+	imr_self_test_result(ret < 0, "overlapped IMR @ (%p - %p)\n", __va(base), __va(base + size));
 
 	/* Test that a 1 KiB IMR @ zero with read/write all will bomb out. */
 	ret = imr_add_range(0, IMR_ALIGN, IMR_READ_ACCESS_ALL,
diff --git a/drivers/accel/habanalabs/gaudi/gaudi.c b/drivers/accel/habanalabs/gaudi/gaudi.c
index 056e2ef44afb..b4c913e78ebf 100644
--- a/drivers/accel/habanalabs/gaudi/gaudi.c
+++ b/drivers/accel/habanalabs/gaudi/gaudi.c
@@ -8014,9 +8014,6 @@ static bool gaudi_is_device_idle(struct hl_device *hdev, u64 *mask_arr, u8 mask_
 		struct engines_data *e)
 {
 	struct gaudi_device *gaudi = hdev->asic_specific;
-	const char *fmt = "%-5d%-9s%#-14x%#-12x%#x\n";
-	const char *mme_slave_fmt = "%-5d%-9s%-14s%-12s%#x\n";
-	const char *nic_fmt = "%-5d%-9s%#-14x%#x\n";
 	unsigned long *mask = (unsigned long *)mask_arr;
 	u32 qm_glbl_sts0, qm_cgm_sts, dma_core_sts0, tpc_cfg_sts, mme_arch_sts;
 	bool is_idle = true, is_eng_idle, is_slave;
@@ -8042,7 +8039,7 @@ static bool gaudi_is_device_idle(struct hl_device *hdev, u64 *mask_arr, u8 mask_
 		if (mask && !is_eng_idle)
 			set_bit(GAUDI_ENGINE_ID_DMA_0 + dma_id, mask);
 		if (e)
-			hl_engine_data_sprintf(e, fmt, dma_id,
+			hl_engine_data_sprintf(e, "%-5d%-9s%#-14x%#-12x%#x\n", dma_id,
 				is_eng_idle ? "Y" : "N", qm_glbl_sts0,
 				qm_cgm_sts, dma_core_sts0);
 	}
@@ -8064,7 +8061,7 @@ static bool gaudi_is_device_idle(struct hl_device *hdev, u64 *mask_arr, u8 mask_
 		if (mask && !is_eng_idle)
 			set_bit(GAUDI_ENGINE_ID_TPC_0 + i, mask);
 		if (e)
-			hl_engine_data_sprintf(e, fmt, i,
+			hl_engine_data_sprintf(e, "%-5d%-9s%#-14x%#-12x%#x\n", i,
 				is_eng_idle ? "Y" : "N",
 				qm_glbl_sts0, qm_cgm_sts, tpc_cfg_sts);
 	}
@@ -8093,11 +8090,11 @@ static bool gaudi_is_device_idle(struct hl_device *hdev, u64 *mask_arr, u8 mask_
 			set_bit(GAUDI_ENGINE_ID_MME_0 + i, mask);
 		if (e) {
 			if (!is_slave)
-				hl_engine_data_sprintf(e, fmt, i,
+				hl_engine_data_sprintf(e, "%-5d%-9s%#-14x%#-12x%#x\n", i,
 					is_eng_idle ? "Y" : "N",
 					qm_glbl_sts0, qm_cgm_sts, mme_arch_sts);
 			else
-				hl_engine_data_sprintf(e, mme_slave_fmt, i,
+				hl_engine_data_sprintf(e, "%-5d%-9s%-14s%-12s%#x\n", i,
 					is_eng_idle ? "Y" : "N", "-",
 					"-", mme_arch_sts);
 		}
@@ -8120,7 +8117,7 @@ static bool gaudi_is_device_idle(struct hl_device *hdev, u64 *mask_arr, u8 mask_
 			if (mask && !is_eng_idle)
 				set_bit(GAUDI_ENGINE_ID_NIC_0 + port, mask);
 			if (e)
-				hl_engine_data_sprintf(e, nic_fmt, port,
+				hl_engine_data_sprintf(e, "%-5d%-9s%#-14x%#x\n", port,
 						is_eng_idle ? "Y" : "N",
 						qm_glbl_sts0, qm_cgm_sts);
 		}
@@ -8135,7 +8132,7 @@ static bool gaudi_is_device_idle(struct hl_device *hdev, u64 *mask_arr, u8 mask_
 			if (mask && !is_eng_idle)
 				set_bit(GAUDI_ENGINE_ID_NIC_0 + port, mask);
 			if (e)
-				hl_engine_data_sprintf(e, nic_fmt, port,
+				hl_engine_data_sprintf(e, "%-5d%-9s%#-14x%#x\n", port,
 						is_eng_idle ? "Y" : "N",
 						qm_glbl_sts0, qm_cgm_sts);
 		}
diff --git a/drivers/clk/ti/adpll.c b/drivers/clk/ti/adpll.c
index 6a3542cf910b..b28ee4956602 100644
--- a/drivers/clk/ti/adpll.c
+++ b/drivers/clk/ti/adpll.c
@@ -801,13 +801,12 @@ static int ti_adpll_init_registers(struct ti_adpll_data *d)
 
 static int ti_adpll_init_inputs(struct ti_adpll_data *d)
 {
-	static const char error[] = "need at least %i inputs";
 	struct clk *clock;
 	int nr_inputs;
 
 	nr_inputs = of_clk_get_parent_count(d->np);
 	if (nr_inputs < d->c->nr_max_inputs) {
-		dev_err(d->dev, error, nr_inputs);
+		dev_err(d->dev, "need at least %i inputs", nr_inputs);
 		return -EINVAL;
 	}
 	of_clk_parent_fill(d->np, d->parent_names, nr_inputs);
diff --git a/drivers/iommu/omap-iommu-debug.c b/drivers/iommu/omap-iommu-debug.c
index 259f65291d90..64d359732bfd 100644
--- a/drivers/iommu/omap-iommu-debug.c
+++ b/drivers/iommu/omap-iommu-debug.c
@@ -30,11 +30,10 @@ static inline bool is_omap_iommu_detached(struct omap_iommu *obj)
 #define pr_reg(name)							\
 	do {								\
 		ssize_t bytes;						\
-		const char *str = "%20s: %08x\n";			\
 		const int maxcol = 32;					\
 		if (len < maxcol)					\
 			goto out;					\
-		bytes = scnprintf(p, maxcol, str, __stringify(name),	\
+		bytes = scnprintf(p, maxcol, "%20s: %08x\n", __stringify(name),	\
 				 iommu_read_reg(obj, MMU_##name));	\
 		p += bytes;						\
 		len -= bytes;						\
diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index e00b12aa5ec9..cb27a9880dbd 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -342,12 +342,10 @@ static bool mtd_expert_analysis_mode;
 #ifdef CONFIG_DEBUG_FS
 bool mtd_check_expert_analysis_mode(void)
 {
-	const char *mtd_expert_analysis_warning =
+	return WARN_ONCE(mtd_expert_analysis_mode,
 		"Bad block checks have been entirely disabled.\n"
 		"This is only reserved for post-mortem forensics and debug purposes.\n"
-		"Never enable this mode if you do not know what you are doing!\n";
-
-	return WARN_ONCE(mtd_expert_analysis_mode, mtd_expert_analysis_warning);
+		"Never enable this mode if you do not know what you are doing!\n");
 }
 EXPORT_SYMBOL_GPL(mtd_check_expert_analysis_mode);
 #endif
diff --git a/drivers/net/appletalk/ipddp.c b/drivers/net/appletalk/ipddp.c
index d558535390f9..7800db94db70 100644
--- a/drivers/net/appletalk/ipddp.c
+++ b/drivers/net/appletalk/ipddp.c
@@ -38,8 +38,6 @@
 
 #include "ipddp.h"		/* Our stuff */
 
-static const char version[] = KERN_INFO "ipddp.c:v0.01 8/28/97 Bradford W. Johnson <johns393@maroon.tc.umn.edu>\n";
-
 static struct ipddp_route *ipddp_route_list;
 static DEFINE_SPINLOCK(ipddp_route_lock);
 
@@ -79,7 +77,7 @@ static struct net_device * __init ipddp_init(void)
 	strcpy(dev->name, "ipddp%d");
 
 	if (version_printed++ == 0)
-                printk(version);
+                printk(KERN_INFO "ipddp.c:v0.01 8/28/97 Bradford W. Johnson <johns393@maroon.tc.umn.edu>\n");
 
 	/* Initialize the device structure. */
 	dev->netdev_ops = &ipddp_netdev_ops;
diff --git a/drivers/net/hamradio/6pack.c b/drivers/net/hamradio/6pack.c
index 9fb567524220..b7c79d2c7871 100644
--- a/drivers/net/hamradio/6pack.c
+++ b/drivers/net/hamradio/6pack.c
@@ -756,21 +756,16 @@ static struct tty_ldisc_ops sp_ldisc = {
 
 /* Initialize 6pack control device -- register 6pack line discipline */
 
-static const char msg_banner[]  __initconst = KERN_INFO \
-	"AX.25: 6pack driver, " SIXPACK_VERSION "\n";
-static const char msg_regfail[] __initconst = KERN_ERR  \
-	"6pack: can't register line discipline (err = %d)\n";
-
 static int __init sixpack_init_driver(void)
 {
 	int status;
 
-	printk(msg_banner);
+	printk(KERN_INFO "AX.25: 6pack driver, " SIXPACK_VERSION "\n");
 
 	/* Register the provided line protocol discipline */
 	status = tty_register_ldisc(&sp_ldisc);
 	if (status)
-		printk(msg_regfail, status);
+		printk(KERN_ERR "6pack: can't register line discipline (err = %d)\n", status);
 
 	return status;
 }
diff --git a/drivers/net/hamradio/baycom_epp.c b/drivers/net/hamradio/baycom_epp.c
index 494f524b9a0e..26dccb6cec3d 100644
--- a/drivers/net/hamradio/baycom_epp.c
+++ b/drivers/net/hamradio/baycom_epp.c
@@ -49,9 +49,6 @@
 
 /* --------------------------------------------------------------------- */
 
-static const char paranoia_str[] = KERN_ERR 
-	"baycom_epp: bad magic number for hdlcdrv_state struct in routine %s\n";
-
 static const char bc_drvname[] = "baycom_epp";
 static const char bc_drvinfo[] = KERN_INFO "baycom_epp: (C) 1998-2000 Thomas Sailer, HB9JNX/AE4WA\n"
 "baycom_epp: version 0.7\n";
@@ -1281,7 +1278,7 @@ static void __exit cleanup_baycomepp(void)
 				unregister_netdev(dev);
 				free_netdev(dev);
 			} else
-				printk(paranoia_str, "cleanup_module");
+				printk(KERN_ERR "baycom_epp: bad magic number for hdlcdrv_state struct in routine %s\n", "cleanup_module");
 		}
 	}
 	parport_unregister_driver(&baycom_epp_par_driver);
diff --git a/drivers/net/hamradio/mkiss.c b/drivers/net/hamradio/mkiss.c
index c251e04ae047..fee253895c85 100644
--- a/drivers/net/hamradio/mkiss.c
+++ b/drivers/net/hamradio/mkiss.c
@@ -946,20 +946,15 @@ static struct tty_ldisc_ops ax_ldisc = {
 	.write_wakeup	= mkiss_write_wakeup
 };
 
-static const char banner[] __initconst = KERN_INFO \
-	"mkiss: AX.25 Multikiss, Hans Albas PE1AYX\n";
-static const char msg_regfail[] __initconst = KERN_ERR \
-	"mkiss: can't register line discipline (err = %d)\n";
-
 static int __init mkiss_init_driver(void)
 {
 	int status;
 
-	printk(banner);
+	printk(KERN_INFO "mkiss: AX.25 Multikiss, Hans Albas PE1AYX\n");
 
 	status = tty_register_ldisc(&ax_ldisc);
 	if (status != 0)
-		printk(msg_regfail, status);
+		printk(KERN_ERR "mkiss: can't register line discipline (err = %d)\n", status);
 
 	return status;
 }
diff --git a/drivers/net/wireless/realtek/rtw89/debug.c b/drivers/net/wireless/realtek/rtw89/debug.c
index a4bbac916e22..863f4a415395 100644
--- a/drivers/net/wireless/realtek/rtw89/debug.c
+++ b/drivers/net/wireless/realtek/rtw89/debug.c
@@ -504,21 +504,16 @@ static const struct txpwr_map __txpwr_map_lmt_ru = {
 static u8 __print_txpwr_ent(struct seq_file *m, const struct txpwr_ent *ent,
 			    const s8 *buf, const u8 cur)
 {
-	char *fmt;
-
 	switch (ent->len) {
 	case 2:
-		fmt = "%s\t| %3d, %3d,\tdBm\n";
-		seq_printf(m, fmt, ent->txt, buf[cur], buf[cur + 1]);
+		seq_printf(m, "%s\t| %3d, %3d,\tdBm\n", ent->txt, buf[cur], buf[cur + 1]);
 		return 2;
 	case 4:
-		fmt = "%s\t| %3d, %3d, %3d, %3d,\tdBm\n";
-		seq_printf(m, fmt, ent->txt, buf[cur], buf[cur + 1],
+		seq_printf(m, "%s\t| %3d, %3d, %3d, %3d,\tdBm\n", ent->txt, buf[cur], buf[cur + 1],
 			   buf[cur + 2], buf[cur + 3]);
 		return 4;
 	case 8:
-		fmt = "%s\t| %3d, %3d, %3d, %3d, %3d, %3d, %3d, %3d,\tdBm\n";
-		seq_printf(m, fmt, ent->txt, buf[cur], buf[cur + 1],
+		seq_printf(m, "%s\t| %3d, %3d, %3d, %3d, %3d, %3d, %3d, %3d,\tdBm\n", ent->txt, buf[cur], buf[cur + 1],
 			   buf[cur + 2], buf[cur + 3], buf[cur + 4],
 			   buf[cur + 5], buf[cur + 6], buf[cur + 7]);
 		return 8;
diff --git a/drivers/remoteproc/keystone_remoteproc.c b/drivers/remoteproc/keystone_remoteproc.c
index 7e57b90bcaf8..21168ccbce46 100644
--- a/drivers/remoteproc/keystone_remoteproc.c
+++ b/drivers/remoteproc/keystone_remoteproc.c
@@ -366,7 +366,6 @@ static int keystone_rproc_probe(struct platform_device *pdev)
 	struct rproc *rproc;
 	int dsp_id;
 	char *fw_name = NULL;
-	char *template = "keystone-dsp%d-fw";
 	int name_len = 0;
 	int ret = 0;
 
@@ -382,11 +381,11 @@ static int keystone_rproc_probe(struct platform_device *pdev)
 	}
 
 	/* construct a custom default fw name - subject to change in future */
-	name_len = strlen(template); /* assuming a single digit alias */
+	name_len = strlen("keystone-dsp%d-fw"); /* assuming a single digit alias */
 	fw_name = devm_kzalloc(dev, name_len, GFP_KERNEL);
 	if (!fw_name)
 		return -ENOMEM;
-	snprintf(fw_name, name_len, template, dsp_id);
+	snprintf(fw_name, name_len, "keystone-dsp%d-fw", dsp_id);
 
 	rproc = rproc_alloc(dev, dev_name(dev), &keystone_rproc_ops, fw_name,
 			    sizeof(*ksproc));
diff --git a/drivers/scsi/esas2r/esas2r_log.c b/drivers/scsi/esas2r/esas2r_log.c
index 1672c52f855d..566e15d040b7 100644
--- a/drivers/scsi/esas2r/esas2r_log.c
+++ b/drivers/scsi/esas2r/esas2r_log.c
@@ -128,8 +128,6 @@ static __printf(3, 0) int esas2r_log_master(const long level,
 		int retval = 0;
 		char *buffer = event_buffer;
 		size_t buflen = EVENT_LOG_BUFF_SIZE;
-		const char *fmt_nodev = "%s%s: ";
-		const char *fmt_dev = "%s%s [%s, %s, %s]";
 		const char *slevel =
 			translate_esas2r_event_level_to_kernel(level);
 
@@ -144,10 +142,10 @@ static __printf(3, 0) int esas2r_log_master(const long level,
 		 */
 
 		if (dev == NULL) {
-			snprintf(buffer, buflen, fmt_nodev, slevel,
+			snprintf(buffer, buflen, "%s%s: ", slevel,
 				 ESAS2R_DRVR_NAME);
 		} else {
-			snprintf(buffer, buflen, fmt_dev, slevel,
+			snprintf(buffer, buflen, "%s%s [%s, %s, %s]", slevel,
 				 ESAS2R_DRVR_NAME,
 				 (dev->driver ? dev->driver->name : "unknown"),
 				 (dev->bus ? dev->bus->name : "unknown"),
diff --git a/drivers/tty/serial/st-asc.c b/drivers/tty/serial/st-asc.c
index aa471c9c24d9..35c54bc046fb 100644
--- a/drivers/tty/serial/st-asc.c
+++ b/drivers/tty/serial/st-asc.c
@@ -942,10 +942,8 @@ static struct platform_driver asc_serial_driver = {
 static int __init asc_init(void)
 {
 	int ret;
-	static const char banner[] __initconst =
-		KERN_INFO "STMicroelectronics ASC driver initialized\n";
 
-	printk(banner);
+	printk(KERN_INFO "STMicroelectronics ASC driver initialized\n");
 
 	ret = uart_register_driver(&asc_uart_driver);
 	if (ret)
diff --git a/fs/nilfs2/sysfs.c b/fs/nilfs2/sysfs.c
index 379d22e28ed6..2a8c3d49ef4e 100644
--- a/fs/nilfs2/sysfs.c
+++ b/fs/nilfs2/sysfs.c
@@ -107,16 +107,14 @@ nilfs_snapshot_blocks_count_show(struct nilfs_snapshot_attr *attr,
 			(unsigned long long)atomic64_read(&root->blocks_count));
 }
 
-static const char snapshot_readme_str[] =
-	"The group contains details about mounted snapshot.\n\n"
-	"(1) inodes_count\n\tshow number of inodes for snapshot.\n\n"
-	"(2) blocks_count\n\tshow number of blocks for snapshot.\n\n";
-
 static ssize_t
 nilfs_snapshot_README_show(struct nilfs_snapshot_attr *attr,
 			    struct nilfs_root *root, char *buf)
 {
-	return sysfs_emit(buf, snapshot_readme_str);
+	return sysfs_emit(buf,
+		"The group contains details about mounted snapshot.\n\n"
+		"(1) inodes_count\n\tshow number of inodes for snapshot.\n\n"
+		"(2) blocks_count\n\tshow number of blocks for snapshot.\n\n");
 }
 
 NILFS_SNAPSHOT_RO_ATTR(inodes_count);
@@ -210,15 +208,13 @@ void nilfs_sysfs_delete_snapshot_group(struct nilfs_root *root)
  *                    NILFS mounted snapshots attrs                     *
  ************************************************************************/
 
-static const char mounted_snapshots_readme_str[] =
-	"The mounted_snapshots group contains group for\n"
-	"every mounted snapshot.\n";
-
 static ssize_t
 nilfs_mounted_snapshots_README_show(struct nilfs_mounted_snapshots_attr *attr,
 				    struct the_nilfs *nilfs, char *buf)
 {
-	return sysfs_emit(buf, mounted_snapshots_readme_str);
+	return sysfs_emit(buf,
+		"The mounted_snapshots group contains group for\n"
+		"every mounted snapshot.\n");
 }
 
 NILFS_MOUNTED_SNAPSHOTS_RO_ATTR(README);
@@ -311,20 +307,18 @@ nilfs_checkpoints_next_checkpoint_show(struct nilfs_checkpoints_attr *attr,
 	return sysfs_emit(buf, "%llu\n", cno);
 }
 
-static const char checkpoints_readme_str[] =
-	"The checkpoints group contains attributes that describe\n"
-	"details about volume's checkpoints.\n\n"
-	"(1) checkpoints_number\n\tshow number of checkpoints on volume.\n\n"
-	"(2) snapshots_number\n\tshow number of snapshots on volume.\n\n"
-	"(3) last_seg_checkpoint\n"
-	"\tshow checkpoint number of the latest segment.\n\n"
-	"(4) next_checkpoint\n\tshow next checkpoint number.\n\n";
-
 static ssize_t
 nilfs_checkpoints_README_show(struct nilfs_checkpoints_attr *attr,
 				struct the_nilfs *nilfs, char *buf)
 {
-	return sysfs_emit(buf, checkpoints_readme_str);
+	return sysfs_emit(buf,
+		"The checkpoints group contains attributes that describe\n"
+		"details about volume's checkpoints.\n\n"
+		"(1) checkpoints_number\n\tshow number of checkpoints on volume.\n\n"
+		"(2) snapshots_number\n\tshow number of snapshots on volume.\n\n"
+		"(3) last_seg_checkpoint\n"
+		"\tshow checkpoint number of the latest segment.\n\n"
+		"(4) next_checkpoint\n\tshow next checkpoint number.\n\n");
 }
 
 NILFS_CHECKPOINTS_RO_ATTR(checkpoints_number);
@@ -401,20 +395,18 @@ nilfs_segments_dirty_segments_show(struct nilfs_segments_attr *attr,
 	return sysfs_emit(buf, "%llu\n", sustat.ss_ndirtysegs);
 }
 
-static const char segments_readme_str[] =
-	"The segments group contains attributes that describe\n"
-	"details about volume's segments.\n\n"
-	"(1) segments_number\n\tshow number of segments on volume.\n\n"
-	"(2) blocks_per_segment\n\tshow number of blocks in segment.\n\n"
-	"(3) clean_segments\n\tshow count of clean segments.\n\n"
-	"(4) dirty_segments\n\tshow count of dirty segments.\n\n";
-
 static ssize_t
 nilfs_segments_README_show(struct nilfs_segments_attr *attr,
 			    struct the_nilfs *nilfs,
 			    char *buf)
 {
-	return sysfs_emit(buf, segments_readme_str);
+	return sysfs_emit(buf,
+		"The segments group contains attributes that describe\n"
+		"details about volume's segments.\n\n"
+		"(1) segments_number\n\tshow number of segments on volume.\n\n"
+		"(2) blocks_per_segment\n\tshow number of blocks in segment.\n\n"
+		"(3) clean_segments\n\tshow count of clean segments.\n\n"
+		"(4) dirty_segments\n\tshow count of dirty segments.\n\n");
 }
 
 NILFS_SEGMENTS_RO_ATTR(segments_number);
@@ -624,41 +616,39 @@ nilfs_segctor_dirty_data_blocks_count_show(struct nilfs_segctor_attr *attr,
 	return sysfs_emit(buf, "%u\n", ndirtyblks);
 }
 
-static const char segctor_readme_str[] =
-	"The segctor group contains attributes that describe\n"
-	"segctor thread activity details.\n\n"
-	"(1) last_pseg_block\n"
-	"\tshow start block number of the latest segment.\n\n"
-	"(2) last_seg_sequence\n"
-	"\tshow sequence value of the latest segment.\n\n"
-	"(3) last_seg_checkpoint\n"
-	"\tshow checkpoint number of the latest segment.\n\n"
-	"(4) current_seg_sequence\n\tshow segment sequence counter.\n\n"
-	"(5) current_last_full_seg\n"
-	"\tshow index number of the latest full segment.\n\n"
-	"(6) next_full_seg\n"
-	"\tshow index number of the full segment index to be used next.\n\n"
-	"(7) next_pseg_offset\n"
-	"\tshow offset of next partial segment in the current full segment.\n\n"
-	"(8) next_checkpoint\n\tshow next checkpoint number.\n\n"
-	"(9) last_seg_write_time\n"
-	"\tshow write time of the last segment in human-readable format.\n\n"
-	"(10) last_seg_write_time_secs\n"
-	"\tshow write time of the last segment in seconds.\n\n"
-	"(11) last_nongc_write_time\n"
-	"\tshow write time of the last segment not for cleaner operation "
-	"in human-readable format.\n\n"
-	"(12) last_nongc_write_time_secs\n"
-	"\tshow write time of the last segment not for cleaner operation "
-	"in seconds.\n\n"
-	"(13) dirty_data_blocks_count\n"
-	"\tshow number of dirty data blocks.\n\n";
-
 static ssize_t
 nilfs_segctor_README_show(struct nilfs_segctor_attr *attr,
 			  struct the_nilfs *nilfs, char *buf)
 {
-	return sysfs_emit(buf, segctor_readme_str);
+	return sysfs_emit(buf,
+		"The segctor group contains attributes that describe\n"
+		"segctor thread activity details.\n\n"
+		"(1) last_pseg_block\n"
+		"\tshow start block number of the latest segment.\n\n"
+		"(2) last_seg_sequence\n"
+		"\tshow sequence value of the latest segment.\n\n"
+		"(3) last_seg_checkpoint\n"
+		"\tshow checkpoint number of the latest segment.\n\n"
+		"(4) current_seg_sequence\n\tshow segment sequence counter.\n\n"
+		"(5) current_last_full_seg\n"
+		"\tshow index number of the latest full segment.\n\n"
+		"(6) next_full_seg\n"
+		"\tshow index number of the full segment index to be used next.\n\n"
+		"(7) next_pseg_offset\n"
+		"\tshow offset of next partial segment in the current full segment.\n\n"
+		"(8) next_checkpoint\n\tshow next checkpoint number.\n\n"
+		"(9) last_seg_write_time\n"
+		"\tshow write time of the last segment in human-readable format.\n\n"
+		"(10) last_seg_write_time_secs\n"
+		"\tshow write time of the last segment in seconds.\n\n"
+		"(11) last_nongc_write_time\n"
+		"\tshow write time of the last segment not for cleaner operation "
+		"in human-readable format.\n\n"
+		"(12) last_nongc_write_time_secs\n"
+		"\tshow write time of the last segment not for cleaner operation "
+		"in seconds.\n\n"
+		"(13) dirty_data_blocks_count\n"
+		"\tshow number of dirty data blocks.\n\n");
 }
 
 NILFS_SEGCTOR_RO_ATTR(last_pseg_block);
@@ -787,24 +777,22 @@ nilfs_superblock_sb_update_frequency_store(struct nilfs_superblock_attr *attr,
 	return count;
 }
 
-static const char sb_readme_str[] =
-	"The superblock group contains attributes that describe\n"
-	"superblock's details.\n\n"
-	"(1) sb_write_time\n\tshow previous write time of super block "
-	"in human-readable format.\n\n"
-	"(2) sb_write_time_secs\n\tshow previous write time of super block "
-	"in seconds.\n\n"
-	"(3) sb_write_count\n\tshow write count of super block.\n\n"
-	"(4) sb_update_frequency\n"
-	"\tshow/set interval of periodical update of superblock (in seconds).\n\n"
-	"\tYou can set preferable frequency of superblock update by command:\n\n"
-	"\t'echo <val> > /sys/fs/<nilfs>/<dev>/superblock/sb_update_frequency'\n";
-
 static ssize_t
 nilfs_superblock_README_show(struct nilfs_superblock_attr *attr,
 				struct the_nilfs *nilfs, char *buf)
 {
-	return sysfs_emit(buf, sb_readme_str);
+	return sysfs_emit(buf,
+		"The superblock group contains attributes that describe\n"
+		"superblock's details.\n\n"
+		"(1) sb_write_time\n\tshow previous write time of super block "
+		"in human-readable format.\n\n"
+		"(2) sb_write_time_secs\n\tshow previous write time of super block "
+		"in seconds.\n\n"
+		"(3) sb_write_count\n\tshow write count of super block.\n\n"
+		"(4) sb_update_frequency\n"
+		"\tshow/set interval of periodical update of superblock (in seconds).\n\n"
+		"\tYou can set preferable frequency of superblock update by command:\n\n"
+		"\t'echo <val> > /sys/fs/<nilfs>/<dev>/superblock/sb_update_frequency'\n");
 }
 
 NILFS_SUPERBLOCK_RO_ATTR(sb_write_time);
@@ -895,21 +883,19 @@ ssize_t nilfs_dev_volume_name_show(struct nilfs_dev_attr *attr,
 			 sbp[0]->s_volume_name);
 }
 
-static const char dev_readme_str[] =
-	"The <device> group contains attributes that describe file system\n"
-	"partition's details.\n\n"
-	"(1) revision\n\tshow NILFS file system revision.\n\n"
-	"(2) blocksize\n\tshow volume block size in bytes.\n\n"
-	"(3) device_size\n\tshow volume size in bytes.\n\n"
-	"(4) free_blocks\n\tshow count of free blocks on volume.\n\n"
-	"(5) uuid\n\tshow volume's UUID.\n\n"
-	"(6) volume_name\n\tshow volume's name.\n\n";
-
 static ssize_t nilfs_dev_README_show(struct nilfs_dev_attr *attr,
 				     struct the_nilfs *nilfs,
 				     char *buf)
 {
-	return sysfs_emit(buf, dev_readme_str);
+	return sysfs_emit(buf,
+		"The <device> group contains attributes that describe file system\n"
+		"partition's details.\n\n"
+		"(1) revision\n\tshow NILFS file system revision.\n\n"
+		"(2) blocksize\n\tshow volume block size in bytes.\n\n"
+		"(3) device_size\n\tshow volume size in bytes.\n\n"
+		"(4) free_blocks\n\tshow count of free blocks on volume.\n\n"
+		"(5) uuid\n\tshow volume's UUID.\n\n"
+		"(6) volume_name\n\tshow volume's name.\n\n");
 }
 
 NILFS_DEV_RO_ATTR(revision);
@@ -1058,16 +1044,14 @@ static ssize_t nilfs_feature_revision_show(struct kobject *kobj,
 			NILFS_CURRENT_REV, NILFS_MINOR_REV);
 }
 
-static const char features_readme_str[] =
-	"The features group contains attributes that describe NILFS file\n"
-	"system driver features.\n\n"
-	"(1) revision\n\tshow current revision of NILFS file system driver.\n";
-
 static ssize_t nilfs_feature_README_show(struct kobject *kobj,
 					 struct attribute *attr,
 					 char *buf)
 {
-	return sysfs_emit(buf, features_readme_str);
+	return sysfs_emit(buf,
+		"The features group contains attributes that describe NILFS file\n"
+		"system driver features.\n\n"
+		"(1) revision\n\tshow current revision of NILFS file system driver.\n");
 }
 
 NILFS_FEATURE_RO_ATTR(revision);
diff --git a/fs/ntfs/super.c b/fs/ntfs/super.c
index 56a7d5bd33e4..1a993d6e46d4 100644
--- a/fs/ntfs/super.c
+++ b/fs/ntfs/super.c
@@ -670,7 +670,6 @@ static bool is_boot_sector_ntfs(const struct super_block *sb,
 static struct buffer_head *read_ntfs_boot_sector(struct super_block *sb,
 		const int silent)
 {
-	const char *read_err_str = "Unable to read %s boot sector.";
 	struct buffer_head *bh_primary, *bh_backup;
 	sector_t nr_blocks = NTFS_SB(sb)->nr_blocks;
 
@@ -682,7 +681,7 @@ static struct buffer_head *read_ntfs_boot_sector(struct super_block *sb,
 		if (!silent)
 			ntfs_error(sb, "Primary boot sector is invalid.");
 	} else if (!silent)
-		ntfs_error(sb, read_err_str, "primary");
+		ntfs_error(sb, "Unable to read %s boot sector.", "primary");
 	if (!(NTFS_SB(sb)->on_errors & ON_ERRORS_RECOVER)) {
 		if (bh_primary)
 			brelse(bh_primary);
@@ -698,7 +697,7 @@ static struct buffer_head *read_ntfs_boot_sector(struct super_block *sb,
 			goto hotfix_primary_boot_sector;
 		brelse(bh_backup);
 	} else if (!silent)
-		ntfs_error(sb, read_err_str, "backup");
+		ntfs_error(sb, "Unable to read %s boot sector.", "backup");
 	/* Try to read NT3.51- backup boot sector. */
 	if ((bh_backup = sb_bread(sb, nr_blocks >> 1))) {
 		if (is_boot_sector_ntfs(sb, (NTFS_BOOT_SECTOR*)
@@ -709,7 +708,7 @@ static struct buffer_head *read_ntfs_boot_sector(struct super_block *sb,
 					"sector.");
 		brelse(bh_backup);
 	} else if (!silent)
-		ntfs_error(sb, read_err_str, "backup");
+		ntfs_error(sb, "Unable to read %s boot sector.", "backup");
 	/* We failed. Cleanup and return. */
 	if (bh_primary)
 		brelse(bh_primary);
diff --git a/kernel/power/suspend_test.c b/kernel/power/suspend_test.c
index 1b4a66c3c888..93ad22326d9a 100644
--- a/kernel/power/suspend_test.c
+++ b/kernel/power/suspend_test.c
@@ -61,15 +61,6 @@ void suspend_test_finish(const char *label)
 
 static void __init test_wakealarm(struct rtc_device *rtc, suspend_state_t state)
 {
-	static char err_readtime[] __initdata =
-		KERN_ERR "PM: can't read %s time, err %d\n";
-	static char err_wakealarm [] __initdata =
-		KERN_ERR "PM: can't set %s wakealarm, err %d\n";
-	static char err_suspend[] __initdata =
-		KERN_ERR "PM: suspend test failed, error %d\n";
-	static char info_test[] __initdata =
-		KERN_INFO "PM: test RTC wakeup from '%s' suspend\n";
-
 	time64_t		now;
 	struct rtc_wkalrm	alm;
 	int			status;
@@ -78,7 +69,7 @@ static void __init test_wakealarm(struct rtc_device *rtc, suspend_state_t state)
 repeat:
 	status = rtc_read_time(rtc, &alm.time);
 	if (status < 0) {
-		printk(err_readtime, dev_name(&rtc->dev), status);
+		printk(KERN_ERR "PM: can't read %s time, err %d\n", dev_name(&rtc->dev), status);
 		return;
 	}
 	now = rtc_tm_to_time64(&alm.time);
@@ -89,29 +80,29 @@ static void __init test_wakealarm(struct rtc_device *rtc, suspend_state_t state)
 
 	status = rtc_set_alarm(rtc, &alm);
 	if (status < 0) {
-		printk(err_wakealarm, dev_name(&rtc->dev), status);
+		printk(KERN_ERR "PM: can't set %s wakealarm, err %d\n", dev_name(&rtc->dev), status);
 		return;
 	}
 
 	if (state == PM_SUSPEND_MEM) {
-		printk(info_test, pm_states[state]);
+		printk(KERN_INFO "PM: test RTC wakeup from '%s' suspend\n", pm_states[state]);
 		status = pm_suspend(state);
 		if (status == -ENODEV)
 			state = PM_SUSPEND_STANDBY;
 	}
 	if (state == PM_SUSPEND_STANDBY) {
-		printk(info_test, pm_states[state]);
+		printk(KERN_INFO "PM: test RTC wakeup from '%s' suspend\n", pm_states[state]);
 		status = pm_suspend(state);
 		if (status < 0)
 			state = PM_SUSPEND_TO_IDLE;
 	}
 	if (state == PM_SUSPEND_TO_IDLE) {
-		printk(info_test, pm_states[state]);
+		printk(KERN_INFO "PM: test RTC wakeup from '%s' suspend\n", pm_states[state]);
 		status = pm_suspend(state);
 	}
 
 	if (status < 0)
-		printk(err_suspend, status);
+		printk(KERN_ERR "PM: suspend test failed, error %d\n", status);
 
 	test_repeat_count_current++;
 	if (test_repeat_count_current < test_repeat_count_max)
@@ -144,9 +135,6 @@ static int __init has_wakealarm(struct device *dev, const void *data)
  */
 static const char *test_state_label __initdata;
 
-static char warn_bad_state[] __initdata =
-	KERN_WARNING "PM: can't test '%s' suspend state\n";
-
 static int __init setup_test_suspend(char *value)
 {
 	int i;
@@ -171,16 +159,13 @@ static int __init setup_test_suspend(char *value)
 			return 1;
 		}
 
-	printk(warn_bad_state, suspend_type);
+	printk(KERN_WARNING "PM: can't test '%s' suspend state\n", suspend_type);
 	return 1;
 }
 __setup("test_suspend", setup_test_suspend);
 
 static int __init test_suspend(void)
 {
-	static const char warn_no_rtc[] __initconst =
-		KERN_WARNING "PM: no wakealarm-capable RTC driver is ready\n";
-
 	struct rtc_device	*rtc = NULL;
 	struct device		*dev;
 	suspend_state_t test_state;
@@ -196,7 +181,7 @@ static int __init test_suspend(void)
 			break;
 	}
 	if (test_state == PM_SUSPEND_MAX) {
-		printk(warn_bad_state, test_state_label);
+		printk(KERN_WARNING "PM: can't test '%s' suspend state\n", test_state_label);
 		return 0;
 	}
 
@@ -207,7 +192,7 @@ static int __init test_suspend(void)
 		put_device(dev);
 	}
 	if (!rtc) {
-		printk(warn_no_rtc);
+		printk(KERN_WARNING "PM: no wakealarm-capable RTC driver is ready\n");
 		return 0;
 	}
 
diff --git a/net/802/psnap.c b/net/802/psnap.c
index 1406bfdbda13..ddd5a00bd483 100644
--- a/net/802/psnap.c
+++ b/net/802/psnap.c
@@ -92,14 +92,11 @@ static int snap_request(struct datalink_proto *dl,
 EXPORT_SYMBOL(register_snap_client);
 EXPORT_SYMBOL(unregister_snap_client);
 
-static const char snap_err_msg[] __initconst =
-	KERN_CRIT "SNAP - unable to register with 802.2\n";
-
 static int __init snap_init(void)
 {
 	snap_sap = llc_sap_open(0xAA, snap_rcv);
 	if (!snap_sap) {
-		printk(snap_err_msg);
+		printk(KERN_CRIT "SNAP - unable to register with 802.2\n");
 		return -EBUSY;
 	}
 
diff --git a/net/core/net-sysfs.c b/net/core/net-sysfs.c
index 15e3f4606b5f..e7bebe662f9c 100644
--- a/net/core/net-sysfs.c
+++ b/net/core/net-sysfs.c
@@ -28,10 +28,6 @@
 #include "net-sysfs.h"
 
 #ifdef CONFIG_SYSFS
-static const char fmt_hex[] = "%#x\n";
-static const char fmt_dec[] = "%d\n";
-static const char fmt_ulong[] = "%lu\n";
-static const char fmt_u64[] = "%llu\n";
 
 /* Caller holds RTNL or dev_base_lock */
 static inline int dev_isalive(const struct net_device *dev)
@@ -105,26 +101,26 @@ static ssize_t netdev_store(struct device *dev, struct device_attribute *attr,
 	return ret;
 }
 
-NETDEVICE_SHOW_RO(dev_id, fmt_hex);
-NETDEVICE_SHOW_RO(dev_port, fmt_dec);
-NETDEVICE_SHOW_RO(addr_assign_type, fmt_dec);
-NETDEVICE_SHOW_RO(addr_len, fmt_dec);
-NETDEVICE_SHOW_RO(ifindex, fmt_dec);
-NETDEVICE_SHOW_RO(type, fmt_dec);
-NETDEVICE_SHOW_RO(link_mode, fmt_dec);
+NETDEVICE_SHOW_RO(dev_id, "%#x\n");
+NETDEVICE_SHOW_RO(dev_port, "%d\n");
+NETDEVICE_SHOW_RO(addr_assign_type, "%d\n");
+NETDEVICE_SHOW_RO(addr_len, "%d\n");
+NETDEVICE_SHOW_RO(ifindex, "%d\n");
+NETDEVICE_SHOW_RO(type, "%d\n");
+NETDEVICE_SHOW_RO(link_mode, "%d\n");
 
 static ssize_t iflink_show(struct device *dev, struct device_attribute *attr,
 			   char *buf)
 {
 	struct net_device *ndev = to_net_dev(dev);
 
-	return sysfs_emit(buf, fmt_dec, dev_get_iflink(ndev));
+	return sysfs_emit(buf, "%d\n", dev_get_iflink(ndev));
 }
 static DEVICE_ATTR_RO(iflink);
 
 static ssize_t format_name_assign_type(const struct net_device *dev, char *buf)
 {
-	return sysfs_emit(buf, fmt_dec, dev->name_assign_type);
+	return sysfs_emit(buf, "%d\n", dev->name_assign_type);
 }
 
 static ssize_t name_assign_type_show(struct device *dev,
@@ -194,7 +190,7 @@ static ssize_t carrier_show(struct device *dev,
 	struct net_device *netdev = to_net_dev(dev);
 
 	if (netif_running(netdev))
-		return sysfs_emit(buf, fmt_dec, !!netif_carrier_ok(netdev));
+		return sysfs_emit(buf, "%d\n", !!netif_carrier_ok(netdev));
 
 	return -EINVAL;
 }
@@ -219,7 +215,7 @@ static ssize_t speed_show(struct device *dev,
 		struct ethtool_link_ksettings cmd;
 
 		if (!__ethtool_get_link_ksettings(netdev, &cmd))
-			ret = sysfs_emit(buf, fmt_dec, cmd.base.speed);
+			ret = sysfs_emit(buf, "%d\n", cmd.base.speed);
 	}
 	rtnl_unlock();
 	return ret;
@@ -272,7 +268,7 @@ static ssize_t testing_show(struct device *dev,
 	struct net_device *netdev = to_net_dev(dev);
 
 	if (netif_running(netdev))
-		return sysfs_emit(buf, fmt_dec, !!netif_testing(netdev));
+		return sysfs_emit(buf, "%d\n", !!netif_testing(netdev));
 
 	return -EINVAL;
 }
@@ -284,7 +280,7 @@ static ssize_t dormant_show(struct device *dev,
 	struct net_device *netdev = to_net_dev(dev);
 
 	if (netif_running(netdev))
-		return sysfs_emit(buf, fmt_dec, !!netif_dormant(netdev));
+		return sysfs_emit(buf, "%d\n", !!netif_dormant(netdev));
 
 	return -EINVAL;
 }
@@ -325,7 +321,7 @@ static ssize_t carrier_changes_show(struct device *dev,
 {
 	struct net_device *netdev = to_net_dev(dev);
 
-	return sysfs_emit(buf, fmt_dec,
+	return sysfs_emit(buf, "%d\n",
 			  atomic_read(&netdev->carrier_up_count) +
 			  atomic_read(&netdev->carrier_down_count));
 }
@@ -337,7 +333,7 @@ static ssize_t carrier_up_count_show(struct device *dev,
 {
 	struct net_device *netdev = to_net_dev(dev);
 
-	return sysfs_emit(buf, fmt_dec, atomic_read(&netdev->carrier_up_count));
+	return sysfs_emit(buf, "%d\n", atomic_read(&netdev->carrier_up_count));
 }
 static DEVICE_ATTR_RO(carrier_up_count);
 
@@ -347,7 +343,7 @@ static ssize_t carrier_down_count_show(struct device *dev,
 {
 	struct net_device *netdev = to_net_dev(dev);
 
-	return sysfs_emit(buf, fmt_dec, atomic_read(&netdev->carrier_down_count));
+	return sysfs_emit(buf, "%d\n", atomic_read(&netdev->carrier_down_count));
 }
 static DEVICE_ATTR_RO(carrier_down_count);
 
@@ -363,7 +359,7 @@ static ssize_t mtu_store(struct device *dev, struct device_attribute *attr,
 {
 	return netdev_store(dev, attr, buf, len, change_mtu);
 }
-NETDEVICE_SHOW_RW(mtu, fmt_dec);
+NETDEVICE_SHOW_RW(mtu, "%d\n");
 
 static int change_flags(struct net_device *dev, unsigned long new_flags)
 {
@@ -375,7 +371,7 @@ static ssize_t flags_store(struct device *dev, struct device_attribute *attr,
 {
 	return netdev_store(dev, attr, buf, len, change_flags);
 }
-NETDEVICE_SHOW_RW(flags, fmt_hex);
+NETDEVICE_SHOW_RW(flags, "%#x\n");
 
 static ssize_t tx_queue_len_store(struct device *dev,
 				  struct device_attribute *attr,
@@ -386,7 +382,7 @@ static ssize_t tx_queue_len_store(struct device *dev,
 
 	return netdev_store(dev, attr, buf, len, dev_change_tx_queue_len);
 }
-NETDEVICE_SHOW_RW(tx_queue_len, fmt_dec);
+NETDEVICE_SHOW_RW(tx_queue_len, "%d\n");
 
 static int change_gro_flush_timeout(struct net_device *dev, unsigned long val)
 {
@@ -403,7 +399,7 @@ static ssize_t gro_flush_timeout_store(struct device *dev,
 
 	return netdev_store(dev, attr, buf, len, change_gro_flush_timeout);
 }
-NETDEVICE_SHOW_RW(gro_flush_timeout, fmt_ulong);
+NETDEVICE_SHOW_RW(gro_flush_timeout, "%lu\n");
 
 static int change_napi_defer_hard_irqs(struct net_device *dev, unsigned long val)
 {
@@ -420,7 +416,7 @@ static ssize_t napi_defer_hard_irqs_store(struct device *dev,
 
 	return netdev_store(dev, attr, buf, len, change_napi_defer_hard_irqs);
 }
-NETDEVICE_SHOW_RW(napi_defer_hard_irqs, fmt_dec);
+NETDEVICE_SHOW_RW(napi_defer_hard_irqs, "%d\n");
 
 static ssize_t ifalias_store(struct device *dev, struct device_attribute *attr,
 			     const char *buf, size_t len)
@@ -478,7 +474,7 @@ static ssize_t group_store(struct device *dev, struct device_attribute *attr,
 {
 	return netdev_store(dev, attr, buf, len, change_group);
 }
-NETDEVICE_SHOW(group, fmt_dec);
+NETDEVICE_SHOW(group, "%d\n");
 static DEVICE_ATTR(netdev_group, 0644, group_show, group_store);
 
 static int change_proto_down(struct net_device *dev, unsigned long proto_down)
@@ -492,7 +488,7 @@ static ssize_t proto_down_store(struct device *dev,
 {
 	return netdev_store(dev, attr, buf, len, change_proto_down);
 }
-NETDEVICE_SHOW_RW(proto_down, fmt_dec);
+NETDEVICE_SHOW_RW(proto_down, "%d\n");
 
 static ssize_t phys_port_id_show(struct device *dev,
 				 struct device_attribute *attr, char *buf)
@@ -591,7 +587,7 @@ static ssize_t threaded_show(struct device *dev,
 		return restart_syscall();
 
 	if (dev_isalive(netdev))
-		ret = sysfs_emit(buf, fmt_dec, netdev->threaded);
+		ret = sysfs_emit(buf, "%d\n", netdev->threaded);
 
 	rtnl_unlock();
 	return ret;
@@ -673,7 +669,7 @@ static ssize_t netstat_show(const struct device *d,
 		struct rtnl_link_stats64 temp;
 		const struct rtnl_link_stats64 *stats = dev_get_stats(dev, &temp);
 
-		ret = sysfs_emit(buf, fmt_u64, *(u64 *)(((u8 *)stats) + offset));
+		ret = sysfs_emit(buf,  "%llu\n", *(u64 *)(((u8 *)stats) + offset));
 	}
 	read_unlock(&dev_base_lock);
 	return ret;
@@ -1236,7 +1232,7 @@ static ssize_t tx_timeout_show(struct netdev_queue *queue, char *buf)
 {
 	unsigned long trans_timeout = atomic_long_read(&queue->trans_timeout);
 
-	return sysfs_emit(buf, fmt_ulong, trans_timeout);
+	return sysfs_emit(buf, "%lu\n", trans_timeout);
 }
 
 static unsigned int get_netdev_queue_index(struct netdev_queue *queue)
diff --git a/net/llc/af_llc.c b/net/llc/af_llc.c
index 9b06c380866b..5f5f63b8d486 100644
--- a/net/llc/af_llc.c
+++ b/net/llc/af_llc.c
@@ -1234,13 +1234,6 @@ static const struct proto_ops llc_ui_ops = {
 	.mmap	     = sock_no_mmap,
 };
 
-static const char llc_proc_err_msg[] __initconst =
-	KERN_CRIT "LLC: Unable to register the proc_fs entries\n";
-static const char llc_sysctl_err_msg[] __initconst =
-	KERN_CRIT "LLC: Unable to register the sysctl entries\n";
-static const char llc_sock_err_msg[] __initconst =
-	KERN_CRIT "LLC: Unable to register the network family\n";
-
 static int __init llc2_init(void)
 {
 	int rc = proto_register(&llc_proto, 0);
@@ -1253,17 +1246,17 @@ static int __init llc2_init(void)
 	llc_ui_sap_last_autoport = LLC_SAP_DYN_START;
 	rc = llc_proc_init();
 	if (rc != 0) {
-		printk(llc_proc_err_msg);
+		printk(KERN_CRIT "LLC: Unable to register the proc_fs entries\n");
 		goto out_station;
 	}
 	rc = llc_sysctl_init();
 	if (rc) {
-		printk(llc_sysctl_err_msg);
+		printk(KERN_CRIT "LLC: Unable to register the sysctl entries\n");
 		goto out_proc;
 	}
 	rc = sock_register(&llc_ui_family_ops);
 	if (rc) {
-		printk(llc_sock_err_msg);
+		printk(KERN_CRIT "LLC: Unable to register the network family\n");
 		goto out_sysctl;
 	}
 	llc_add_pack(LLC_DEST_SAP, llc_sap_handler);
diff --git a/security/apparmor/lib.c b/security/apparmor/lib.c
index a630c951bb3b..1ed8d5fdbfee 100644
--- a/security/apparmor/lib.c
+++ b/security/apparmor/lib.c
@@ -240,16 +240,16 @@ void aa_perm_mask_to_str(char *str, size_t str_size, const char *chrs, u32 mask)
 void aa_audit_perm_names(struct audit_buffer *ab, const char * const *names,
 			 u32 mask)
 {
-	const char *fmt = "%s";
 	unsigned int i, perm = 1;
 	bool prev = false;
 
 	for (i = 0; i < 32; perm <<= 1, i++) {
 		if (mask & perm) {
-			audit_log_format(ab, fmt, names[i]);
 			if (!prev) {
+				audit_log_format(ab, "%s", names[i]);
 				prev = true;
-				fmt = " %s";
+			} else {
+				audit_log_format(ab, " %s", names[i]);
 			}
 		}
 	}
diff --git a/sound/usb/mixer_scarlett_gen2.c b/sound/usb/mixer_scarlett_gen2.c
index 33c7c391e7c6..f51d73bf0cab 100644
--- a/sound/usb/mixer_scarlett_gen2.c
+++ b/sound/usb/mixer_scarlett_gen2.c
@@ -3171,12 +3171,10 @@ static int scarlett2_add_line_in_ctls(struct usb_mixer_interface *mixer)
 	const struct scarlett2_device_info *info = private->info;
 	int err, i;
 	char s[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];
-	const char *fmt = "Line In %d %s Capture %s";
-	const char *fmt2 = "Line In %d-%d %s Capture %s";
 
 	/* Add input level (line/inst) controls */
 	for (i = 0; i < info->level_input_count; i++) {
-		snprintf(s, sizeof(s), fmt, i + 1 + info->level_input_first,
+		snprintf(s, sizeof(s), "Line In %d %s Capture %s", i + 1 + info->level_input_first,
 			 "Level", "Enum");
 		err = scarlett2_add_new_ctl(mixer, &scarlett2_level_enum_ctl,
 					    i, 1, s, &private->level_ctls[i]);
@@ -3186,7 +3184,7 @@ static int scarlett2_add_line_in_ctls(struct usb_mixer_interface *mixer)
 
 	/* Add input pad controls */
 	for (i = 0; i < info->pad_input_count; i++) {
-		snprintf(s, sizeof(s), fmt, i + 1, "Pad", "Switch");
+		snprintf(s, sizeof(s), "Line In %d %s Capture %s", i + 1, "Pad", "Switch");
 		err = scarlett2_add_new_ctl(mixer, &scarlett2_pad_ctl,
 					    i, 1, s, &private->pad_ctls[i]);
 		if (err < 0)
@@ -3195,7 +3193,7 @@ static int scarlett2_add_line_in_ctls(struct usb_mixer_interface *mixer)
 
 	/* Add input air controls */
 	for (i = 0; i < info->air_input_count; i++) {
-		snprintf(s, sizeof(s), fmt, i + 1, "Air", "Switch");
+		snprintf(s, sizeof(s), "Line In %d %s Capture %s", i + 1, "Air", "Switch");
 		err = scarlett2_add_new_ctl(mixer, &scarlett2_air_ctl,
 					    i, 1, s, &private->air_ctls[i]);
 		if (err < 0)
@@ -3205,7 +3203,7 @@ static int scarlett2_add_line_in_ctls(struct usb_mixer_interface *mixer)
 	/* Add input phantom controls */
 	if (info->inputs_per_phantom == 1) {
 		for (i = 0; i < info->phantom_count; i++) {
-			snprintf(s, sizeof(s), fmt, i + 1,
+			snprintf(s, sizeof(s), "Line In %d %s Capture %s", i + 1,
 				 "Phantom Power", "Switch");
 			err = scarlett2_add_new_ctl(
 				mixer, &scarlett2_phantom_ctl,
@@ -3218,7 +3216,7 @@ static int scarlett2_add_line_in_ctls(struct usb_mixer_interface *mixer)
 			int from = i * info->inputs_per_phantom + 1;
 			int to = (i + 1) * info->inputs_per_phantom;
 
-			snprintf(s, sizeof(s), fmt2, from, to,
+			snprintf(s, sizeof(s), "Line In %d-%d %s Capture %s", from, to,
 				 "Phantom Power", "Switch");
 			err = scarlett2_add_new_ctl(
 				mixer, &scarlett2_phantom_ctl,
-- 
