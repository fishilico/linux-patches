From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Nicolas Iooss <nicolas.iooss_linux@m4x.org>
Date: Fri, 26 Aug 2016 13:12:46 +0200
Subject: [PATCH] {FRAMA-C} Introduce __FRAMAC__ macro in generic code

- Define specific macros compatible with Frama-C compiler
- In kernel/signal: disable x86-specific bits
- Remove ASM code when it is avoidable (this modifies the
  generated/analyzed code as it means taking the "slow and untested
  fail-over path"
- Simplify SYSCALL_DEFINE macro (Frama-C does not understand complex
  code as the one used to define syscalls)
- Use string functions from Frama-C
---
 drivers/block/drbd/drbd_int.h   |   2 +-
 include/asm-generic/page.h      |   8 ++
 include/asm-generic/uaccess.h   |  15 ++++
 include/linux/compiler.h        |  21 ++++++
 include/linux/compiler_types.h  |   2 +-
 include/linux/cpumask.h         |   5 ++
 include/linux/crypto.h          |   7 +-
 include/linux/delay.h           |  15 +++-
 include/linux/limits.h          |   6 +-
 include/linux/mfd/wl1273-core.h |   2 +
 include/linux/overflow.h        | 126 ++++++++++++++++++++++++++++++++
 include/linux/pci.h             |   3 +
 include/linux/syscalls.h        |   7 ++
 include/uapi/linux/limits.h     |   8 +-
 include/uapi/linux/types.h      |   2 +-
 include/vdso/limits.h           |   4 +
 kernel/signal.c                 |   2 +-
 kernel/time/time.c              |   4 +
 lib/hexdump.c                   |  10 ++-
 19 files changed, 237 insertions(+), 12 deletions(-)

diff --git a/drivers/block/drbd/drbd_int.h b/drivers/block/drbd/drbd_int.h
index 5d9181382ce1..5496081369e5 100644
--- a/drivers/block/drbd/drbd_int.h
+++ b/drivers/block/drbd/drbd_int.h
@@ -39,7 +39,7 @@
 #include "drbd_state.h"
 #include "drbd_protocol.h"
 
-#ifdef __CHECKER__
+#if defined(__CHECKER__) && !defined(__FRAMAC__)
 # define __protected_by(x)       __attribute__((require_context(x,1,999,"rdwr")))
 # define __protected_read_by(x)  __attribute__((require_context(x,1,999,"read")))
 # define __protected_write_by(x) __attribute__((require_context(x,1,999,"write")))
diff --git a/include/asm-generic/page.h b/include/asm-generic/page.h
index 6fc47561814c..70ea99f1931b 100644
--- a/include/asm-generic/page.h
+++ b/include/asm-generic/page.h
@@ -86,8 +86,16 @@ extern unsigned long memory_end;
 
 #define pfn_valid(pfn)		((pfn) >= ARCH_PFN_OFFSET && ((pfn) - ARCH_PFN_OFFSET) < max_mapnr)
 
+#ifdef __FRAMAC__
+/* Prevent Frama-C from reporting errors about:
+ * "ordered comparison of pointer with null pointer [-Werror=extra]"
+ * because PAGE_OFFSET is 0.
+ */
+#define virt_addr_valid(kaddr) ((void *)(kaddr) != NULL)
+#else
 #define	virt_addr_valid(kaddr)	(((void *)(kaddr) >= (void *)PAGE_OFFSET) && \
 				((void *)(kaddr) < (void *)memory_end))
+#endif
 
 #endif /* __ASSEMBLY__ */
 
diff --git a/include/asm-generic/uaccess.h b/include/asm-generic/uaccess.h
index 10ffa8b5c117..6ac78d3994d0 100644
--- a/include/asm-generic/uaccess.h
+++ b/include/asm-generic/uaccess.h
@@ -165,6 +165,20 @@ static inline int __access_ok(unsigned long addr, unsigned long size)
 	__pu_err;						\
 })
 
+#ifdef __FRAMAC__
+/* Frama-C does not like the access_ok() ? ... : ... ; construct:
+ * [kernel] failure: invalid implicit conversion from void to int
+ */
+#define put_user(x, ptr)					\
+({								\
+	void *__p = (ptr);					\
+	int __pu_err = -EFAULT;					\
+	might_fault();						\
+	if (access_ok(__p, sizeof(*ptr)))		\
+		__pu_err = __put_user((x), ((__typeof__(*(ptr)) __user *)__p));;	\
+	__pu_err;						\
+})
+#else
 #define put_user(x, ptr)					\
 ({								\
 	void __user *__p = (ptr);				\
@@ -173,6 +187,7 @@ static inline int __access_ok(unsigned long addr, unsigned long size)
 		__put_user((x), ((__typeof__(*(ptr)) __user *)__p)) :	\
 		-EFAULT;					\
 })
+#endif
 
 #ifndef __put_user_fn
 
diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index a177e32b2191..09d18ffae7d0 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -29,6 +29,27 @@ static noinline notrace __used void __same_pointer_depths_with_volatile2_chk(con
 #define __same_pointer_depths_with_volatile2_chk(p1, p2) do { } while (0)
 #endif
 
+/* Frama-C doesn't understand ASM nor compiler-specific intrisics */
+#ifdef __FRAMAC__
+/* Borrow code from compiler-intel.h */
+#undef barrier
+#undef RELOC_HIDE
+#undef OPTIMIZER_HIDE_VAR
+
+#define barrier() do { } while (0)
+#define RELOC_HIDE(ptr, off) ({ \
+		unsigned long __ptr; \
+		 __ptr = (unsigned long) (ptr); \
+		(typeof(ptr)) (__ptr + (off)); \
+	})
+#define OPTIMIZER_HIDE_VAR(var) barrier()
+
+#include <asm/posix_types.h>
+extern void *memcpy(void *d, const void *s, __kernel_size_t n);
+#define __builtin_memcpy memcpy
+/* #define __builtin_constant_p(x) false   <- the code requires this macro to work */
+#define __builtin_expect(x, v) (x)
+#endif /* __FRAMAC__ */
 /*
  * Note: DISABLE_BRANCH_PROFILING can be used by special lowlevel code
  * to disable branch tracing on a per file basis.
diff --git a/include/linux/compiler_types.h b/include/linux/compiler_types.h
index 6b015468e571..790515958fbb 100644
--- a/include/linux/compiler_types.h
+++ b/include/linux/compiler_types.h
@@ -4,7 +4,7 @@
 
 #ifndef __ASSEMBLY__
 
-#ifdef __CHECKER__
+#if defined(__CHECKER__) && !defined(__FRAMAC__)
 /* address spaces */
 # define __kernel	__attribute__((address_space(0)))
 # define __user		__attribute__((noderef, address_space(__user)))
diff --git a/include/linux/cpumask.h b/include/linux/cpumask.h
index 1e7399fc69c0..4d227496abe5 100644
--- a/include/linux/cpumask.h
+++ b/include/linux/cpumask.h
@@ -847,9 +847,14 @@ set_cpu_dying(unsigned int cpu, bool dying)
  *
  * This does the conversion, and can be used as a constant initializer.
  */
+#ifdef __FRAMAC__
+/* Remove a check using sizeof' side effect in to_cpumask macro definition */
+#define to_cpumask(bitmap) ((struct cpumask *)(bitmap))
+#else
 #define to_cpumask(bitmap)						\
 	((struct cpumask *)(1 ? (bitmap)				\
 			    : (void *)sizeof(__check_is_bitmap(bitmap))))
+#endif
 
 static inline int __check_is_bitmap(const unsigned long *bitmap)
 {
diff --git a/include/linux/crypto.h b/include/linux/crypto.h
index a9773e6ac7ed..983ba993a57a 100644
--- a/include/linux/crypto.h
+++ b/include/linux/crypto.h
@@ -636,7 +636,12 @@ struct crypto_tfm {
 	
 	struct crypto_alg *__crt_alg;
 
-	void *__crt_ctx[] CRYPTO_MINALIGN_ATTR;
+	void *__crt_ctx[0] CRYPTO_MINALIGN_ATTR; /* Add [0] to silence Frama-C error:
+linux: include/linux/crypto.h:550:[kernel] user error: field base is declared with incomplete type struct crypto_tfm
+linux: include/linux/crypto.h:554:[kernel] user error: field base is declared with incomplete type struct crypto_tfm
+linux: include/linux/crypto.h:558:[kernel] user error: field base is declared with incomplete type struct crypto_tfm
+linux: include/linux/crypto.h:562:[kernel] user error: field base is declared with incomplete type struct crypto_tfm
+*/
 };
 
 struct crypto_comp {
diff --git a/include/linux/delay.h b/include/linux/delay.h
index 1d0e2ce6b6d9..5aa8890cd260 100644
--- a/include/linux/delay.h
+++ b/include/linux/delay.h
@@ -40,9 +40,18 @@ extern unsigned long loops_per_jiffy;
 #endif
 
 #ifndef mdelay
-#define mdelay(n) (\
-	(__builtin_constant_p(n) && (n)<=MAX_UDELAY_MS) ? udelay((n)*1000) : \
-	({unsigned long __ms=(n); while (__ms--) udelay(1000);}))
+/* Frama-C does not like the ... ? ... : ... ; construct:
+ * [kernel] failure: invalid implicit conversion from void to void
+ */
+#define mdelay(n) ({ \
+	if (__builtin_constant_p(n) && (n) <= MAX_UDELAY_MS) \
+		udelay((n)*1000); \
+	else { \
+		unsigned long __ms = (n); \
+		while (__ms--) \
+			udelay(1000); \
+	} \
+	})
 #endif
 
 #ifndef ndelay
diff --git a/include/linux/limits.h b/include/linux/limits.h
index b568b9c30bbf..6fc31ffb1344 100644
--- a/include/linux/limits.h
+++ b/include/linux/limits.h
@@ -4,8 +4,12 @@
 
 #include <uapi/linux/limits.h>
 #include <linux/types.h>
-#include <vdso/limits.h>
 
+#ifdef __FRAMAC__
+#include <libc/limits.h>
+#else
+#include <vdso/limits.h>
+#endif /* __FRAMAC__ */
 #define SIZE_MAX	(~(size_t)0)
 #define PHYS_ADDR_MAX	(~(phys_addr_t)0)
 
diff --git a/include/linux/mfd/wl1273-core.h b/include/linux/mfd/wl1273-core.h
index c28cf76d5c31..ac5f907262a2 100644
--- a/include/linux/mfd/wl1273-core.h
+++ b/include/linux/mfd/wl1273-core.h
@@ -204,8 +204,10 @@
 				 WL1273_IS2_TRI_OPT | \
 				 WL1273_IS2_RATE_48K)
 
+#ifndef __FRAMAC__
 #define SCHAR_MIN (-128)
 #define SCHAR_MAX 127
+#endif
 
 #define WL1273_FR_EVENT			BIT(0)
 #define WL1273_BL_EVENT			BIT(1)
diff --git a/include/linux/overflow.h b/include/linux/overflow.h
index 4669632bd72b..5177dded6604 100644
--- a/include/linux/overflow.h
+++ b/include/linux/overflow.h
@@ -51,6 +51,131 @@ static inline bool __must_check __must_check_overflow(bool overflow)
 	return unlikely(overflow);
 }
 
+#if defined(__FRAMAC__)
+/* Checking for unsigned overflow is relatively easy without causing UB. */
+#define __unsigned_add_overflow(a, b, d) ({	\
+	typeof(a) __a = (a);			\
+	typeof(b) __b = (b);			\
+	typeof(d) __d = (d);			\
+	(void) (&__a == &__b);			\
+	(void) (&__a == __d);			\
+	*__d = __a + __b;			\
+	*__d < __a;				\
+})
+#define __unsigned_sub_overflow(a, b, d) ({	\
+	typeof(a) __a = (a);			\
+	typeof(b) __b = (b);			\
+	typeof(d) __d = (d);			\
+	(void) (&__a == &__b);			\
+	(void) (&__a == __d);			\
+	*__d = __a - __b;			\
+	__a < __b;				\
+})
+/*
+ * If one of a or b is a compile-time constant, this avoids a division.
+ */
+#define __unsigned_mul_overflow(a, b, d) ({		\
+	typeof(a) __a = (a);				\
+	typeof(b) __b = (b);				\
+	typeof(d) __d = (d);				\
+	(void) (&__a == &__b);				\
+	(void) (&__a == __d);				\
+	*__d = __a * __b;				\
+	__builtin_constant_p(__b) ?			\
+	  __b > 0 && __a > type_max(typeof(__a)) / __b : \
+	  __a > 0 && __b > type_max(typeof(__b)) / __a;	 \
+})
+
+/*
+ * For signed types, detecting overflow is much harder, especially if
+ * we want to avoid UB. But the interface of these macros is such that
+ * we must provide a result in *d, and in fact we must produce the
+ * result promised by gcc's builtins, which is simply the possibly
+ * wrapped-around value. Fortunately, we can just formally do the
+ * operations in the widest relevant unsigned type (u64) and then
+ * truncate the result - gcc is smart enough to generate the same code
+ * with and without the (u64) casts.
+ */
+
+/*
+ * Adding two signed integers can overflow only if they have the same
+ * sign, and overflow has happened iff the result has the opposite
+ * sign.
+ */
+#define __signed_add_overflow(a, b, d) ({	\
+	typeof(a) __a = (a);			\
+	typeof(b) __b = (b);			\
+	typeof(d) __d = (d);			\
+	(void) (&__a == &__b);			\
+	(void) (&__a == __d);			\
+	*__d = (u64)__a + (u64)__b;		\
+	(((~(__a ^ __b)) & (*__d ^ __a))	\
+		& type_min(typeof(__a))) != 0;	\
+})
+
+/*
+ * Subtraction is similar, except that overflow can now happen only
+ * when the signs are opposite. In this case, overflow has happened if
+ * the result has the opposite sign of a.
+ */
+#define __signed_sub_overflow(a, b, d) ({	\
+	typeof(a) __a = (a);			\
+	typeof(b) __b = (b);			\
+	typeof(d) __d = (d);			\
+	(void) (&__a == &__b);			\
+	(void) (&__a == __d);			\
+	*__d = (u64)__a - (u64)__b;		\
+	((((__a ^ __b)) & (*__d ^ __a))		\
+		& type_min(typeof(__a))) != 0;	\
+})
+
+/*
+ * Signed multiplication is rather hard. gcc always follows C99, so
+ * division is truncated towards 0. This means that we can write the
+ * overflow check like this:
+ *
+ * (a > 0 && (b > MAX/a || b < MIN/a)) ||
+ * (a < -1 && (b > MIN/a || b < MAX/a) ||
+ * (a == -1 && b == MIN)
+ *
+ * The redundant casts of -1 are to silence an annoying -Wtype-limits
+ * (included in -Wextra) warning: When the type is u8 or u16, the
+ * __b_c_e in check_mul_overflow obviously selects
+ * __unsigned_mul_overflow, but unfortunately gcc still parses this
+ * code and warns about the limited range of __b.
+ */
+
+#define __signed_mul_overflow(a, b, d) ({				\
+	typeof(a) __a = (a);						\
+	typeof(b) __b = (b);						\
+	typeof(d) __d = (d);						\
+	typeof(a) __tmax = type_max(typeof(a));				\
+	typeof(a) __tmin = type_min(typeof(a));				\
+	(void) (&__a == &__b);						\
+	(void) (&__a == __d);						\
+	*__d = (u64)__a * (u64)__b;					\
+	(__b > 0   && (__a > __tmax/__b || __a < __tmin/__b)) ||	\
+	(__b < (typeof(__b))-1  && (__a > __tmin/__b || __a < __tmax/__b)) || \
+	(__b == (typeof(__b))-1 && __a == __tmin);			\
+})
+
+
+#define check_add_overflow(a, b, d)	__must_check_overflow(		\
+	__builtin_choose_expr(is_signed_type(typeof(a)),		\
+			__signed_add_overflow(a, b, d),			\
+			__unsigned_add_overflow(a, b, d)))
+
+#define check_sub_overflow(a, b, d)	__must_check_overflow(		\
+	__builtin_choose_expr(is_signed_type(typeof(a)),		\
+			__signed_sub_overflow(a, b, d),			\
+			__unsigned_sub_overflow(a, b, d)))
+
+#define check_mul_overflow(a, b, d)	__must_check_overflow(		\
+	__builtin_choose_expr(is_signed_type(typeof(a)),		\
+			__signed_mul_overflow(a, b, d),			\
+			__unsigned_mul_overflow(a, b, d)))
+
+#else
 /*
  * For simplicity and code hygiene, the fallback code below insists on
  * a, b and *d having the same type (similar to the min() and max()
@@ -85,6 +210,7 @@ static inline bool __must_check __must_check_overflow(bool overflow)
 	(void) (&__a == __d);			\
 	__builtin_mul_overflow(__a, __b, __d);	\
 }))
+#endif /* __FRAMA_C__ */
 
 /** check_shl_overflow() - Calculate a left-shifted value and check overflow
  *
diff --git a/include/linux/pci.h b/include/linux/pci.h
index cd8aa6fce204..d98967b84ec6 100644
--- a/include/linux/pci.h
+++ b/include/linux/pci.h
@@ -168,6 +168,8 @@ typedef int __bitwise pci_power_t;
 #define PCI_UNKNOWN	((pci_power_t __force) 5)
 #define PCI_POWER_ERROR	((pci_power_t __force) -1)
 
+/* Frama-C reports a warning about pci_power_names when !CONFIG_PCI */
+#if !defined(__FRAMAC__) || defined(CONFIG_PCI)
 /* Remember to update this when the list above changes! */
 extern const char *pci_power_names[];
 
@@ -175,6 +177,7 @@ static inline const char *pci_power_name(pci_power_t state)
 {
 	return pci_power_names[1 + (__force int) state];
 }
+#endif
 
 /**
  * typedef pci_channel_state_t
diff --git a/include/linux/syscalls.h b/include/linux/syscalls.h
index a66440765a82..44f53ddde2e8 100644
--- a/include/linux/syscalls.h
+++ b/include/linux/syscalls.h
@@ -234,6 +234,12 @@ static inline int is_syscall_trace_event(struct trace_event_call *tp_event)
  * done within __do_sys_*().
  */
 #ifndef __SYSCALL_DEFINEx
+#ifdef __FRAMAC__
+/* Simplify __SYSCALL_DEFINEx to make frama-C understands code */
+#define __SYSCALL_DEFINEx(x, name, ...)                    \
+	asmlinkage long sys##name(__MAP(x, __SC_DECL, __VA_ARGS__)); \
+	asmlinkage long sys##name(__MAP(x, __SC_DECL, __VA_ARGS__))
+#else
 #define __SYSCALL_DEFINEx(x, name, ...)					\
 	__diag_push();							\
 	__diag_ignore(GCC, 8, "-Wattribute-alias",			\
@@ -252,6 +258,7 @@ static inline int is_syscall_trace_event(struct trace_event_call *tp_event)
 	}								\
 	__diag_pop();							\
 	static inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))
+#endif /* __FRAMAC__ */
 #endif /* __SYSCALL_DEFINEx */
 
 /* For split 64-bit arguments on 32-bit architectures */
diff --git a/include/uapi/linux/limits.h b/include/uapi/linux/limits.h
index 6bcbe3068761..5bfdfa419121 100644
--- a/include/uapi/linux/limits.h
+++ b/include/uapi/linux/limits.h
@@ -4,13 +4,17 @@
 
 #define NR_OPEN	        1024
 
-#define NGROUPS_MAX    65536	/* supplemental group IDs are available */
+#ifdef __FRAMAC__
+#include <libc/limits.h>
+#else
 #define ARG_MAX       131072	/* # bytes of args + environ for exec() */
+#define PATH_MAX        4096	/* # chars in a path name including nul */
+#endif /* __FRAMAC__ */
+#define NGROUPS_MAX    65536	/* supplemental group IDs are available */
 #define LINK_MAX         127	/* # links a file may have */
 #define MAX_CANON        255	/* size of the canonical input queue */
 #define MAX_INPUT        255	/* size of the type-ahead buffer */
 #define NAME_MAX         255	/* # chars in a file name */
-#define PATH_MAX        4096	/* # chars in a path name including nul */
 #define PIPE_BUF        4096	/* # bytes in atomic write to a pipe */
 #define XATTR_NAME_MAX   255	/* # chars in an extended attribute name */
 #define XATTR_SIZE_MAX 65536	/* size of an extended attribute value (64k) */
diff --git a/include/uapi/linux/types.h b/include/uapi/linux/types.h
index f6d2f83cbe29..ae19149149d6 100644
--- a/include/uapi/linux/types.h
+++ b/include/uapi/linux/types.h
@@ -19,7 +19,7 @@
  * any application/library that wants linux/types.h.
  */
 
-#ifdef __CHECKER__
+#if defined(__CHECKER__) && !defined(__FRAMAC__)
 #define __bitwise__ __attribute__((bitwise))
 #else
 #define __bitwise__
diff --git a/include/vdso/limits.h b/include/vdso/limits.h
index 0197888ad0e0..ee5b03df8f9b 100644
--- a/include/vdso/limits.h
+++ b/include/vdso/limits.h
@@ -2,6 +2,9 @@
 #ifndef __VDSO_LIMITS_H
 #define __VDSO_LIMITS_H
 
+#ifdef __FRAMAC__
+#include <libc/limits.h>
+#else
 #define USHRT_MAX	((unsigned short)~0U)
 #define SHRT_MAX	((short)(USHRT_MAX >> 1))
 #define SHRT_MIN	((short)(-SHRT_MAX - 1))
@@ -14,6 +17,7 @@
 #define LLONG_MAX	((long long)(~0ULL >> 1))
 #define LLONG_MIN	(-LLONG_MAX - 1)
 #define ULLONG_MAX	(~0ULL)
+#endif /* __FRAMAC__ */
 #define UINTPTR_MAX	ULONG_MAX
 
 #endif /* __VDSO_LIMITS_H */
diff --git a/kernel/signal.c b/kernel/signal.c
index 952741f6d0f9..56528ade569c 100644
--- a/kernel/signal.c
+++ b/kernel/signal.c
@@ -1263,7 +1263,7 @@ static void print_fatal_signal(int signr)
 	struct pt_regs *regs = signal_pt_regs();
 	pr_info("potentially unexpected fatal signal %d.\n", signr);
 
-#if defined(__i386__) && !defined(__arch_um__)
+#if defined(__i386__) && !defined(__arch_um__) && !defined(__FRAMAC__)
 	pr_info("code at %08lx: ", regs->ip);
 	{
 		int i;
diff --git a/kernel/time/time.c b/kernel/time/time.c
index 29923b20e0e4..5f0f0bf76e91 100644
--- a/kernel/time/time.c
+++ b/kernel/time/time.c
@@ -478,17 +478,21 @@ EXPORT_SYMBOL(ns_to_kernel_old_timeval);
 void set_normalized_timespec64(struct timespec64 *ts, time64_t sec, s64 nsec)
 {
 	while (nsec >= NSEC_PER_SEC) {
+#ifndef __FRAMAC__
 		/*
 		 * The following asm() prevents the compiler from
 		 * optimising this loop into a modulo operation. See
 		 * also __iter_div_u64_rem() in include/linux/time.h
 		 */
 		asm("" : "+rm"(nsec));
+#endif
 		nsec -= NSEC_PER_SEC;
 		++sec;
 	}
 	while (nsec < 0) {
+#ifndef __FRAMAC__
 		asm("" : "+rm"(nsec));
+#endif
 		nsec += NSEC_PER_SEC;
 		--sec;
 	}
diff --git a/lib/hexdump.c b/lib/hexdump.c
index 9301578f98e8..db5510f3827b 100644
--- a/lib/hexdump.c
+++ b/lib/hexdump.c
@@ -111,7 +111,9 @@ int hex_dump_to_buffer(const void *buf, size_t len, int rowsize, int groupsize,
 	u8 ch;
 	int j, lx = 0;
 	int ascii_column;
+#ifndef __FRAMAC__
 	int ret;
+#endif
 
 	if (rowsize != 16 && rowsize != 32)
 		rowsize = 16;
@@ -132,6 +134,10 @@ int hex_dump_to_buffer(const void *buf, size_t len, int rowsize, int groupsize,
 	if (!len)
 		goto nil;
 
+#ifndef __FRAMAC__
+/* Frama-C does not like get_unaligned():
+ * lib/hexdump.c:143:[kernel] failure: lvalue of type void: tmp_0
+ */
 	if (groupsize == 8) {
 		const u64 *ptr8 = buf;
 
@@ -165,7 +171,9 @@ int hex_dump_to_buffer(const void *buf, size_t len, int rowsize, int groupsize,
 				goto overflow1;
 			lx += ret;
 		}
-	} else {
+	} else
+#endif
+	{
 		for (j = 0; j < len; j++) {
 			if (linebuflen < lx + 2)
 				goto overflow2;
-- 
