From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Nicolas Iooss <nicolas.iooss_linux@m4x.org>
Date: Fri, 26 Aug 2016 13:12:46 +0200
Subject: [PATCH] {FRAMA-C} Introduce __FRAMAC__ macro in generic code

- Define specific macros compatible with Frama-C compiler
- In kernel/signal: disable x86-specific bits
- Remove ASM code when it is avoidable (this modifies the
  generated/analyzed code as it means taking the "slow and untested
  fail-over path"
- Simplify SYSCALL_DEFINE macro (Frama-C does not understand complex
  code as the one used to define syscalls)
- Use string functions from Frama-C
---
 drivers/block/drbd/drbd_int.h   |  2 +-
 drivers/input/joystick/analog.c |  6 +++++-
 include/asm-generic/uaccess.h   | 15 +++++++++++++++
 include/linux/compiler.h        | 21 +++++++++++++++++++++
 include/linux/compiler_types.h  |  2 +-
 include/linux/cpumask.h         |  5 +++++
 include/linux/crypto.h          | 11 +++++++++--
 include/linux/delay.h           | 15 ++++++++++++---
 include/linux/flex_array.h      |  5 ++++-
 include/linux/kernel.h          |  9 +++++++++
 include/linux/math64.h          |  2 ++
 include/linux/mfd/wl1273-core.h |  2 ++
 include/linux/overflow.h        |  2 +-
 include/linux/pci.h             |  3 +++
 include/linux/syscalls.h        |  7 +++++++
 include/uapi/linux/limits.h     |  8 ++++++--
 include/uapi/linux/types.h      |  2 +-
 kernel/signal.c                 |  2 +-
 kernel/time/time.c              |  4 ++++
 lib/hexdump.c                   | 10 +++++++++-
 20 files changed, 118 insertions(+), 15 deletions(-)

diff --git a/drivers/block/drbd/drbd_int.h b/drivers/block/drbd/drbd_int.h
index 000a2f4c0e92..8b41e474392d 100644
--- a/drivers/block/drbd/drbd_int.h
+++ b/drivers/block/drbd/drbd_int.h
@@ -51,7 +51,7 @@
 #include "drbd_state.h"
 #include "drbd_protocol.h"
 
-#ifdef __CHECKER__
+#if defined(__CHECKER__) && !defined(__FRAMAC__)
 # define __protected_by(x)       __attribute__((require_context(x,1,999,"rdwr")))
 # define __protected_read_by(x)  __attribute__((require_context(x,1,999,"read")))
 # define __protected_write_by(x) __attribute__((require_context(x,1,999,"write")))
diff --git a/drivers/input/joystick/analog.c b/drivers/input/joystick/analog.c
index 2b445c8d3fcd..3e39b6f4da06 100644
--- a/drivers/input/joystick/analog.c
+++ b/drivers/input/joystick/analog.c
@@ -135,7 +135,11 @@ struct analog_port {
  * Time macros.
  */
 
-#ifdef __i386__
+#ifdef __FRAMAC__
+#define GET_TIME(x)     do { x = analog_faketime++; } while(0)
+#define DELTA(x,y)	((y)-(x))
+#define TIME_NAME	"Unreliable"
+#elif defined(__i386__)
 
 #include <linux/i8253.h>
 
diff --git a/include/asm-generic/uaccess.h b/include/asm-generic/uaccess.h
index d82c78a79da5..7a1a1c867dd0 100644
--- a/include/asm-generic/uaccess.h
+++ b/include/asm-generic/uaccess.h
@@ -74,6 +74,20 @@ static inline int __access_ok(unsigned long addr, unsigned long size)
 	__pu_err;						\
 })
 
+#ifdef __FRAMAC__
+/* Frama-C does not like the access_ok() ? ... : ... ; construct:
+ * [kernel] failure: invalid implicit conversion from void to int
+ */
+#define put_user(x, ptr)					\
+({								\
+	void *__p = (ptr);					\
+	int __pu_err = -EFAULT;					\
+	might_fault();						\
+	if (access_ok(__p, sizeof(*ptr)))		\
+		__pu_err = __put_user((x), ((__typeof__(*(ptr)) __user *)__p));;	\
+	__pu_err;						\
+})
+#else
 #define put_user(x, ptr)					\
 ({								\
 	void __user *__p = (ptr);				\
@@ -82,6 +96,7 @@ static inline int __access_ok(unsigned long addr, unsigned long size)
 		__put_user((x), ((__typeof__(*(ptr)) __user *)__p)) :	\
 		-EFAULT;					\
 })
+#endif
 
 #ifndef __put_user_fn
 
diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index de008180baa4..86b453da87df 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -29,6 +29,27 @@ static noinline __used void __same_pointer_depths_with_volatile2_chk(const void
 #define __same_pointer_depths_with_volatile2_chk(p1, p2) do { } while (0)
 #endif
 
+/* Frama-C doesn't understand ASM nor compiler-specific intrisics */
+#ifdef __FRAMAC__
+/* Borrow code from compiler-intel.h */
+#undef barrier
+#undef RELOC_HIDE
+#undef OPTIMIZER_HIDE_VAR
+
+#define barrier() do { } while (0)
+#define RELOC_HIDE(ptr, off) ({ \
+		unsigned long __ptr; \
+		 __ptr = (unsigned long) (ptr); \
+		(typeof(ptr)) (__ptr + (off)); \
+	})
+#define OPTIMIZER_HIDE_VAR(var) barrier()
+
+#include <asm/posix_types.h>
+extern void *memcpy(void *d, const void *s, __kernel_size_t n);
+#define __builtin_memcpy memcpy
+/* #define __builtin_constant_p(x) false   <- the code requires this macro to work */
+#define __builtin_expect(x, v) (x)
+#endif /* __FRAMAC__ */
 /*
  * Note: DISABLE_BRANCH_PROFILING can be used by special lowlevel code
  * to disable branch tracing on a per file basis.
diff --git a/include/linux/compiler_types.h b/include/linux/compiler_types.h
index ba814f18cb4c..816636acba08 100644
--- a/include/linux/compiler_types.h
+++ b/include/linux/compiler_types.h
@@ -4,7 +4,7 @@
 
 #ifndef __ASSEMBLY__
 
-#ifdef __CHECKER__
+#if defined(__CHECKER__) && !defined(__FRAMAC__)
 # define __user		__attribute__((noderef, address_space(1)))
 # define __kernel	__attribute__((address_space(0)))
 # define __safe		__attribute__((safe))
diff --git a/include/linux/cpumask.h b/include/linux/cpumask.h
index 147bdec42215..86002a9186c0 100644
--- a/include/linux/cpumask.h
+++ b/include/linux/cpumask.h
@@ -835,9 +835,14 @@ set_cpu_active(unsigned int cpu, bool active)
  *
  * This does the conversion, and can be used as a constant initializer.
  */
+#ifdef __FRAMAC__
+/* Remove a check using sizeof' side effect in to_cpumask macro definition */
+#define to_cpumask(bitmap) ((struct cpumask *)(bitmap))
+#else
 #define to_cpumask(bitmap)						\
 	((struct cpumask *)(1 ? (bitmap)				\
 			    : (void *)sizeof(__check_is_bitmap(bitmap))))
+#endif
 
 static inline int __check_is_bitmap(const unsigned long *bitmap)
 {
diff --git a/include/linux/crypto.h b/include/linux/crypto.h
index 5615e8822db3..2c2ba6b48862 100644
--- a/include/linux/crypto.h
+++ b/include/linux/crypto.h
@@ -179,7 +179,9 @@ struct ablkcipher_request {
 	struct scatterlist *src;
 	struct scatterlist *dst;
 
-	void *__ctx[] CRYPTO_MINALIGN_ATTR;
+	void *__ctx[0] CRYPTO_MINALIGN_ATTR; /* Add [0] to silence Frama-C error:
+linux: include/crypto/skcipher.h:48:[kernel] user error: field creq is declared with incomplete type struct ablkcipher_request
+*/
 };
 
 struct blkcipher_desc {
@@ -776,7 +778,12 @@ struct crypto_tfm {
 	
 	struct crypto_alg *__crt_alg;
 
-	void *__crt_ctx[] CRYPTO_MINALIGN_ATTR;
+	void *__crt_ctx[0] CRYPTO_MINALIGN_ATTR; /* Add [0] to silence Frama-C error:
+linux: include/linux/crypto.h:550:[kernel] user error: field base is declared with incomplete type struct crypto_tfm
+linux: include/linux/crypto.h:554:[kernel] user error: field base is declared with incomplete type struct crypto_tfm
+linux: include/linux/crypto.h:558:[kernel] user error: field base is declared with incomplete type struct crypto_tfm
+linux: include/linux/crypto.h:562:[kernel] user error: field base is declared with incomplete type struct crypto_tfm
+*/
 };
 
 struct crypto_ablkcipher {
diff --git a/include/linux/delay.h b/include/linux/delay.h
index b78bab4395d8..7eff042dcd06 100644
--- a/include/linux/delay.h
+++ b/include/linux/delay.h
@@ -40,9 +40,18 @@ extern unsigned long loops_per_jiffy;
 #endif
 
 #ifndef mdelay
-#define mdelay(n) (\
-	(__builtin_constant_p(n) && (n)<=MAX_UDELAY_MS) ? udelay((n)*1000) : \
-	({unsigned long __ms=(n); while (__ms--) udelay(1000);}))
+/* Frama-C does not like the ... ? ... : ... ; construct:
+ * [kernel] failure: invalid implicit conversion from void to void
+ */
+#define mdelay(n) ({ \
+	if (__builtin_constant_p(n) && (n) <= MAX_UDELAY_MS) \
+		udelay((n)*1000); \
+	else { \
+		unsigned long __ms = (n); \
+		while (__ms--) \
+			udelay(1000); \
+	} \
+	})
 #endif
 
 #ifndef ndelay
diff --git a/include/linux/flex_array.h b/include/linux/flex_array.h
index b94fa61b51fb..ffd6208aabbd 100644
--- a/include/linux/flex_array.h
+++ b/include/linux/flex_array.h
@@ -25,7 +25,10 @@ struct flex_array {
 			int total_nr_elements;
 			int elems_per_part;
 			struct reciprocal_value reciprocal_elems;
-			struct flex_array_part *parts[];
+			struct flex_array_part *parts[0]; /* Add [0] to silent Frama-C errors:
+include/linux/flex_array.h:20:[kernel] user error: field  is declared with incomplete type struct __anonstruct_14
+include/linux/flex_array.h:20:[kernel] user error: field  is declared with incomplete type union __anonunion_13
+*/
 		};
 		/*
 		 * This little trick makes sure that
diff --git a/include/linux/kernel.h b/include/linux/kernel.h
index 346f64b5ed5b..3cd458dd2415 100644
--- a/include/linux/kernel.h
+++ b/include/linux/kernel.h
@@ -16,6 +16,9 @@
 #include <asm/byteorder.h>
 #include <uapi/linux/kernel.h>
 
+#ifdef __FRAMAC__
+#include <libc/limits.h>
+#else
 #define USHRT_MAX	((u16)(~0U))
 #define SHRT_MAX	((s16)(USHRT_MAX>>1))
 #define SHRT_MIN	((s16)(-SHRT_MAX - 1))
@@ -28,6 +31,7 @@
 #define LLONG_MAX	((long long)(~0ULL>>1))
 #define LLONG_MIN	(-LLONG_MAX - 1)
 #define ULLONG_MAX	(~0ULL)
+#endif /* __FRAMAC__ */
 #define SIZE_MAX	(~(size_t)0)
 #define PHYS_ADDR_MAX	(~(phys_addr_t)0)
 
@@ -279,6 +283,10 @@ extern int _cond_resched(void);
  *
  * Return: an absolute value of x.
  */
+#ifdef __FRAMAC__
+/* Frama-C does not like abs(): [kernel] failure: cannot cast from void to int */
+#define abs(x) ({ __typeof__(x) __x = (x); __x < 0 ? -__x : __x; })
+#else
 #define abs(x)	__abs_choose_expr(x, long long,				\
 		__abs_choose_expr(x, long,				\
 		__abs_choose_expr(x, int,				\
@@ -293,6 +301,7 @@ extern int _cond_resched(void);
 	__builtin_types_compatible_p(typeof(x),   signed type) ||	\
 	__builtin_types_compatible_p(typeof(x), unsigned type),		\
 	({ signed type __x = (x); __x < 0 ? -__x : __x; }), other)
+#endif
 
 /**
  * reciprocal_scale - "scale" a value into range [0, ep_ro)
diff --git a/include/linux/math64.h b/include/linux/math64.h
index bb2c84afb80c..9a4ed3a11c71 100644
--- a/include/linux/math64.h
+++ b/include/linux/math64.h
@@ -148,9 +148,11 @@ __iter_div_u64_rem(u64 dividend, u32 divisor, u64 *remainder)
 	u32 ret = 0;
 
 	while (dividend >= divisor) {
+#ifndef __FRAMAC__
 		/* The following asm() prevents the compiler from
 		   optimising this loop into a modulo operation.  */
 		asm("" : "+rm"(dividend));
+#endif
 
 		dividend -= divisor;
 		ret++;
diff --git a/include/linux/mfd/wl1273-core.h b/include/linux/mfd/wl1273-core.h
index db2f3f454a1b..5124ce3698dc 100644
--- a/include/linux/mfd/wl1273-core.h
+++ b/include/linux/mfd/wl1273-core.h
@@ -217,8 +217,10 @@
 				 WL1273_IS2_TRI_OPT | \
 				 WL1273_IS2_RATE_48K)
 
+#ifndef __FRAMAC__
 #define SCHAR_MIN (-128)
 #define SCHAR_MAX 127
+#endif
 
 #define WL1273_FR_EVENT			BIT(0)
 #define WL1273_BL_EVENT			BIT(1)
diff --git a/include/linux/overflow.h b/include/linux/overflow.h
index 40b48e2133cb..0262548f9fc5 100644
--- a/include/linux/overflow.h
+++ b/include/linux/overflow.h
@@ -37,7 +37,7 @@
 #define type_min(T) ((T)((T)-type_max(T)-(T)1))
 
 
-#ifdef COMPILER_HAS_GENERIC_BUILTIN_OVERFLOW
+#if !defined(__FRAMAC__) && defined(COMPILER_HAS_GENERIC_BUILTIN_OVERFLOW)
 /*
  * For simplicity and code hygiene, the fallback code below insists on
  * a, b and *d having the same type (similar to the min() and max()
diff --git a/include/linux/pci.h b/include/linux/pci.h
index 65f1d8c2f082..7e4161da463a 100644
--- a/include/linux/pci.h
+++ b/include/linux/pci.h
@@ -137,6 +137,8 @@ typedef int __bitwise pci_power_t;
 #define PCI_UNKNOWN	((pci_power_t __force) 5)
 #define PCI_POWER_ERROR	((pci_power_t __force) -1)
 
+/* Frama-C reports a warning about pci_power_names when !CONFIG_PCI */
+#if !defined(__FRAMAC__) || defined(CONFIG_PCI)
 /* Remember to update this when the list above changes! */
 extern const char *pci_power_names[];
 
@@ -144,6 +146,7 @@ static inline const char *pci_power_name(pci_power_t state)
 {
 	return pci_power_names[1 + (__force int) state];
 }
+#endif
 
 #define PCI_PM_D2_DELAY		200
 #define PCI_PM_D3_WAIT		10
diff --git a/include/linux/syscalls.h b/include/linux/syscalls.h
index b767a425df8d..8dc84892db70 100644
--- a/include/linux/syscalls.h
+++ b/include/linux/syscalls.h
@@ -232,6 +232,12 @@ static inline int is_syscall_trace_event(struct trace_event_call *tp_event)
  * done within __do_sys_*().
  */
 #ifndef __SYSCALL_DEFINEx
+#ifdef __FRAMAC__
+/* Simplify __SYSCALL_DEFINEx to make frama-C understands code */
+#define __SYSCALL_DEFINEx(x, name, ...)                    \
+	asmlinkage long sys##name(__MAP(x, __SC_DECL, __VA_ARGS__)); \
+	asmlinkage long sys##name(__MAP(x, __SC_DECL, __VA_ARGS__))
+#else
 #define __SYSCALL_DEFINEx(x, name, ...)					\
 	__diag_push();							\
 	__diag_ignore(GCC, 8, "-Wattribute-alias",			\
@@ -250,6 +256,7 @@ static inline int is_syscall_trace_event(struct trace_event_call *tp_event)
 	}								\
 	__diag_pop();							\
 	static inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))
+#endif /* __FRAMAC__ */
 #endif /* __SYSCALL_DEFINEx */
 
 /*
diff --git a/include/uapi/linux/limits.h b/include/uapi/linux/limits.h
index c3547f07605c..52132e03273b 100644
--- a/include/uapi/linux/limits.h
+++ b/include/uapi/linux/limits.h
@@ -4,13 +4,17 @@
 
 #define NR_OPEN	        1024
 
-#define NGROUPS_MAX    65536	/* supplemental group IDs are available */
+#ifdef __FRAMAC__
+#include <libc/limits.h>
+#else
 #define ARG_MAX       131072	/* # bytes of args + environ for exec() */
+#define PATH_MAX        4096	/* # chars in a path name including nul */
+#endif /* __FRAMAC__ */
+#define NGROUPS_MAX    65536	/* supplemental group IDs are available */
 #define LINK_MAX         127	/* # links a file may have */
 #define MAX_CANON        255	/* size of the canonical input queue */
 #define MAX_INPUT        255	/* size of the type-ahead buffer */
 #define NAME_MAX         255	/* # chars in a file name */
-#define PATH_MAX        4096	/* # chars in a path name including nul */
 #define PIPE_BUF        4096	/* # bytes in atomic write to a pipe */
 #define XATTR_NAME_MAX   255	/* # chars in an extended attribute name */
 #define XATTR_SIZE_MAX 65536	/* size of an extended attribute value (64k) */
diff --git a/include/uapi/linux/types.h b/include/uapi/linux/types.h
index 2fce8b6876e9..357ff7b0ecdd 100644
--- a/include/uapi/linux/types.h
+++ b/include/uapi/linux/types.h
@@ -19,7 +19,7 @@
  * any application/library that wants linux/types.h.
  */
 
-#ifdef __CHECKER__
+#if defined(__CHECKER__) && !defined(__FRAMAC__)
 #define __bitwise__ __attribute__((bitwise))
 #else
 #define __bitwise__
diff --git a/kernel/signal.c b/kernel/signal.c
index e1d7ad8e6ab1..dac0743c23b6 100644
--- a/kernel/signal.c
+++ b/kernel/signal.c
@@ -1168,7 +1168,7 @@ static void print_fatal_signal(int signr)
 	struct pt_regs *regs = signal_pt_regs();
 	pr_info("potentially unexpected fatal signal %d.\n", signr);
 
-#if defined(__i386__) && !defined(__arch_um__)
+#if defined(__i386__) && !defined(__arch_um__) && !defined(__FRAMAC__)
 	pr_info("code at %08lx: ", regs->ip);
 	{
 		int i;
diff --git a/kernel/time/time.c b/kernel/time/time.c
index 2edb5088a70b..7a7b970a55e6 100644
--- a/kernel/time/time.c
+++ b/kernel/time/time.c
@@ -455,17 +455,21 @@ EXPORT_SYMBOL(ns_to_kernel_old_timeval);
 void set_normalized_timespec64(struct timespec64 *ts, time64_t sec, s64 nsec)
 {
 	while (nsec >= NSEC_PER_SEC) {
+#ifndef __FRAMAC__
 		/*
 		 * The following asm() prevents the compiler from
 		 * optimising this loop into a modulo operation. See
 		 * also __iter_div_u64_rem() in include/linux/time.h
 		 */
 		asm("" : "+rm"(nsec));
+#endif
 		nsec -= NSEC_PER_SEC;
 		++sec;
 	}
 	while (nsec < 0) {
+#ifndef __FRAMAC__
 		asm("" : "+rm"(nsec));
+#endif
 		nsec += NSEC_PER_SEC;
 		--sec;
 	}
diff --git a/lib/hexdump.c b/lib/hexdump.c
index 81b70ed37209..5d623c883793 100644
--- a/lib/hexdump.c
+++ b/lib/hexdump.c
@@ -114,7 +114,9 @@ int hex_dump_to_buffer(const void *buf, size_t len, int rowsize, int groupsize,
 	u8 ch;
 	int j, lx = 0;
 	int ascii_column;
+#ifndef __FRAMAC__
 	int ret;
+#endif
 
 	if (rowsize != 16 && rowsize != 32)
 		rowsize = 16;
@@ -135,6 +137,10 @@ int hex_dump_to_buffer(const void *buf, size_t len, int rowsize, int groupsize,
 	if (!len)
 		goto nil;
 
+#ifndef __FRAMAC__
+/* Frama-C does not like get_unaligned():
+ * lib/hexdump.c:143:[kernel] failure: lvalue of type void: tmp_0
+ */
 	if (groupsize == 8) {
 		const u64 *ptr8 = buf;
 
@@ -168,7 +174,9 @@ int hex_dump_to_buffer(const void *buf, size_t len, int rowsize, int groupsize,
 				goto overflow1;
 			lx += ret;
 		}
-	} else {
+	} else
+#endif
+	{
 		for (j = 0; j < len; j++) {
 			if (linebuflen < lx + 2)
 				goto overflow2;
-- 
